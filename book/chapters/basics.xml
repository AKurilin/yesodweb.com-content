<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">
<chapter>
  <title>Basics</title>

  <para>The first step with any new technology is getting it running. The goal
  of this chapter is to get you started with a simple Yesod application, and
  cover some of the basic concepts and terminology.</para>

  <section>
    <title>Hello World</title>

    <para>Let's get this book started properly: a simple web page that says
    Hello World:</para>

    <programlisting language="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Hello World!|]

main :: IO ()
main = warpDebug 3000 HelloWorld</programlisting>

    <para>If you save that code in <literal>helloworld.hs</literal> and run it
    with <literal>runhaskell helloworld.hs</literal>, you'll get a web server
    running on port 3000. If you point your browser to <ulink
    url="http://localhost:3000">http://localhost:3000</ulink>, you'll get the
    following HTML:</para>

    <programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;</programlisting>

    <para>We'll refer back to this example through the rest of the
    chapter.</para>
  </section>

  <section>
    <title>Routing</title>

    <para>Like most modern web frameworks, Yesod follows a <ulink
    url="http://en.wikipedia.org/wiki/Front_Controller_pattern">front
    controller pattern</ulink>. This means that every request to a Yesod
    application enters at the same point and is routed from there. As a
    contrast, in systems like PHP and ASP you usually create a number of
    different files, and the web server automatically directs requests to the
    relevant file.</para>

    <para>In addition, Yesod uses a declarative style for specifying routes.
    In our example above, this looked like:</para>

    <programlisting language="haskell">mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]</programlisting>

    <note>
      <para><literal>mkYesod</literal> is a Template Haskell function, and
      <literal>parseRoutes</literal> is a QuasiQuoter.</para>
    </note>

    <para>In English, all this means is: <quote>In the HelloWorld application,
    create one route. I'd like to call it <literal>HomeR</literal>, it should
    listen for requests to <literal>/</literal> (the root of the application),
    and should answer <literal>GET</literal> requests</quote>. We call
    <literal>HomeR</literal> a <glossterm>resource</glossterm>, which is where
    the "R" suffix comes from.<note>
        <para>The R suffix on resource names is simply convention, but it's a
        fairly universally followed convention. It makes it just a bit easier
        to read and understand code.</para>
      </note></para>

    <para>The <literal>mkYesod</literal> TH function generates quite a bit of
    code here: a route data type, a dispatch function, and a render function.
    We'll look at this in more detail in the routing chapter. But by using the
    <literal>-ddump-splices</literal> GHC option, we can get an immediate look
    at the generated code. A much cleaned up version of it is:</para>

    <programlisting language="haskell">instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -&gt; f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -&gt; app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method -&gt;
            case method of
                "GET" -&gt; yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -&gt; app405 HomeR
</programlisting>

    <para>Some of that will likely not make sense yet. In particular, the
    implementation of <literal>yesodDispatch</literal> is a bit hairy to
    accomodate different dispatch approaches and fit the model necessary for
    our high-performance routing structures. However, the
    <literal>RenderRoute</literal> implementation with its associated data
    type should already give you a good feel for what's going on under the
    surface.</para>
  </section>

  <section>
    <title>Handler function</title>

    <para>So we have a route named <literal>HomeR</literal>, and it responds
    to <literal>GET</literal> requests. How do you define your response? You
    write a <glossterm>handler function</glossterm>. Yesod follows a standard
    naming scheme for these functions: it's the lower case method name (e.g.,
    <literal>GET</literal> becomes <literal>get</literal>) followed by the
    route name. In this case, the function name would be
    <literal>getHomeR</literal>.</para>

    <para>Most of the code you write in Yesod lives in handler functions. This
    is where you process user input, perform database queries and create
    responses. In our simple example, we create a response using the
    <literal>defaultLayout</literal> function. This function wraps up the
    content it's given in your site's template. By default, it produces an
    HTML file with a doctype and <literal>html</literal>,
    <literal>head</literal> and <literal>body</literal> tags. As we'll see in
    the Yesod typeclass chapter, this function can be overridden to do much
    more.</para>

    <para>In our example, we pass <literal>[whamlet|Hello World!|]</literal>
    to <literal>defaultLayout</literal>. <literal>whamlet</literal> is another
    quasi-quoter. In this case, it converts Hamlet syntax into a Widget.
    Hamlet is the default HTML templating engine in Yesod. Together with its
    siblings Cassius, Lucius and Julius, you can create HTML, CSS and
    Javascript in a fully type-safe and compile-time-checked manner. We'll see
    much more about this in the Shakespeare chapter.</para>

    <para>Widgets are another cornerstone of Yesod. They allow you to create
    modular components of a site consisting of HTML, CSS and Javascript and
    reuse them throughout your site. We'll get into more detail on them in the
    widgets chapter.</para>
  </section>

  <section>
    <title>The Foundation</title>

    <para>The word "HelloWorld" shows up a number of times in our example.
    Every Yesod application has a <glossterm>foundation</glossterm> datatype.
    This datatype must be an instance of the Yesod typeclass, which provides a
    central place for declaring a number of different settings controlling the
    execution of our application.</para>

    <para>In our case, this datatype is pretty boring: it doesn't contain any
    information. Nonetheless, the foundation is central to how our example
    runs: it ties together the routes with the instance declaration and lets
    it all be run. We'll see throughout this book that the foundation pops up
    in a whole bunch of places.</para>

    <para>But foundations don't have to be boring: they can be used to store
    lots of useful information, usually stuff that needs to be initialized at
    program launch and used throughout. Some very common examples are:</para>

    <itemizedlist>
      <listitem>
        <para>A database connection pool.</para>
      </listitem>

      <listitem>
        <para>Settings loaded from a config file.</para>
      </listitem>

      <listitem>
        <para>An HTTP connection manager.</para>
      </listitem>
    </itemizedlist>

    <note>
      <para>By the way, the word Yesod (יסוד) means
      <emphasis>foundation</emphasis> in Hebrew.</para>
    </note>
  </section>

  <section>
    <title>Running</title>

    <para>Once again we mention <literal>HelloWorld</literal> in our main
    function. Our foundation contains all the information we need to route and
    respond to requests in our application; now we just need to convert it
    into something that can run. A useful function for this in Yesod is
    <literal>warpDebug</literal>, which runs the Warp webserver with debug
    output enabled on the specified port (here, it's 3000).</para>

    <para>One of the features of Yesod is that you aren't tied down to a
    single deployment strategy. Yesod is built on top of the Web Application
    Interface (WAI), allowing it to run on FastCGI, SCGI, Warp, or even as a
    desktop application using the Webkit library. We'll discuss some of these
    options in the deployment chapter. And at the end of this chapter, we will
    explain the development server.</para>

    <para>Warp is the premiere deployment option for Yesod. It is a
    lightweight, highly efficient web server developed specifically for
    hosting Yesod. It is also used outside of Yesod for other Haskell
    development (both framework and non-framework applications), as well as a
    standard file server in a number of production environments.</para>
  </section>

  <section>
    <title>Resources and type-safe URLs</title>

    <para>In our hello world, we defined just a single resource
    (<literal>HomeR</literal>). A web application is usually much more
    exciting with more than one page on it. Let's take a look:</para>

    <programlisting language="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|&lt;a href=@{Page1R}&gt;Go to page 1!|]
getPage1R = defaultLayout [whamlet|&lt;a href=@{Page2R}&gt;Go to page 2!|]
getPage2R = defaultLayout [whamlet|&lt;a href=@{HomeR}&gt;Go home!|]

main = warpDebug 3000 Links</programlisting>

    <para>Overall, this is very similar to Hello World. Our foundation is now
    <literal>Links</literal> instead of <literal>HelloWorld</literal>, and in
    addition to the <literal>HomeR</literal> resource, we've added
    <literal>Page1R</literal> and <literal>Page2R</literal>. As such, we've
    also added two more handler functions: <literal>getPage1R</literal> and
    <literal>getPage2R</literal>.</para>

    <para>The only truly new feature is inside the <literal>whamlet</literal>
    quasi-quotation. We'll delve into syntax in the Shakespeare chapter, but
    we can see that:</para>

    <programlisting>&lt;a href=@{Page1R}&gt;Go to page 1!</programlisting>

    <para>creates a link to the <literal>Page1R</literal> resource. The
    important thing to note here is that <literal>Page1R</literal> is a data
    constructor. By making each resource a data constructor, we have a feature
    called <glossterm>type-safe URLs</glossterm>. Instead of splicing together
    strings to create URLs, we simply create a plain old Haskell value. By
    using at-sign interpolation (<literal>@{...}</literal>), Yesod
    automatically renders those values to textual URLs before sending things
    off to the user. We can see how this is implemented by looking again at
    the <command>-ddump-splices</command> output:</para>

    <programlisting language="haskell">instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])
</programlisting>

    <para>In the <literal>Route</literal> associated type for
    <literal>Links</literal>, we have additional constructors for
    <literal>Page1R</literal> and <literal>Page2R</literal>. We also now have
    a better glimpse of the return values for <literal>returnRoute</literal>.
    The first part of the tuple gives the <glossterm>path pieces</glossterm>
    for the given route. The second part gives the query string parameters;
    for almost all use cases, this will be an empty list.</para>

    <para>It's hard to over-estimate the value of type-safe URLs. They give
    you a huge amount of flexibility and robustness when developing your
    application. You can move URLs around at will without ever breaking links.
    In the routing chapter, we'll see that routes can take parameters, such as
    a blog entry URL taking the blog post ID.</para>

    <para>Let's say you want to switch from routing on the numerical post ID
    to a year/month/slug setup. In a traditional web framework, you would need
    to go through every single reference to your blog post route and update
    appropriately. If you miss one, you'll have 404s at runtime. In Yesod, all
    you do is update your route and compile: GHC will pinpoint every single
    line of code that needs to be corrected.</para>
  </section>

  <section>
    <title>The scaffolded site</title>

    <para>Installing Yesod will give you both the Yesod library, as well as a
    <literal>yesod</literal> executable. This executable accepts a few
    commands, but the first one you'll want to be acquainted with is
    <literal>yesod init</literal>. It will ask you some questions, and then
    generate a folder containing the default <glossterm>scaffolded
    site</glossterm>. Inside that folder, you can run <literal>cabal install
    --only-dependencies</literal> to build any extra dependencies (such as
    your database backends), and then <literal>yesod devel</literal> to run
    your site.</para>

    <para>The scaffolded site gives you a lot of best practices out of the
    box, setting up files and dependencies in a time-tested approach used by
    most production Yesod sites. However, all this convenience can get in the
    way of actually learning Yesod. Therefore, most of this book will avoid
    the scaffolding tool, and instead deal directly with Yesod as a
    library.</para>

    <para>We will cover the structure of the scaffolded site in more detail
    later.</para>
  </section>

  <section>
    <title>Development server</title>

    <para></para>

    <para>One of the advantages interpreted languages have over compiled
    languages is fast prototyping: you save changes to a file and hit refresh.
    If we want to make any changes to our Yesod apps above, we'll need to call
    <command>runhaskell</command> from scratch, which can be a bit
    tedious.</para>

    <para>Fortunately, there's a solution to this: <literal>yesod
    devel</literal> automatically rebuilds and reloads your code for you. This
    can be a great way to develop your Yesod projects, and when you're ready
    to move to production, you still get to compile down to incredibly
    efficient code. The Yesod scaffolding automatically sets things up for
    you. This gives you the best of both worlds: rapid prototyping <emphasis
    role="bold">and</emphasis> fast production code.</para>

    <para>It's a little bit more involved to set up your code to be used by
    <command>yesod devel</command>, so our examples will just use
    <literal>warpDebug</literal>. But when you're ready to make your
    real-world applications, <command>yesod devel</command> will be waiting
    for you.</para>
  </section>

  <section>
    <title>Summary</title>

    <para></para>

    <para>Every Yesod application is built around a foundation datatype. We
    associate some resources with that datatype and define some handler
    functions, and Yesod handles all of the routing. These resources are also
    data constructors, which lets us have type-safe URLs.</para>

    <para>By being built on top of WAI, Yesod applications can run with a
    number of different backends. <literal>warpDebug</literal> is an easy way
    to get started, as it's included with Yesod. For rapid development, you
    can use <literal>yesod devel</literal> is a good choice. And when you're
    ready to move to production, you have Warp as a high-performance
    option.</para>

    <para>When developing in Yesod, we get a number of choices for coding
    style: quasi-quotation or external files, <literal>warpDebug</literal> or
    <literal>yesod devel</literal>, and so on. The examples in this book will
    tend towards using the choices that are easiest to copy-and-paste, but the
    more powerful options will be available when you start building real Yesod
    applications.</para>
  </section>
</chapter>

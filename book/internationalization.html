<!DOCTYPE HTML>
<html><head><title>Internationalization</title></head><body><header><h1>Internationalization</h1></header><article id="file174-internationalization">
        <p class="hascomments" id="file174-internationalization/x-3">Users expect our software to speak their language. Unfortunately for us, there
            will likely be more than one language involved. While doing simple string replacement
            isn&#39;t too involved, correctly dealing with all the grammar issues can be tricky. After
            all, who wants to see &quot;List 1 file(s)&quot; from a program output?</p>
        <p class="hascomments" id="file174-internationalization/x-4">But a real i18n solution needs to do more than just provide a means of achieving the
            correct output. It needs to make this process easy for both the programmer and the
            translator and relatively error-proof. Yesod&#39;s answer to the problem gives you:</p>
        <ul id="file174-internationalization/ul_bqf_mdz_ae">
            <li id="file174-internationalization/x-5">Intelligent guessing of the user&#39;s desired language based on request headers, with
                the ability to override.</li>
            <li id="file174-internationalization/x-6">A simple syntax for giving translations which requires no Haskell knowledge. (After
                all, most translators aren&#39;t programmers.)</li>
            <li id="file174-internationalization/x-7">The ability to bring in the full power of Haskell for tricky grammar issues as
                necessary, along with a default selection of helper functions to cover most
                needs.</li>
            <li id="file174-internationalization/x-8">Absolutely no issues at all with word order.</li>
        </ul>
    <section class="subtopic" id="file167-synopsis"><h1>Synopsis</h1>
  <pre class="codeblock" id="file167-synopsis/x-3">-- @messages/en.msg
Hello: Hello
EnterItemCount: I would like to buy: 
Purchase: Purchase
ItemCount count@Int: You have purchased #{showInt count} #{plural count &quot;item&quot; &quot;items&quot;}.
SwitchLanguage: Switch language to: 
Switch: Switch</pre>
  <pre class="codeblock" id="file167-synopsis/x-4">-- @messages/he.msg
Hello: שלום
EnterItemCount: אני רוצה לקנות: 
Purchase: קנה
ItemCount count: קנית #{showInt count} #{plural count &quot;דבר&quot; &quot;דברים&quot;}.
SwitchLanguage: החלף שפה ל:
Switch: החלף</pre>
  <pre class="codeblock" id="file167-synopsis/x-5">{-# LANGUAGE OverloadedStrings, QuasiQuotes, TemplateHaskell, TypeFamilies,
    MultiParamTypeClasses #-}
import Yesod

data I18N = I18N

mkMessage &quot;I18N&quot; &quot;messages&quot; &quot;en&quot;

plural :: Int -&gt; String -&gt; String -&gt; String
plural 1 x _ = x
plural _ _ y = y

showInt :: Int -&gt; String
showInt = show

instance Yesod I18N where
    approot _ = &quot;&quot;

instance RenderMessage I18N FormMessage where
    renderMessage _ _ = defaultFormMessage

mkYesod &quot;I18N&quot; [parseRoutes|
/ RootR GET
/buy BuyR GET
/lang LangR POST
|]

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;h1&gt;_{MsgHello}
&lt;form action=@{BuyR}&gt;
    _{MsgEnterItemCount}
    &lt;input type=text name=count&gt;
    &lt;input type=submit value=_{MsgPurchase}&gt;
&lt;form action=@{LangR} method=post&gt;
    _{MsgSwitchLanguage}
    &lt;select name=lang&gt;
        &lt;option value=en&gt;English
        &lt;option value=he&gt;Hebrew
    &lt;input type=submit value=_{MsgSwitch}&gt;
|]

getBuyR :: Handler RepHtml
getBuyR = do
    count &lt;- runInputGet $ ireq intField &quot;count&quot;
    defaultLayout [whamlet|
&lt;p&gt;_{MsgItemCount count}
|]

postLangR :: Handler ()
postLangR = do
    lang &lt;- runInputPost $ ireq textField &quot;lang&quot;
    setLanguage lang
    redirect RedirectTemporary RootR

main :: IO ()
main = warpDebug 3000 I18N</pre>
 </section><section class="subtopic" id="file168-overview"><h1>Overview</h1>
  <p class="hascomments" id="file168-overview/x-3">Most existing i18n solutions out there, like gettext or Java message bundles, work on the
   principle of string lookups. Usually some form of printf-interpolation is used to interpolate
   variables into the strings. In Yesod, as you might guess, we instead rely on types. This gives us
   all of our normal advantages, such as the compiler automatically catching mistakes.</p>
  <p class="hascomments" id="file168-overview/x-4">Let&#39;s take a concrete example. Suppose our application has two things it wants to say to a
   user: say hello, and state how many users are logged into the system. This can be modeled with a
   simple datatype:</p>
  <pre class="codeblock" id="file168-overview/x-5">data MyMessage = MsgHello | MsgUsersLoggedIn Int</pre>
  <p class="hascomments" id="file168-overview/x-6">I can also write a simple function to turn this datatype into an English representation:</p>
  <pre class="codeblock" id="file168-overview/x-7">toEnglish :: MyMessage -&gt; String
toEnglish MsgHello = &quot;Hello there!&quot;
toEnglish (MsgUsersLoggedIn 1) = &quot;There is 1 user logged in.&quot;
toEnglish (MsgUsersLoggedIn i) = &quot;There are &quot; ++ show i ++ &quot; users logged in.&quot;</pre>
  <p class="hascomments" id="file168-overview/x-8">We can also write similar functions for other languages. The advantage to this inside-Haskell
   approach is that we have the fully power of Haskell for addressing tricky grammar issues,
   especially pluralization.</p>
  <aside class="note" id="file168-overview/x-9">You may think pluralization isn&#39;t so complicated: you have one version for 1 item, and
   another for any other count. That might be true in English, but it&#39;s not true for every language.
   Russian, for example, has six different forms, and you need to use some modulus logic to
   determine which one to use.</aside>
  <p class="hascomments" id="file168-overview/x-10">The downside, however, is that you have to write all of this inside of Haskell, which won&#39;t be
   very translator friendly. To solve this, Yesod introduces the concept of message files. We&#39;ll
   cover that in a little bit.</p>
  <p class="hascomments" id="file168-overview/x-11">So let&#39;s say we have this full set of translation functions. How do we go about using them?
   What we need is a new function to wrap them all up together, and then choose the appropriate
   translation function based on the user&#39;s selected language. Once we have that, Yesod can
   automatically choose the most relevant render function and call it on the values you provide.</p>
  <p class="hascomments" id="file168-overview/x-12">In order to simplify things a bit, Hamlet has a special interpolation syntax,
    <code id="file168-overview/x-13">_{...}</code>, which handles all the calls to the render functions. And in order to
   associate a render function with your application, you use the <code id="file168-overview/x-14">YesodMessage</code>
   typeclass.</p>
 </section><section class="subtopic" id="file170-concept_jtl_d3d_d2"><h1>Message files</h1>
  <p class="hascomments" id="file170-concept_jtl_d3d_d2/x-3">The simplest approach to creating translations is via <dfn id="file170-concept_jtl_d3d_d2/x-4">message files</dfn>. The setup is
   very simple: there is a single folder containing all of your translation files, with a single
   file for each language. Each file is named based on its language code, e.g.
    <code class="filepath" id="file170-concept_jtl_d3d_d2/x-5">en.msg</code>. And each line in a file handles one phrase, which correlates to a
   single constructor in your message data type.</p>
  <p class="hascomments" id="file170-concept_jtl_d3d_d2/x-6">So firstly, a word about language codes. There are really two choices available: using a
   two-letter language code, or a language-LOCALE code. For example, when I load up a page in my web
   browser, it sends two languages codes: en-US and en. What my browser is saying is &quot;if you have
   American English, I like that the most. If you have English, I&#39;ll take that instead.&quot;</p>
  <p class="hascomments" id="file170-concept_jtl_d3d_d2/x-7">So which format should you use in your application? Most likely two-letter codes, unless you
   are actually creating separate translations by locale. This ensures that someone asking for
   Canadian English will still see your English.</p>
  <p class="hascomments" id="file170-concept_jtl_d3d_d2/x-8">Now what about these message files? The syntax should be very familiar after your work with
   Hamlet and Persistent. The line starts off with the name of the message. Since this is a data
   constructor, it must start with a capital letter. Next, you can have individual parameters, which
   must be given as lower case. (You can also omit the parameters entirely if you want a simple
   message.) These will be arguments to the data constructor.</p>
  <p class="hascomments" id="file170-concept_jtl_d3d_d2/x-9">The argument list is terminated by a colon, and then followed by the translated string, which
   allows usage of our typical variable interpolation syntax <code id="file170-concept_jtl_d3d_d2/x-10">#{myVar}</code>. By referring
   to the parameters defined before the colon, and using translation helper functions to deal with
   issues like pluralization, you can create all the translated messages you need.</p>
 <section class="subtopic" id="file169-concept_zkq_kjd_d2"><h1>Specifying types</h1>
  <p class="hascomments" id="file169-concept_zkq_kjd_d2/x-3">Since we will be creating a datatype out of our message specifications, each parameter to a
   data constructor must be given a data type. We use a simple @-syntax for this. For example, to
   create the datatype <code id="file169-concept_zkq_kjd_d2/x-4">data MyMessage = MsgHello | MsgSayAge Int</code>, we would
   write:</p>
  <pre class="codeblock" id="file169-concept_zkq_kjd_d2/x-5">Hello: Hi there!
SayAge age@Int: Your age is: #{show age}</pre>
  <p class="hascomments" id="file169-concept_zkq_kjd_d2/x-6">But there are two problems with this:</p>
  <ol id="file169-concept_zkq_kjd_d2/ol_cvd_tjd_d2">
   <li id="file169-concept_zkq_kjd_d2/x-7">It&#39;s not very DRY (don&#39;t repeat yourself) to have to specify this datatype in every
    file.</li>
   <li id="file169-concept_zkq_kjd_d2/x-8">Translators will be very confused having to specify these datatypes.</li>
  </ol>
  <p class="hascomments" id="file169-concept_zkq_kjd_d2/x-9">So instead, the type specification is only required in the main language file. This is
   specified as the third argument in the <code id="file169-concept_zkq_kjd_d2/x-10">mkMessage</code> function. This also specifies
   what will be the backup language, to be used when none of the languages provided by your
   application match the user&#39;s language list.</p>
 </section></section><section class="subtopic" id="file171-concept_srz_1mc_22"><h1>RenderMessage typeclass</h1>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-3">Your call to <code id="file171-concept_srz_1mc_22/x-4">mkMessage</code> creates an instance of the RenderMessage typeclass,
   which is the core of Yesod&#39;s i18n. It is defined as:</p>
  <pre class="codeblock" id="file171-concept_srz_1mc_22/x-5">class RenderMessage master message where
    renderMessage :: master
                  -&gt; [Text] -- ^ languages
                  -&gt; message
                  -&gt; Text </pre>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-6">Notice that there are two parameters to the RenderMessage class: the master site and the
   message type. In theory, we could skip the master type here, but that would mean that every site
   would need to have the same set of translations for each message type. When it comes to shared
   libraries like forms, that would not be a workable solution.</p>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-7">So as with mostmethods within a typeclass, the renderMessage function takes a parameter for
   each of the classes type parameters: master and message. The extra parameter is a list of
   languages the user will accept, in descending order of priority. The method then returns a
   user-ready Text that can be displayed.</p>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-8">A simple instance of RenderMessage may involve no actual translation of strings; instead, it
   will just display the same value for every language. For example:</p>
  <pre class="codeblock" id="file171-concept_srz_1mc_22/x-9">data MyMessage = Hello | Greet Text
instance RenderMessage MyApp MyMessage where
    renderMessage _ _ Hello = &quot;Hello&quot;
    renderMessage _ _ (Greet name) = &quot;Welcome, &quot; &lt;&gt; name &lt;&gt; &quot;!&quot;</pre>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-10">Notice how we ignore the first two parameters to renderMessage. We can now easily extend this
   to support multiple languages:</p>
  <pre class="codeblock" id="file171-concept_srz_1mc_22/x-11">renderEn Hello = &quot;Hello&quot;
renderEn (Greet name) = &quot;Welcome, &quot; &lt;&gt; name &lt;&gt; &quot;!&quot;
renderHe Hello = &quot;שלום&quot;
renderHe (Greet name) = &quot;ברוכים הבאים, &quot; &lt;&gt; name &lt;&gt; &quot;!&quot;
instance RenderMessage MyApp MyMessage where
    renderMessage _ (&quot;en&quot;:_) = renderEn
    renderMessage _ (&quot;he&quot;:_) = renderHe
    renderMessage master (_:langs) = renderMessage master langs
    renderMessage _ [] = renderEn</pre>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-12">The idea here is fairly straight-forward: we define helper functions to support each language.
   We then add a clause to catch each of those languages in the renderMessage definition. We then
   have two final cases: if no languages matched, continue checking with the next language in the
   user&#39;s priority list. If we&#39;ve exhausted all languages the user specified, then use the default
   language (in our case, English).</p>
  <p class="hascomments" id="file171-concept_srz_1mc_22/x-13">But odds are that you will never need to worry about writing this stuff manually, as the
   message file interface does all this for you. But it&#39;s always a good idea to have an
   understanding of what&#39;s going on under the surface.</p>
 </section><section class="subtopic" id="file172-interpolation"><h1>Interpolation</h1>
  <p class="hascomments" id="file172-interpolation/x-3">One way to use your new RenderMessage instance would be to directly call the
    <code id="file172-interpolation/x-4">renderMessage</code> function. This would work, but it&#39;s a bit tedious: you need to
   pass in the foundation value and the language list manually. Instead, Hamlet provides a
   specialized i18n interpolation, which looks like <code id="file172-interpolation/x-5">_{...}</code>.</p>
  <aside class="note" id="file172-interpolation/x-6">Why the underscore? Underscore is already a well-established character for i18n, as it is
   used in the gettext library.</aside>
  <p class="hascomments" id="file172-interpolation/x-7">Hamlet will then automatically translate that to a call to <code id="file172-interpolation/x-8">renderMessage</code>. Once
   Hamlet gets the output Text value, it uses the <code id="file172-interpolation/x-9">toHtml</code> function to produce an
    <code id="file172-interpolation/x-10">Html</code> value, meaning that any special characters (&lt;, &amp;, &gt;) will be
   automatically escaped.</p>
 </section><section class="subtopic" id="file173-phrases-not-words"><h1>Phrases, not words</h1>
  <p class="hascomments" id="file173-phrases-not-words/x-3">As a final note, I&#39;d just like to give some general i18n advice. Let&#39;s say you have an
   application for selling turtles. You&#39;re going to use the word &quot;turtle&quot; in multiple places, like
   &quot;You have added 4 turtles to your cart.&quot; and &quot;You have purchased 4 turtles, congratulations!&quot; As
   a programming, you&#39;ll immediately notice the code reuse potential: we have the phrase &quot;4 turtles&quot;
   twice. So you might structure your message file as:</p>
  <pre class="codeblock" id="file173-phrases-not-words/x-4">AddStart: You have added
AddEnd: to your cart.
PurchaseStart: You have purchased
PurchaseEnd: , congratulations!
Turtles count@Int: #{show count} #{plural &quot;turtle&quot; &quot;turtles&quot;}</pre>
  <p class="hascomments" id="file173-phrases-not-words/x-5">STOP RIGHT THERE! This is all well and good from a programming perspective, but translations
   are <i id="file173-phrases-not-words/x-6">not</i> programming. There are a million things that could go wrong with this, such
   as:</p>
  <ul id="file173-phrases-not-words/ul_425_m2m_f2">
   <li id="file173-phrases-not-words/x-7">Some languages might put &quot;to your cart&quot; before &quot;You have added.&quot;</li>
   <li id="file173-phrases-not-words/x-8">Maybe &quot;added&quot; will be constructed differently depending whether you added 1 or more
    turtles.</li>
   <li id="file173-phrases-not-words/x-9">There are a bunch of whitespace issues as well.</li>
  </ul>
  <p class="hascomments" id="file173-phrases-not-words/x-10">So the general rule is: translate entire phrases, not just words.</p>
 </section></article></body></html>
<!DOCTYPE HTML>
<html><head><title>Example: Ajax</title></head><body><header><h1>Example: Ajax</h1></header><article id="file178-example-ajax"><pre class="codeblock" id="file178-example-ajax/x1">&lt;p&gt;We&#39;re going to write a very simple AJAX application. It will be a simple site with a few pages and a navbar; when you have Javascript, clicking on the links will load the pages via AJAX. Otherwise, it will use static HTML.&lt;/p&gt;

&lt;p&gt;We&#39;re going to use jQuery for the Javascript, though anything would work just fine. Also, the AJAX responses will be served as JSON. Let&#39;s get started.&lt;/p&gt;

&gt; {-# LANGUAGE TypeFamilies, QuasiQuotes, TemplateHaskell, MultiParamTypeClasses, OverloadedStrings #-}
&gt; import Yesod
&gt; import Yesod.Static
&gt; import Data.Monoid (mempty)

Like the blog example, we&#39;ll define some data first.

&gt; data Page = Page
&gt;   { pageName :: String
&gt;   , pageSlug :: String
&gt;   , pageContent :: String
&gt;   }

&gt; loadPages :: IO [Page]
&gt; loadPages = return
&gt;   [ Page &quot;Page 1&quot; &quot;page-1&quot; &quot;My first page&quot;
&gt;   , Page &quot;Page 2&quot; &quot;page-2&quot; &quot;My second page&quot;
&gt;   , Page &quot;Page 3&quot; &quot;page-3&quot; &quot;My third page&quot;
&gt;   ]

&gt; data Ajax = Ajax
&gt;   { ajaxPages :: [Page]
&gt;   , ajaxStatic :: Static
&gt;   }

Next we&#39;ll generate a function for each file in our static folder. This way, we get a compiler warning when trying to using a file which does not exist.

&gt; staticFiles &quot;static/yesod/ajax&quot;

Now the routes; we&#39;ll have a homepage, a pattern for the pages, and use a static subsite for the Javascript and CSS files.

&gt; mkYesod &quot;Ajax&quot; [parseRoutes|
&gt; /                  HomeR   GET
&gt; /page/#String      PageR   GET
&gt; /static            StaticR Static ajaxStatic
&gt; |]

&lt;p&gt;That third line there is the syntax for a subsite: Static is the datatype for the subsite argument; siteStatic returns the site itself (parse, render and dispatch functions); and ajaxStatic gets the subsite argument from the master argument.&lt;/p&gt;

&lt;p&gt;Now, we&#39;ll define the Yesod instance. We&#39;ll still use a dummy approot value, but we&#39;re also going to define a default layout.&lt;/p&gt;

&gt; instance Yesod Ajax where
&gt;   approot _ = &quot;&quot;
&gt;   defaultLayout widget = do
&gt;   Ajax pages _ &lt;- getYesod
&gt;   content &lt;- widgetToPageContent widget
&gt;   hamletToRepHtml [hamlet|
&gt; \&lt;!DOCTYPE html&gt;
&gt; 
&gt; &lt;html&gt;
&gt;   &lt;head&gt;
&gt;     &lt;title&gt;#{pageTitle content}
&gt;     &lt;link rel=&quot;stylesheet&quot; href=&quot;@{StaticR style_css}&quot;&gt;
&gt;     &lt;script src=&quot;http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js&quot;&gt;
&gt;     &lt;script src=&quot;@{StaticR script_js}&quot;&gt;
&gt;     \^{pageHead content}
&gt;   &lt;body&gt;
&gt;     &lt;ul id=&quot;navbar&quot;&gt;
&gt;       $forall page &lt;- pages
&gt;         &lt;li&gt;
&gt;           &lt;a href=&quot;@{PageR (pageSlug page)}&quot;&gt;#{pageName page}
&gt;     &lt;div id=&quot;content&quot;&gt;
&gt;       \^{pageBody content}
&gt; |]

&lt;p&gt;The Hamlet template refers to style_css and style_js; these were generated by the call to staticFiles above.  There&#39;s nothing Yesod-specific about the &lt;a href=&quot;/static/yesod/ajax/style.css&quot;&gt;style.css&lt;/a&gt; and &lt;a href=&quot;/static/yesod/ajax/script.js&quot;&gt;script.js&lt;/a&gt; files, so I won&#39;t describe them here.&lt;/p&gt;

&lt;p&gt;Now we need our handler functions. We&#39;ll have the homepage simply redirect to the first page, so:&lt;/p&gt;

&gt; getHomeR :: Handler ()
&gt; getHomeR = do
&gt;   Ajax pages _ &lt;- getYesod
&gt;   let first = head pages
&gt;   redirect RedirectTemporary $ PageR $ pageSlug first

And now the cool part: a handler that returns either HTML or JSON data, depending on the request headers.

&gt; getPageR :: String -&gt; Handler RepHtmlJson
&gt; getPageR slug = do
&gt;   Ajax pages _ &lt;- getYesod
&gt;   case filter (\e -&gt; pageSlug e == slug) pages of
&gt;       [] -&gt; notFound
&gt;       page:_ -&gt; defaultLayoutJson (do
&gt;           setTitle $ toHtml $ pageName page
&gt;           addHamlet $ html page
&gt;           ) (json page)
&gt;  where
&gt;   html page = [hamlet|
&gt; &lt;h1&gt;#{pageName page}
&gt; &lt;article&gt;#{pageContent page}
&gt; |]
&gt;   json page = jsonMap
&gt;       [ (&quot;name&quot;, jsonScalar $ pageName page)
&gt;       , (&quot;content&quot;, jsonScalar $ pageContent page)
&gt;       ]

&lt;p&gt;We first try and find the appropriate Page, returning a 404 if it&#39;s not there. We then use the defaultLayoutJson function, which is really the heart of this example. It allows you an easy way to create responses that will be either HTML or JSON, and which use the default layout in the HTML responses. It takes four arguments: 1) the title of the HTML page, 2) some value, 3) a function from that value to a Hamlet value, and 4) a function from that value to a Json value.&lt;/p&gt;

&lt;p&gt;Under the scenes, the Json monad is really just using the Hamlet monad, so it gets all of the benefits thereof, namely interleaved IO and enumerator output. It is pretty straight-forward to generate JSON output by using the three functions jsonMap, jsonList and jsonMap. One thing to note: the input to jsonScalar must be HtmlContent; this helps avoid cross-site scripting attacks, by ensuring that any HTML entities will be escaped.&lt;/p&gt;

&lt;p&gt;And now our typical main function. We need two parameters to build our Ajax value: the pages, and the static loader. We&#39;ll load up from a local directory.&lt;/p&gt;

&gt; main :: IO ()
&gt; main = do
&gt;   pages &lt;- loadPages
&gt;   s &lt;- static &quot;static/yesod/ajax&quot;
&gt;   warpDebug 3000 $ Ajax pages s
</pre></article></body></html>
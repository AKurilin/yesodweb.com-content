<!DOCTYPE HTML>
<html><head><title>Sessions</title></head><body><header><h1>Sessions</h1></header><article id="file101-sessions"><p class="hascomments" id="file101-sessions/i1">HTTP is a stateless protocol. While some view this as a disadvantage, advocates of
            RESTful web development laud this as an advantage. When state is removed from the
            picture, it is easier to scale applications, caching can happen automatically, and many
            other nice side effects occur. You can draw many parallels with the non-mutable nature
            of Haskell in general.</p>
        <p class="hascomments" id="file101-sessions/x-3">As much as possible, RESTful applications should avoid storing state about an interaction
            with a client. However, it is sometimes unavoidable. Features like shopping carts are
            the classic example, but other more mundane interactions like proper login handling can
            be greatly enhanced by proper usage of sessions.</p><p class="hascomments" id="file101-sessions/i2">This chapter will describe how Yesod stores session data,
            how you can access this data, and some special functions to help
            you make the most of sessions.</p><section class="subtopic" id="file95-clientsession"><h1>Clientsession</h1><p class="hascomments" id="file95-clientsession/cs1">One of the earliest packages spun off from Yesod was
            <dfn class="apiname" id="file95-clientsession/x1">clientsession</dfn>. This package uses encryption and
            signatures to store data in a client-side cookie. The encryption
            prevents the user from tampering with the data, and the signature
            ensures that the session cannot be hijacked.</p><p class="hascomments" id="file95-clientsession/cs2">It might sound like a bad idea from an efficiency
            standpoint to store data in a cookie: after all, this means that
            the data must be sent on every request. However, in practice,
            clientsession can be a great boon for performance.</p><ul id="file95-clientsession/x2"><li id="file95-clientsession/x3">No server side database lookup is required to service a request.</li><li id="file95-clientsession/x4">We can easily scale horizontally: each request contains all the information we need to send a response.</li><li id="file95-clientsession/x5">To avoid undue bandwidth overhead, production sites can serve their static content from
                a separate domain name to avoid the overhead of transmitting the session cookie for
                each request.</li></ul><p class="hascomments" id="file95-clientsession/cs3">Obviously, storing megabytes of information in the session
            will be a bad idea. But for that matter, most session
            implementations recommend against such practices. If you really
            need massive storage for a user, it is best to simply store a
            lookup key in the session, and put the actual data in a
            database.</p>
        <p class="hascomments" id="file95-clientsession/x-3">All of the interaction with clientsession is handled by Yesod internally, but there are a
            few spots where you can tweak the behavior just a bit.</p></section><section class="subtopic" id="file96-controlling-sessions"><h1>Controlling sessions</h1><p class="hascomments" id="file96-controlling-sessions/c1">There are three functions in the Yesod typeclass that control how sessions work.
                <dfn class="apiname" id="file96-controlling-sessions/x-3">yesod-core:Yesod.Core:encryptKey</dfn> returns the encryption key used.
            By default, it will take this from a local file, so that sessions can persist between
            database shutdowns. This file will be automatically created and filled with random data
            if it does not exist. And if you override this function to return <code id="file96-controlling-sessions/x2">Nothing</code>, sessions will be disabled.</p><aside class="note" id="file96-controlling-sessions/x3"><p class="hascomments" id="file96-controlling-sessions/c2">Why disable sessions? They <b id="file96-controlling-sessions/x4">do</b> introduce a
                performance overhead. Under normal circumstances, this overhead
                is minimal, especially compared to database access. However,
                when dealing with very basic tasks, the overhead can become
                noticeable. But be careful about disabling sessions: this will
                also disable such features as 
                    CSRF (Cross-Site Request Forgery) protection.</p></aside><p class="hascomments" id="file96-controlling-sessions/c3">The next function is <dfn class="apiname" id="file96-controlling-sessions/x-4">yesod-core:Yesod.Core:clientSessionDuration</dfn>. This
            function simply gives the number of minutes that a session should be active. The default
            is 120 (2 hours).</p><p class="hascomments" id="file96-controlling-sessions/c4">This value ends up affecting the session cookie in two ways:
            firstly, it determines the expiration date for the cookie itself.
            More importantly, however, the session expiration timestamp is
            encoded inside the session signature. When Yesod decodes the
            signature, it checks if the date is in the past; if so, it ignores
            the session values.</p><aside class="note" id="file96-controlling-sessions/x6"><p class="hascomments" id="file96-controlling-sessions/c5">Every time Yesod sends a response to the client, it
                sends an updated session cookie with a new expire date. This
                way, even if you do not change the session values themselves, a
                session will not time out if the user continues to browse your
                site.</p></aside><p class="hascomments" id="file96-controlling-sessions/c6">And this leads very nicely to the last function:
                <dfn class="apiname" id="file96-controlling-sessions/x-5">yesod-core:Yesod.Core:sessionIpAddress</dfn>. By default, Yesod also
            encodes the client&#39;s IP address inside the cookie to prevent session hijacking. In
            general, this is a good thing. However, some ISPs are known for putting their users
            behind proxies that rewrite their IP addresses, sometimes changing the source IP in the
            middle of the session. If this happens, and you have sessionIpAddress enabled, the
            user&#39;s session will be reset. Turning this setting to false will allow a session to
            continue under such circumstances, at the cost of exposing a user to session
            hijacking.</p></section><section class="subtopic" id="file97-session-operations"><h1>Session Operations</h1><p class="hascomments" id="file97-session-operations/o1">Like most frameworks, sessions in Yesod are simple key-value
            stores. The base session API boils down to just three functions:
            <code id="file97-session-operations/x1">lookupSession</code> gets a value for a key (if available),
            <code id="file97-session-operations/x2">setSession</code> sets a value for a key, and
            <code id="file97-session-operations/x3">deleteSession</code> clears a value for a key.</p><pre class="codeblock" id="file97-session-operations/x4">{-# LANGUAGE TypeFamilies, QuasiQuotes, TemplateHaskell, MultiParamTypeClasses, OverloadedStrings #-}
import Yesod
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

data Session = Session

mkYesod &quot;Session&quot; [parseRoutes|
/ Root GET POST
|]

getRoot :: Handler RepHtml
getRoot = do
    sess &lt;- getSession
    hamletToRepHtml [hamlet|
&lt;form method=post&gt;
    &lt;input type=text name=key&gt;
    &lt;input type=text name=val&gt;
    &lt;input type=submit&gt;
&lt;h1&gt;#{show sess}
|]

postRoot :: Handler ()
postRoot = do
    (key, mval) &lt;- runInputPost $ (,) &lt;$&gt; ireq textField &quot;key&quot; &lt;*&gt; iopt textField &quot;val&quot;
    case mval of
        Nothing -&gt; deleteSession key
        Just val -&gt; setSession key val
    liftIO $ print (key, mval)
    redirect RedirectTemporary Root

instance Yesod Session where
    approot _ = &quot;&quot;
    clientSessionDuration _ = 1

instance RenderMessage Session FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 Session</pre></section><section class="subtopic" id="file98-messages"><h1>Messages</h1><p class="hascomments" id="file98-messages/m1">One usage of sessions previously alluded to is messages.
            They come to solve a common problem in web development: the user
            performs a POST request, the web app makes a change, and then the
            web app wants to <i id="file98-messages/x1">simultaneously</i> redirect the user to a new
            page and send the user a success message.</p><p class="hascomments" id="file98-messages/m2">Yesod provides a pair of functions to make this very easy:
            <code id="file98-messages/x2">setMessage</code> stores a value in the session, and
            <code id="file98-messages/x3">getMessage</code> both reads the value most recently put into
            the session, and clears the old value so it does not accidently get
            displayed twice.</p><p class="hascomments" id="file98-messages/m3">It is recommended to have a call to getMessage in
            <code id="file98-messages/x4">defaultLayout</code> so that any available message is shown
            to a user immediately, without having to remember to add getMessage
            calls to every handler.</p>
        <pre class="codeblock" id="file98-messages/x-3">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, MultiParamTypeClasses #-}
import Yesod

data Messages = Messages

mkYesod &quot;Messages&quot; [parseRoutes|
/ RootR GET
/set-message SetMessageR POST
|]

instance Yesod Messages where
    approot _ = &quot;&quot;
    defaultLayout widget = do
        pc &lt;- widgetToPageContent widget
        mmsg &lt;- getMessage
        hamletToRepHtml [hamlet|
!!!
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        ^{pageHead pc}
    &lt;body&gt;
        $maybe msg &lt;- mmsg
            &lt;p&gt;Your message was: #{msg}
        ^{pageBody pc}
|]

instance RenderMessage Messages FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;form method=post action=@{SetMessageR}&gt;
    My message is: #
    &lt;input type=text name=message&gt;
    &lt;input type=submit&gt;
|]

postSetMessageR :: Handler ()
postSetMessageR = do
    msg &lt;- runInputPost $ ireq textField &quot;message&quot;
    setMessage $ toHtml msg
    redirect RedirectTemporary RootR

main :: IO ()
main = warpDebug 3000 Messages</pre>
        <figure id="file98-messages/x-4"><figcaption>Initial page load, no message</figcaption>
            
            <img id="file98-messages/image_oka_gxb_yd" src="images/messages-1.png" />
        </figure>
        <figure id="file98-messages/x-6"><figcaption>New message entered in text box</figcaption>
            
            <img id="file98-messages/image_bqu_hxb_yd" src="images/messages-2.png" />
        </figure>
        <figure id="file98-messages/x-8"><figcaption>After form submit, message appears at top of page</figcaption>
            
            <img id="file98-messages/image_qhn_jxb_yd" src="images/messages-3.png" />
        </figure>
        <figure id="file98-messages/x-10"><figcaption>After refresh, the message is cleared</figcaption>
            
            <img id="file98-messages/image_sjp_kxb_yd" src="images/messages-4.png" />
        </figure></section><section class="subtopic" id="file99-ultimate-destination"><h1>Ultimate Destination</h1><p class="hascomments" id="file99-ultimate-destination/u1">Not to be confused with a horror film, this concept is used internally in <dfn class="apiname" id="file99-ultimate-destination/x1">yesod-auth</dfn>. Let&#39;s say a user requests a page that requires
            authentication. Clearly, you need to send them to the login page. A well-designed web
            app will then <i id="file99-ultimate-destination/x2">send them back to the first page they requested</i>. That&#39;s
            what we call the ultimate destination.</p><p class="hascomments" id="file99-ultimate-destination/u2"><code id="file99-ultimate-destination/x3">redirectUltDest</code> sends the user to the ultimate
            destination set in his/her session, clearing that value from the
            session. It takes a default destination as well, in case there is
            no destination set. For setting the session, there are three
            variants: <code id="file99-ultimate-destination/x4">setUltDest</code> sets the destination to the given
            type-safe URL, <code id="file99-ultimate-destination/x5">setUltDestString</code> does the same with a
            text URL, and <code id="file99-ultimate-destination/x6">setUltDest&#39;</code> sets the destination to the
            currently requested URL.</p></section><section class="subtopic" id="file100-summary"><h1>Summary</h1>
        <p class="hascomments" id="file100-summary/x-3">Sessions are the number one way we bypass the statelessness imposed by HTTP. We shouldn&#39;t
            consider this an escape hatch to perform whatever actions we want: statelessness in web
            applications is a virtue, and we should respect it whenever possible. However, there are
            some specific cases where it is vital to retain some state.</p><p class="hascomments" id="file100-summary/s1">The session API in Yesod is very simple. It provides a
            simple key-value store, and a few convenience functions built on
            top for common use cases. If used properly, with small payloads,
            sessions should be an unobtrusive part of your web development.</p></section></article></body></html>
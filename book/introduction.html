<!DOCTYPE HTML>
<html><head><title>Introduction</title></head><body><header><h1>Introduction</h1></header><article id="file7-introduction"><p class="hascomments" id="file7-introduction/i1">Since web programming began, people have been trying to make the development process a more pleasant one. As a community, we have continually pushed new techniques to try and solve some of the lingering difficulties of security threats, the stateless nature of HTTP, the multiple languages (HTML, CSS, Javascript) necessary to create a powerful web application, and more.</p><p class="hascomments" id="file7-introduction/i2">Yesod attempts to ease the web development process by playing to the strengths of the Haskell programming language. Haskell&#39;s strong compile-time guarantees of correctness not only encompass types; referential transparency ensures that we don&#39;t have any unintended side effects. Pattern matching on algebraic data types can help guarantee we&#39;ve accounted for every possible case. By building upon Haskell, entire classes of bugs disappear.</p><p class="hascomments" id="file7-introduction/i3">Unfortunately, using Haskell isn&#39;t enough. The web, by its very nature, is <i id="file7-introduction/x1">not</i> type safe. Even the simplest case of distinguishing between an integer and string is impossible: all data on the web is transferred as raw bytes, evading our best efforts at type safety. Every app writer is left with the task of validating all input. I call this problem <dfn id="file7-introduction/x2">the boundary issue</dfn>: as much as your application is type safe on the inside, every boundary with the outside world still needs to be sanitized.</p><section class="subtopic" id="file1-type-safety"><h1>Type Safety</h1><p class="hascomments" id="file1-type-safety/ts1">This is where Yesod comes in. By using high-level declarative techniques, you can specify the exact input types you are expecting. And the process works the other way as well: using a process of type-safe URLs, you can make sure that the data you send out is also guaranteed to be well formed.</p><p class="hascomments" id="file1-type-safety/ts2">The boundary issue is not just a problem when dealing with the client: the same problem exists when persisting and loading data. Once again, Yesod saves you on the boundary by performing the marshaling of data for you. You can specify your entities in a high-level definition and remain blissfully ignorant of the details.</p></section><section class="subtopic" id="file2-concise"><h1>Concise</h1><p class="hascomments" id="file2-concise/c1">We all know that there is a lot of boilerplate coding involved in web applications. Wherever possible, Yesod tries to use Haskell&#39;s features to save your fingers the work:</p><ul id="file2-concise/x1"><li id="file2-concise/x2">The forms library reduces the amount of code used for common cases by leveraging the Applicative type class.</li><li id="file2-concise/x3">Routes are declared in a very terse format, without sacrificing type safety.</li><li id="file2-concise/x4">Serializing your data to and from a database is handled automatically via code generation.</li></ul><p class="hascomments" id="file2-concise/c2">In Yesod, we have two kinds of code generation. To get your project started, we provide a scaffolding tool to set up your file and folder structure. However, most code generation is done at compile time via meta programming. This means your generated code will never get stale, as a simple library upgrade will bring all your generated code up-to-date.</p><p class="hascomments" id="file2-concise/c3">But for those who like to stay in control, and know exactly what their code is doing, you can always run closer to the compiler and write all your code yourself.</p></section><section class="subtopic" id="file3-performance"><h1>Performance</h1><p class="hascomments" id="file3-performance/p1">Haskell&#39;s main compiler, the GHC, has amazing performance characteristics, and is improving all the time. This choice of language by itself gives Yesod a large performance advantage over other offerings. But that&#39;s not enough: we need an architecture designed for performance.</p><p class="hascomments" id="file3-performance/p2">Our approach to templates is one example: by allowing HTML, CSS and JavaScript to be analyzed at compile time, Yesod both avoids costly disk I/O at runtime and can optimize the rendering of this code. But the architectural decisions go deeper: we use advanced techniques such as enumerators and builders in the underlying libraries to make sure our code runs in constant memory, without exhausting precious file handles and other resources. By offering high-level abstractions, you can get highly compressed and properly cached CSS and JavaScript.</p><p class="hascomments" id="file3-performance/p3">Yesod&#39;s flagship web server, Warp, is the fastest Haskell web server around. When these two pieces of technology are combined, it produces one of the fastest web application deployment solutions available.</p></section><section class="subtopic" id="file4-modular"><h1>Modular</h1><p class="hascomments" id="file4-modular/m1">Yesod has spawned the creation of dozens of packages, most of which are usable in a context outside of Yesod itself. One of the goals of the project is to contribute back to the community as much as possible; as such, even if you are not planning on using Yesod in your next project, a large portion of this book may still be relevant for your needs.</p><p class="hascomments" id="file4-modular/m2">Of course, these libraries have all been designed to integrate well together. Using the Yesod Framework should give you a strong feeling of consistency throughout the various APIs.</p></section><section class="subtopic" id="file5-a-solid-foundation"><h1>A solid foundation</h1><p class="hascomments" id="file5-a-solid-foundation/s1">I remember once seeing a PHP framework advertising support for UTF-8. This struck me as
            surprising: you mean having UTF-8 support isn&#39;t automatic? In the Haskell world, issues
            like character encoding are already well addressed and fully supported. In fact, we
            usually have the opposite problem: there are a number of packages providing powerful and
            well-designed support for the problem. The Haskell community is constantly pushing the
            boundaries finding the cleanest, most efficient solutions for each challenge.</p><p class="hascomments" id="file5-a-solid-foundation/s2">The downside of such a powerful ecosystem is the complexity of choice. By using Yesod, you will already have most of the tools chosen for you, and you can be guaranteed they work together. Of course, you always have the option of pulling in your own solution.</p><p class="hascomments" id="file5-a-solid-foundation/s3">As a real-life example, Yesod and Hamlet (the default templating language) use <dfn class="apiname" id="file5-a-solid-foundation/x1">blaze-builder</dfn> for textual content generation. This choice was made because blaze provides the fastest interface for generating UTF-8 data. Anyone who wants to use one of the other great libraries out there, such as <dfn class="apiname" id="file5-a-solid-foundation/x2">text</dfn>, should have no problem dropping it in.</p></section><section class="subtopic" id="file6-introduction-to-haskell"><h1>Introduction to Haskell</h1><p class="hascomments" id="file6-introduction-to-haskell/intro1">Haskell is a powerful, fast, type-safe, functional programming language. This book takes as an assumption that you are already familiar with most of the basics of Haskell. There are two wonderful books for learning Haskell, both of which are available for reading online:</p><ul id="file6-introduction-to-haskell/x1"><li id="file6-introduction-to-haskell/x2"><a href="http://learnyouahaskell.com">Learn You a Haskell for Great Good!</a></li><li id="file6-introduction-to-haskell/x4"><a href="http://book.realworldhaskell.org/read">Real World Haskell</a></li></ul><p class="hascomments" id="file6-introduction-to-haskell/intro2">Yesod relies on a few features in Haskell that most introductory tutorials do not cover. Though you will rarely need to understand how these work, it&#39;s always best to start off with a good appreciation for what your tools are doing. There will be an appendix added later covering some of these topics.</p></section></article></body></html>
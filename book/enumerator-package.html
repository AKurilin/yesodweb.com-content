<!DOCTYPE HTML>
<html><head><title>Enumerator Package</title></head><body><header><h1>Enumerator Package</h1></header><article id="file211-enumerator-package"><p class="hascomments" id="file211-enumerator-package/intro1">One of the upcoming patterns in Haskell is <dfn id="file211-enumerator-package/x1">enumerators</dfn>. They are designed to solve the problems of producing, modifying and consuming streams of data. Enumerators are considered a bit intimidating, possibly because:</p><ul id="file211-enumerator-package/x2"><li id="file211-enumerator-package/x3">There are multiple implementations, all with slightly different approaches.</li><li id="file211-enumerator-package/x4">Some of the implementations (in my opinion) use incredibly confusing naming.</li><li id="file211-enumerator-package/x5">The tutorials that get written usually don&#39;t directly target an existing implementation, and work more on building up intuition than giving instructions on how to use the library.</li></ul><p class="hascomments" id="file211-enumerator-package/intro2">The Yesod framework uses enumerators behind the scenes in a number of places: in WAI/Warp for dealing with request and response bodies, in Persistent for receiving the results from a database query, and in various side packages like <dfn class="apiname" id="file211-enumerator-package/x6">http-enumerator</dfn> and <dfn class="apiname" id="file211-enumerator-package/x7">xml-enumerator</dfn>. We always use the <dfn class="apiname" id="file211-enumerator-package/x8">enumerator</dfn> package. That package is the topic of this chapter.</p><p class="hascomments" id="file211-enumerator-package/intro3">This chapter is composed of three main sections, each dealing with one of the main concepts:</p><ul id="file211-enumerator-package/x9"><li id="file211-enumerator-package/x10">We start with <dfn id="file211-enumerator-package/x11">iteratees</dfn>, which are <b id="file211-enumerator-package/x12">consumers</b>. They are fed data and do something with it.</li><li id="file211-enumerator-package/x13">Next we cover <dfn id="file211-enumerator-package/x14">enumerators</dfn> which are <b id="file211-enumerator-package/x15">producers</b>. They feed data to an iteratee.</li><li id="file211-enumerator-package/x16">Finally, we address <dfn id="file211-enumerator-package/x17">enumeratees</dfn>. These are <b id="file211-enumerator-package/x18">pipes</b> which are fed data from an enumerator and in turn feed data to an iteratee.</li></ul><aside class="note" id="file211-enumerator-package/x19"><p class="hascomments" id="file211-enumerator-package/intro4">You may be wondering why we bother with this, when most of these problems can be addressed by lazy I/O. The basic problem with lazy I/O is its non-determinism. For more information, it&#39;s best to go to the original source on this topic: <a href="http://okmij.org/ftp/Streams.html#iteratee">Oleg</a>.</p></aside><section class="subtopic" id="file199-iteratees"><h1>Iteratees</h1>
        <p class="hascomments">An Iteratee is a data consumer. It is the core type of the enumerator package, on which
            the other types are based.</p>
    <section class="subtopic" id="file191-intuition"><h1>Intuition</h1><p class="hascomments" id="file191-intuition/intuition1">Let&#39;s say we want to write a function that sums the numbers in a list. Forgetting uninteresting details like space leaks, a perfectly good implementation could be:</p><pre class="codeblock" id="file191-intuition/x1">sum1 :: [Int] -&gt; Int
sum1 [] = 0
sum1 (x:xs) = x + sum1 xs</pre><p class="hascomments" id="file191-intuition/intuition2">But let&#39;s say that we don&#39;t have a list of numbers. Instead, the user is typing numbers on the command line, and hitting &quot;q&quot; when done. In other words, we have a function like:</p><pre class="codeblock" id="file191-intuition/x2">getNumber :: IO (Maybe Int)
getNumber = do
    x &lt;- readLine
    if x == &quot;q&quot;
        then return Nothing
        else return $ Just $ read x</pre><p class="hascomments" id="file191-intuition/intuition3">We could write our new sum function as:</p><pre class="codeblock" id="file191-intuition/x3">sum2 :: IO Int
sum2 = do
    maybeNum &lt;- getNumber
    case maybeNum of
        Nothing -&gt; return 0
        Just num -&gt; do
            rest &lt;- sum2
            return $ num + rest</pre><p class="hascomments" id="file191-intuition/intuition4">It&#39;s fairly annoying to have to write two completely separate sum functions just because our data source changed. Ideally, we would like to generalize things a bit. Let&#39;s start by noticing a similarity between these two functions: they both only <b id="file191-intuition/x4">yield</b> a value when they are informed that there are no more numbers. In the case of sum1, we check for an empty list; in sum2, we check for Nothing.</p></section><section class="subtopic" id="file192-stream-datatype"><h1>Stream Datatype</h1><p class="hascomments" id="file192-stream-datatype/stream1">The first datatype defined in the enumerator package is:</p><pre class="codeblock" id="file192-stream-datatype/x1">data Stream a = Chunks [a] | EOF</pre><p class="hascomments" id="file192-stream-datatype/stream2">The EOF constructor indicates that no more data is available. The Chunks constructor simply allows us to put multiple pieces of data together for efficiency. We could now rewrite sum2 to use this Stream datatype:</p><pre class="codeblock" id="file192-stream-datatype/x2">getNumber2 :: IO (Stream Int)
getNumber2 = do
    maybeNum &lt;- getNumber -- using the original getNumber function
    case maybeNum of
        Nothing -&gt; return EOF
        Just num -&gt; return $ Chunks [num]

sum3 :: IO Int
sum3 = do
    stream &lt;- getNumber2
    case stream of
        EOF -&gt; return 0
        Chunks nums -&gt; do
            let nums&#39; = sum nums
            rest &lt;- sum3
            return $ nums&#39; + rest</pre><p class="hascomments" id="file192-stream-datatype/stream3">Not that it&#39;s much better than sum2, but at least it shows how to use the Stream datatype. The problem here is that we still refer explicitly to the getNumber2 function, hard-coding the data source.</p><p class="hascomments" id="file192-stream-datatype/stream4">One possible solution is to make the data source an argument to the sum function, ie:</p><pre class="codeblock" id="file192-stream-datatype/x3">sum4 :: IO (Stream Int) -&gt; IO Int
sum4 getNum = do
    stream &lt;- getNum
    case stream of
        EOF -&gt; return 0
        Chunks nums -&gt; do
            let nums&#39; = sum nums
            rest &lt;- sum4 getNum
            return $ nums&#39; + rest</pre><p class="hascomments" id="file192-stream-datatype/stream5">That&#39;s all well and good, but let&#39;s pretend we want to have <i id="file192-stream-datatype/x4">two</i> datasources to sum over: values the user enters on the command line, and some numbers we read over an HTTP connection, perhaps. The problem here is one of <b id="file192-stream-datatype/x5">control</b>: sum4 is running the show here by calling getNum. This is a <b id="file192-stream-datatype/x6">pull</b> data model. Enumerators have an <b id="file192-stream-datatype/x7">inversion of control/push</b> model, putting the enumerator in charge. This allows cool things like feeding in multiple data sources, and also makes it easier to write enumerators that properly deal with resource allocation.</p></section><section class="subtopic" id="file193-the-step-datatype"><h1>The Step datatype</h1><p class="hascomments" id="file193-the-step-datatype/step1">So we need a new datatype that will represent the state of our summing operation. We&#39;re going to allow our operations to be in one of three states:</p><ul id="file193-the-step-datatype/x1"><li id="file193-the-step-datatype/x2">Waiting for more data.</li><li id="file193-the-step-datatype/x3">Already calculated a result.</li><li id="file193-the-step-datatype/x4">For convenience, we also have an error state. This isn&#39;t strictly necessary (it could be modeled by choosing an EitherT kind of monad, for example), but it&#39;s simpler.</li></ul><p class="hascomments" id="file193-the-step-datatype/step2">As you could guess, these states will correspond to three constructors for the Step datatype. The error state is modeled by <code id="file193-the-step-datatype/x5">Error SomeException</code>, building on top of Haskell&#39;s extensible exception system. The already calculated constructor is:</p><pre class="codeblock" id="file193-the-step-datatype/x6">Yield b (Stream a)</pre><p class="hascomments" id="file193-the-step-datatype/step3">Here, a is the <i id="file193-the-step-datatype/x7">input</i> to our iteratee and b is the <i id="file193-the-step-datatype/x8">output</i>. This constructor allows us to simultaneously produce a result and save any &quot;leftover&quot; input for another iteratee that may run after us. (This won&#39;t be the case with the sum function, which always consumes all its input, but we&#39;ll see some other examples that do not consume all output.)</p><p class="hascomments" id="file193-the-step-datatype/step4">Now the question is how to represent the state of an iteratee that&#39;s waiting for more data. You might at first want to declare some datatype to represent the internal state and pass that around somehow. That&#39;s not how it works: instead, we simply use a function (very Haskell of us, right?):</p><pre class="codeblock" id="file193-the-step-datatype/x9">Continue (Stream a -&gt; Iteratee a m b)</pre><p class="hascomments" id="file193-the-step-datatype/step5">Eureka! We&#39;ve finally seen the Iteratee datatype! Actually, Iteratee is a very boring datatype that is only present to allow us to declare cool instances (eg, Monad) for our functions. Iteratee is defined as:</p><pre class="codeblock" id="file193-the-step-datatype/x10">newtype Iteratee a m b = Iteratee (m (Step a m b))</pre><p class="hascomments" id="file193-the-step-datatype/step5a">And the complete Step datatype is:</p><pre class="codeblock" id="file193-the-step-datatype/x11">data Step a m b = Error SomeException 
                | Yield b (Stream a) 
                | Continue (Stream a -&gt; Iteratee a m b)</pre><p class="hascomments" id="file193-the-step-datatype/step6">This is important: <b id="file193-the-step-datatype/x12">Iteratee is just a newtype wrapper around a Step inside a monad</b>. Just keep that in mind as you look at definitions in the enumerator package. So knowing this, we can think of the Continue constructor as:</p><pre class="codeblock" id="file193-the-step-datatype/x13">Continue (Stream a -&gt; m (Step a m b))</pre><p class="hascomments" id="file193-the-step-datatype/step7">That&#39;s much easier to approach: that function takes some input data and returns a new state of the iteratee. Let&#39;s see what our sum function would look like using this Step datatype:</p><pre class="codeblock" id="file193-the-step-datatype/x14">sum5 :: Monad m =&gt; Step Int m Int -- Int input, any monad, Int output
sum5 =
    Continue $ go 0 -- a common pattern, you always start with a Continue
  where
    go :: Monad m =&gt; Int -&gt; Stream Int -&gt; Iteratee Int m Int
    -- Add the new input to the running sum and create a new Continue
    go runningSum (Chunks nums) = do
        let runningSum&#39; = runningSum + sum nums
        -- This next line is *ugly*, good thing there are some helper
        -- functions to clean it up. More on that below.
        Iteratee $ return $ Continue $ go runningSum&#39;
    -- Produce the final result
    go runningSum EOF = Iteratee $ return $ Yield runningSum EOF</pre>
<aside class="note" id="file193-the-step-datatype/x15">In order to run this code, you can use <code id="file193-the-step-datatype/x16">run_ $ enumList 8 [1..10] sum5</code>. But this gets into some of the Enumerator black magic we won&#39;t discuss till later.</aside>
<p class="hascomments" id="file193-the-step-datatype/step8">The first real line (<code id="file193-the-step-datatype/x17">Continue $ go 0</code>) initializes our iteratee to its starting state. Just like every other sum function, we need to explicitly state that we are starting from 0 somewhere. The real workhorse is the go function. Notice how we are really passing the state of the iteratee around as the first argument to go: this is also a very common pattern in iteratees.</p><p class="hascomments" id="file193-the-step-datatype/step9">We need to handle two different cases: when handed an EOF, the go function <b id="file193-the-step-datatype/x18">must</b> Yield a value. (Well, it could also produce an Error value, but it definitely <b id="file193-the-step-datatype/x19">cannot</b> Continue.) In that case, we simply yield the running sum and say there was no data left over. When we receive some input data via Chunks, we simply add it to the running sum and create a new Continue based on the same go function.</p><p class="hascomments" id="file193-the-step-datatype/step10">Now let&#39;s work on making that function a little bit prettier by using some built-in helper functions. The pattern <code id="file193-the-step-datatype/x20">Iteratee . return</code> is common enough to warrant a helper function, namely:</p><pre class="codeblock" id="file193-the-step-datatype/x21">returnI :: Monad m =&gt; Step a m b -&gt; Iteratee a m b
returnI = Iteratee . return</pre><p class="hascomments" id="file193-the-step-datatype/step11">So for example,</p><pre class="codeblock" id="file193-the-step-datatype/x22">go runningSum EOF = Iteratee $ return $ Yield runningSum EOF</pre><p class="hascomments" id="file193-the-step-datatype/step12">becomes</p><pre class="codeblock" id="file193-the-step-datatype/x23">go runningSum EOF = returnI $ Yield runningSum EOF</pre><p class="hascomments" id="file193-the-step-datatype/step13">But even <i id="file193-the-step-datatype/x24">that</i> is common enough to warrant a helper function:</p><pre class="codeblock" id="file193-the-step-datatype/x25">yield :: Monad m =&gt; b -&gt; Stream a -&gt; Iteratee a m b
yield x chunk = returnI $ Yield x chunk</pre><p class="hascomments" id="file193-the-step-datatype/step14">so our line becomes</p><pre class="codeblock" id="file193-the-step-datatype/x26">go runningSum EOF = yield runningSum EOF</pre><p class="hascomments" id="file193-the-step-datatype/step15">Similarly,</p><pre class="codeblock" id="file193-the-step-datatype/x27">Iteratee $ return $ Continue $ go runningSum&#39;</pre><p class="hascomments" id="file193-the-step-datatype/step16">becomes</p><pre class="codeblock" id="file193-the-step-datatype/x28">continue $ go runningSum&#39;</pre></section><section class="subtopic" id="file194-monad-instance-for-iteratee"><h1>Monad instance for Iteratee</h1><p class="hascomments" id="file194-monad-instance-for-iteratee/mi1">This is all very nice: we now have an iteratee that can be fed numbers from any monad and sum them. It can even take input from different sources and sum them together. (By the way, I haven&#39;t actually shown you how to feed those numbers in: that is in part 2 about enumerators.) But let&#39;s be honest: sum5 is an ugly function. Isn&#39;t there something easier?</p><p class="hascomments" id="file194-monad-instance-for-iteratee/mi2">In fact, there is. Remember how I said Iteratee really just existed to facilitate typeclass instances? This includes a monad instance. Feel free to look at the code to see how that instance is defined, but here we&#39;ll just look at how to use it:</p><pre class="codeblock" id="file194-monad-instance-for-iteratee/x1">sum6 :: Monad m =&gt; Iteratee Int m Int
sum6 = do
    maybeNum &lt;- head -- not head from Prelude!
    case maybeNum of
        Nothing -&gt; return 0
        Just i -&gt; do
            rest &lt;- sum6
            return $ i + rest</pre><p class="hascomments" id="file194-monad-instance-for-iteratee/mi3">That head function is not from Prelude, it&#39;s from the Data.Enumerator module. Its type signature is:</p><pre class="codeblock" id="file194-monad-instance-for-iteratee/x2">head :: Monad m =&gt; Iteratee a m (Maybe a)</pre><p class="hascomments" id="file194-monad-instance-for-iteratee/mi4">which basically means give me the next piece of input if it&#39;s there. We&#39;ll look at this function in more depth in a bit.</p><p class="hascomments" id="file194-monad-instance-for-iteratee/mi5">Go compare the code for sum6 with sum2: they are amazingly similar. You can often build up more complicated iteratees by using some simple iteratees and the Monad instance of Iteratee.</p></section><section class="subtopic" id="file195-interleaved-io"><h1>Interleaved I/O</h1><p class="hascomments" id="file195-interleaved-io/io1">Alright, let&#39;s look at a totally different problem. We want to be fed some strings and print them to the screen one line at a time. One approach would be to use lazy I/O:</p><pre class="codeblock" id="file195-interleaved-io/x1">lazyIO :: IO ()
lazyIO = do
    s &lt;- lines `fmap` getContents
    mapM_ putStrLn s</pre><p class="hascomments" id="file195-interleaved-io/io2">But this has two drawbacks: </p><ul id="file195-interleaved-io/x2"><li id="file195-interleaved-io/x3">It&#39;s tied down to a single input source, stdin. This could be worked around with an argument giving a datasource.</li><li id="file195-interleaved-io/x4">But let&#39;s say the data source is some scarce resource (think: file handles on a very busy web server). We have no guarantees with lazy I/O of when those file handles will be released.</li></ul><p class="hascomments" id="file195-interleaved-io/io3">Let&#39;s look at how to write this in our new high-level monadic iteratee approach:</p><pre class="codeblock" id="file195-interleaved-io/x5">interleaved :: MonadIO m =&gt; Iteratee String m ()
interleaved = do
    maybeLine &lt;- head
    case maybeLine of
        Nothing -&gt; return ()
        Just line -&gt; do
            liftIO $ putStrLn line
            interleaved</pre><p class="hascomments" id="file195-interleaved-io/io4">The liftIO function comes from the transformers package, and simply promotes an action in the IO monad to any arbitrary MonadIO action. Notice how we don&#39;t really track any state with this iteratee: we don&#39;t care about its result, only its side effects.</p></section><section class="subtopic" id="file196-implementing-head"><h1>Implementing head</h1><p class="hascomments" id="file196-implementing-head/ihead1">As a last example, let&#39;s actually implement the head function.</p><pre class="codeblock" id="file196-implementing-head/x1">head&#39; :: Monad m =&gt; Iteratee a m (Maybe a)
head&#39; =
    continue go
  where
    go (Chunks []) = continue go
    go (Chunks (x:xs)) = yield (Just x) (Chunks xs)
    go EOF = yield Nothing EOF</pre><p class="hascomments" id="file196-implementing-head/ihead2">Like our sum6 function, this also wraps an inner &quot;go&quot; function with a continue. However, we now have <i id="file196-implementing-head/x2">three</i> clauses for our go function. The first handles the case of <code id="file196-implementing-head/x3">Chunks []</code>. To quote the enumerator docs:</p><p class="hascomments" id="file196-implementing-head/ihead3">(Chunks []) is used to indicate that a stream is still active, but currently has no available data. Iteratees should ignore empty chunks.</p><p class="hascomments" id="file196-implementing-head/ihead4">The second clause handles the case where we are given some data. In this case, we yield the first element in the list, and return the rest as leftover data. The third clause handles the end of input by returning Nothing.</p></section><section class="subtopic" id="file197-exercises"><h1>Exercises</h1><ol id="file197-exercises/x1"><li id="file197-exercises/x2">Write an enumeratee which takes hex chars (eg, &quot;DEADBEEF&quot;) to Word8s. Its type signature should be <code id="file197-exercises/x3">Enumeratee Char Word8 m b</code>.</li><li id="file197-exercises/x4">Write the opposite enumeratee, eg <code id="file197-exercises/x5">Enumeratee Word8 Char m b</code>.</li><li id="file197-exercises/x6">Create a quickcheck property that ensures that these two functions work correctly.</li></ol></section><section class="subtopic" id="file198-summary"><h1>Summary</h1><ul id="file198-summary/x1"><li id="file198-summary/x2">Enumeratees are the pipes connecting enumerators to iteratees.</li><li id="file198-summary/x3">The strange type signature of an Enumeratee hides a lot of possible power. Especially notice how similar their type signatures are to Enumerators.</li><li id="file198-summary/x4">You can merge an Enumeratee into an Iteratee with <code id="file198-summary/x5">joinI $ enumeratee $$ iteratee</code>.</li><li id="file198-summary/x6">Don&#39;t forget that you can use the Monad instance of Iteratee when creating your own enumeratees.</li><li id="file198-summary/x7">You can always compose multiple enumeratees together, such as in http-enumerator.</li></ul></section></section><section class="subtopic" id="file205-enumerators"><h1>Enumerators</h1>
        <p class="hascomments">Whereas an Iteratee is a consumer, an Enumerator is a producer. At a high level, an
            Enumerator is in fact an <i>Iteratee transformer</i>, moving an Iteratee from one state
            to a new one. Let&#39;s look at how this works.</p>
    <section class="subtopic" id="file200-extracting-a-value"><h1>Extracting a value</h1><p class="hascomments" id="file200-extracting-a-value/extract1">So far, we&#39;ve written a few iteratees, but we still don&#39;t know how to extract values from them. To start, let&#39;s remember that <code id="file200-extracting-a-value/x1">Iteratee</code> is just a newtype wrapper around <code id="file200-extracting-a-value/x2">Step</code>:</p><pre class="codeblock" id="file200-extracting-a-value/x3">newtype Iteratee a m b = Iteratee { runIteratee :: m (Step a m b) }</pre><p class="hascomments" id="file200-extracting-a-value/extract2">First we need to unwrap the Iteratee and deal with the Step value inside. Remember also that Step has three constructors: Continue, Yield and Error. We&#39;ll handle the Error constructor by returning our result in an Either. Yield already provides the data we&#39;re looking for.</p><p class="hascomments" id="file200-extracting-a-value/extract3">The tricky case is Continue: here, we have an iteratee that is still expecting more data. This is where the EOF constructor comes in handy: it&#39;s our little way to tell the iteratee to finish what it&#39;s doing and get on with things. If you remember from above, I said a well-behaving iteratee will never return a Continue after receiving an EOF; now we&#39;ll see why:</p><pre class="codeblock" id="file200-extracting-a-value/x4">extract :: Monad m =&gt; Iteratee a m b -&gt; m (Either SomeException b)
extract (Iteratee mstep) = do
    step &lt;- mstep
    case step of
        Continue k -&gt; do
            let Iteratee mstep&#39; = k EOF
            step&#39; &lt;- mstep&#39;
            case step&#39; of
                Continue _ -&gt; error &quot;Misbehaving iteratee&quot;
                Yield b _ -&gt; return $ Right b
                Error e -&gt; return $ Left e
        Yield b _ -&gt; return $ Right b
        Error e -&gt; return $ Left e</pre><p class="hascomments" id="file200-extracting-a-value/extract4">Fortunately, you don&#39;t need to redefine this yourself: enumerator includes both a
                <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:run">run</a> and <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:run_">run_</a> function. Let&#39;s go ahead and use it on
            our sum6 function:</p><pre class="codeblock" id="file200-extracting-a-value/x7">run_ = return
sum6 = 5 :: Int
-- START
main = run_ sum6 &gt;&gt;= print</pre><p class="hascomments" id="file200-extracting-a-value/extract5">If you run this, the result will be 0. This emphasizes an important point: an iteratee is not just <i id="file200-extracting-a-value/x8">how</i> to process incoming data, <b id="file200-extracting-a-value/x9">it is the state of the processing</b>. In this case, we haven&#39;t done anything to change the initial state of sum6, so we still have the initial value of 0.</p><p class="hascomments" id="file200-extracting-a-value/extract6">To give an analogy: think of an iteratee as a machine. When you feed it data, you modify the internal state but you can&#39;t see any of those changes on the outside. When you are done feeding the data, you press a button and it spits out the result. If you don&#39;t feed in any data, your result is the initial state.</p></section><section class="subtopic" id="file201-adding-data"><h1>Adding data</h1><p class="hascomments" id="file201-adding-data/addingdata1">Let&#39;s say that we actually want to sum some numbers. For example, the numbers 1 to 10. We need some way to feed that into our sum6 iteratee. In order to approach this, we&#39;ll once again need to unwrap our Iteratee and deal with the Step value directly.</p><p class="hascomments" id="file201-adding-data/addingdata2">In our case, we know with certainty that the Step constructor we used is Continue, so it&#39;s safe to write our function as:</p><pre class="codeblock" id="file201-adding-data/x1">sum7 :: Monad m =&gt; Iteratee Int m Int
sum7 = Iteratee $ do
    Continue k &lt;- runIteratee sum6
    runIteratee $ k $ Chunks [1..10]</pre><p class="hascomments" id="file201-adding-data/addingdata3">But in general, we won&#39;t know what constructor will be lying in wait for us. We need to properly deal with Continue, Yield and Error. We&#39;ve seen what to do with Continue: feed it the data. With Yield and Error, the right action in general is to <b id="file201-adding-data/x2">do nothing</b>, since we&#39;ve already arrived at our final result (either a successful Yield or an Error). So the &quot;proper&quot; way to write the above function is:</p><pre class="codeblock" id="file201-adding-data/x3">sum8 :: Monad m =&gt; Iteratee Int m Int
sum8 = Iteratee $ do
    step &lt;- runIteratee sum6
    case step of
        Continue k -&gt; runIteratee $ k $ Chunks [1..10]
        _ -&gt; return step</pre></section><section class="subtopic" id="file202-enumerator-type-synonym"><h1>Enumerator type synonym</h1><p class="hascomments" id="file202-enumerator-type-synonym/ets1">What we&#39;ve done with sum7 and sum8 is perform a transformation on the Iteratee. But we&#39;ve done this in a very limited way: we&#39;ve hard-coded in the original Iteratee function (sum6). We could just make this an argument to the function:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x1">sum9 :: Monad m =&gt; Iteratee Int m Int -&gt; Iteratee Int m Int
sum9 orig = Iteratee $ do
    step &lt;- runIteratee orig
    case step of
        Continue k -&gt; runIteratee $ k $ Chunks [1..10]
        _ -&gt; return step</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets2">But since we always just want to unwrap the Iteratee value anyway, it turns out that it&#39;s more natural to make the argument of type Step, ie:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x2">sum10 :: Monad m =&gt; Step Int m Int -&gt; Iteratee Int m Int
sum10 (Continue k) = k $ Chunks [1..10]
sum10 step = returnI step</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets3">This type signature (take a Step, return an Iteratee) turns out to be very common:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x3">type Enumerator a m b = Step a m b -&gt; Iteratee a m b</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets4">Meaning sum10&#39;s type signature could also be expressed as:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x4">sum10 :: Monad m =&gt; Enumerator Int m Int</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets5">Of course, we need some helper function to connect an Enumerator and an Iteratee:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x5">applyEnum :: Monad m =&gt; Enumerator a m b -&gt; Iteratee a m b -&gt; Iteratee a m b
applyEnum enum iter = Iteratee $ do
    step &lt;- runIteratee iter
    runIteratee $ enum step</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets6">Let me repeat the intuition here: the Enumerator is transforming the Iteratee from its initial state to a new state by feeding it more data. In order to use this function, we could write:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x6">run_ (applyEnum sum10 sum6) &gt;&gt;= print</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets7">This results in 55, exactly as we&#39;d expect. But now we can see one of the benefits of enumerators: we can use multiple data sources. Let&#39;s say we have another enumerator:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x7">sum11 :: Monad m =&gt; Enumerator Int m Int
sum11 (Continue k) = k $ Chunks [11..20]
sum11 step = returnI step</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets8">Then we could simply apply both enumerators:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x8">run_ (applyEnum sum11 $ applyEnum sum10 sum6) &gt;&gt;= print</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets9">And we would get the result 210. (Yes, (1 + 20) * 10 = 210.) But don&#39;t worry, you don&#39;t
            need to write this applyEnum function yourself: enumerator provides a <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:-36--36-">$$</a> operator which does the same thing. Its
            type signature is a bit scarier, since it&#39;s a generalization of applyEnum, but it works
            the same, and even makes code more readable:</p><pre class="codeblock" id="file202-enumerator-type-synonym/x10">run_ (sum11 $$ sum10 $$ sum6) &gt;&gt;= print</pre><p class="hascomments" id="file202-enumerator-type-synonym/ets10"><code id="file202-enumerator-type-synonym/x11">$$</code> is a synonym for <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:-61--61--60--60-">==&lt;&lt;</a>, which is simply flip <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:-62--62--61--61-">&gt;&gt;==</a>. I find <code id="file202-enumerator-type-synonym/x14">$$</code> the most readable, but YMMV (YMMV).</p></section><section class="subtopic" id="file203-some-built-in-enumerators"><h1>Some built-in enumerators</h1><p class="hascomments" id="file203-some-built-in-enumerators/builtin1">Of course, writing a whole function just to pass some numbers to our sum function seems a bit tedious. We could easily make the list an argument to the function:</p><pre class="codeblock" id="file203-some-built-in-enumerators/x1">sum12 :: Monad m =&gt; [Int] -&gt; Enumerator Int m Int
sum12 nums (Continue k) = k $ Chunks nums
sum12 _ step = returnI step</pre><p class="hascomments" id="file203-some-built-in-enumerators/builtin2">But now there&#39;s not even anything Int-specific in our function. We could easily generalize this to:</p><pre class="codeblock" id="file203-some-built-in-enumerators/x2">genericSum12 :: Monad m =&gt; [a] -&gt; Enumerator a m b
genericSum12 nums (Continue k) = k $ Chunks nums
genericSum12 _ step = returnI step</pre><p class="hascomments" id="file203-some-built-in-enumerators/builtin3">And in fact, enumerator comes built in with the <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:enumList">enumList</a> function which does
                        this. enumList also takes an Integer argument to indicate the maximum number
                        of elements to stick in a chunk. For example, we could write:</p><pre class="codeblock" id="file203-some-built-in-enumerators/x4">run_ (enumList 5 [1..30] $$ sum6) &gt;&gt;= print</pre><p class="hascomments" id="file203-some-built-in-enumerators/builtin4">(That produces 465 if you&#39;re counting.) The first argument to enumList should never affect the result, though it may have some performance impact.</p><p class="hascomments" id="file203-some-built-in-enumerators/builtin5">Data.Enumerator includes two other enumerators: <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:enumEOF">enumEOF</a> simply passes an EOF
                        to the iteratee. <a href="http://hackage.haskell.org/packages/archive/enumerator/0.4.0.2/doc/html/Data-Enumerator.html#v:concatEnums">concatEnums</a> is slightly more
                        interesting; it combines multiple enumerators together. For example:</p><pre class="codeblock" id="file203-some-built-in-enumerators/x7">run_ (concatEnums
        [ enumList 1 [1..10]
        , enumList 1 [11..20]
        , enumList 1 [21..30]
        ] $$ sum6) &gt;&gt;= print</pre><p class="hascomments" id="file203-some-built-in-enumerators/builtin6">This also produces 465.</p></section><section class="subtopic" id="file204-some-non-pure-input"><h1>Some non-pure input</h1><p class="hascomments" id="file204-some-non-pure-input/np1">Enumerators are much more interesting when they aren&#39;t simply dealing with pure values. In the first part of this tutorial, we gave the example of the user entering numbers on the command line:</p><pre class="codeblock" id="file204-some-non-pure-input/x1">getNumber :: IO (Maybe Int)
getNumber = do
    x &lt;- getLine
    if x == &quot;q&quot;
        then return Nothing
        else return $ Just $ read x

sum2 :: IO Int
sum2 = do
    maybeNum &lt;- getNumber
    case maybeNum of
        Nothing -&gt; return 0
        Just num -&gt; do
            rest &lt;- sum2
            return $ num + rest</pre><p class="hascomments" id="file204-some-non-pure-input/np2">We referred to this as the pull-model: sum2 pulled each value from getNumber. Let&#39;s see if we can rewrite getNumber to be a pusher instead of a pullee.</p><pre class="codeblock" id="file204-some-non-pure-input/x2">getNumberEnum :: MonadIO m =&gt; Enumerator Int m b
getNumberEnum (Continue k) = do
    x &lt;- liftIO getLine
    if x == &quot;q&quot;
        then continue k
        else k (Chunks [read x]) &gt;&gt;== getNumberEnum
getNumberEnum step = returnI step</pre><p class="hascomments" id="file204-some-non-pure-input/np3">First, notice that we check which constructor was passed, and only perform any actions if it was Continue. If it was Continue, we get the line of input from the user. If the line is &quot;q&quot; (our indication to stop feeding in values), we do nothing. You <i id="file204-some-non-pure-input/x3">might</i> have thought that we should pass an EOF. But if we did that, we&#39;d be preventing other data from being sent to this iteratee. Instead, we simply return the original Step value.</p><p class="hascomments" id="file204-some-non-pure-input/np4">If the line was not &quot;q&quot;, we convert it to an Int via read, create a Stream value with the Chunks datatype, and pass it to k. (If we wanted to do things properly, we&#39;d check if x is really an Int and use the Error constructor; I leave that as an exercise to the reader.) At this point, let&#39;s look at type signatures:</p><pre class="codeblock" id="file204-some-non-pure-input/x4">k (Chunks [read x]) :: Iteratee Int m b</pre><p class="hascomments" id="file204-some-non-pure-input/np5">If we simply left off the rest of the line, our program would typecheck. However, it would only ever read one value from the command line; the <code id="file204-some-non-pure-input/x5">&gt;&gt;== getNumberEnum</code> causes our enumerator to loop.</p><p class="hascomments" id="file204-some-non-pure-input/np6">One last thing to note about our function: notice the b in our type signature.</p><pre class="codeblock" id="file204-some-non-pure-input/x6">getNumberEnum :: MonadIO m =&gt; Enumerator Int m b</pre><p class="hascomments" id="file204-some-non-pure-input/np7">This is saying that our Enumerator can feed <code id="file204-some-non-pure-input/x7">Int</code>s to any Iteratee accepting <code id="file204-some-non-pure-input/x8">Int</code>s, and it doesn&#39;t matter what the final output type will be. This is in general the way enumerators work. This allows us to create drastically different iteratees that work with the same enumerators:</p><pre class="codeblock" id="file204-some-non-pure-input/x9">intsToStrings :: (Show a, Monad m) =&gt; Iteratee a m String
intsToStrings = (unlines . map show) `fmap` consume</pre><p class="hascomments" id="file204-some-non-pure-input/np8">And then both of these lines work:</p><pre class="codeblock" id="file204-some-non-pure-input/x10">run_ (getNumberEnum $$ sum6) &gt;&gt;= print
run_ (getNumberEnum $$ intsToStrings) &gt;&gt;= print</pre></section><section class="subtopic" id="file197-exercises"><h1>Exercises</h1><ol id="file197-exercises/x1"><li id="file197-exercises/x2">Write an enumeratee which takes hex chars (eg, &quot;DEADBEEF&quot;) to Word8s. Its type signature should be <code id="file197-exercises/x3">Enumeratee Char Word8 m b</code>.</li><li id="file197-exercises/x4">Write the opposite enumeratee, eg <code id="file197-exercises/x5">Enumeratee Word8 Char m b</code>.</li><li id="file197-exercises/x6">Create a quickcheck property that ensures that these two functions work correctly.</li></ol></section><section class="subtopic" id="file198-summary"><h1>Summary</h1><ul id="file198-summary/x1"><li id="file198-summary/x2">Enumeratees are the pipes connecting enumerators to iteratees.</li><li id="file198-summary/x3">The strange type signature of an Enumeratee hides a lot of possible power. Especially notice how similar their type signatures are to Enumerators.</li><li id="file198-summary/x4">You can merge an Enumeratee into an Iteratee with <code id="file198-summary/x5">joinI $ enumeratee $$ iteratee</code>.</li><li id="file198-summary/x6">Don&#39;t forget that you can use the Monad instance of Iteratee when creating your own enumeratees.</li><li id="file198-summary/x7">You can always compose multiple enumeratees together, such as in http-enumerator.</li></ul></section></section><section class="subtopic" id="file210-enumeratees"><h1>Enumeratees</h1>
        <p class="hascomments">The final piece in the puzzle is the Enumeratee. This is a combination of an Iteratee (it
            consumes some data) and an Enumerator (is passes it other data on). It can be thought of
            as a <i>stream transformer</i>, or as a pipe connecting an Enumerator to an
            Iteratee.</p>
    <section class="subtopic" id="file206-generalizing-getnumberenum"><h1>Generalizing getNumberEnum</h1><p class="hascomments" id="file206-generalizing-getnumberenum/gen1">Earlier, we created a getNumberEnum function with a type signature:</p><pre class="codeblock" id="file206-generalizing-getnumberenum/x1">getNumberEnum :: MonadIO m =&gt; Enumerator Int m b</pre><p class="hascomments" id="file206-generalizing-getnumberenum/gen2">If you don&#39;t remember, this means getNumberEnum produces a stream of <code id="file206-generalizing-getnumberenum/x2">Int</code>s. In particular, our getNumberEnum function read lines from stdin, converted them to ints and fed them into an iteratee. It stopped reading lines when it saw a &quot;q&quot;.</p><p class="hascomments" id="file206-generalizing-getnumberenum/gen3">But this functionality seems like it could be useful outside the realm of Ints. We may like to deal with the original Strings, for example, or Bools, or a bunch of other things. We could easily define a more generalized function which simply doesn&#39;t do the String to Int conversion:</p><pre class="codeblock" id="file206-generalizing-getnumberenum/x3">lineEnum :: MonadIO m =&gt; Enumerator String m b
lineEnum (Continue k) = do
    x &lt;- liftIO getLine
    if x == &quot;q&quot;
        then continue k
        else k (Chunks [x]) &gt;&gt;== lineEnum
lineEnum step = returnI step</pre><p class="hascomments" id="file206-generalizing-getnumberenum/gen4">Cool, let&#39;s plug this into our sumIter function (I&#39;ve renamed the sum6 function from the previous two parts):</p><pre class="codeblock" id="file206-generalizing-getnumberenum/x4">lineEnum $$ sumIter</pre><p class="hascomments" id="file206-generalizing-getnumberenum/gen5">Actually, that doesn&#39;t type check: lineEnum produces <code id="file206-generalizing-getnumberenum/x5">String</code>s, and sumIter takes <code id="file206-generalizing-getnumberenum/x6">Int</code>s. We need to modify one of them somehow.</p><pre class="codeblock" id="file206-generalizing-getnumberenum/x7">sumIterString :: Monad m =&gt; Iteratee String m Int
sumIterString = Iteratee $ do
    innerStep &lt;- runIteratee sumIter
    return $ go innerStep
  where
    go :: Monad m =&gt; Step Int m Int -&gt; Step String m Int
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -&gt; Iteratee $ do
        let ints = fmap read strings :: Stream Int
        step &lt;- runIteratee $ k ints
        return $ go step</pre><p class="hascomments" id="file206-generalizing-getnumberenum/gen6">What we&#39;ve done here is wrap around the original iteratee. As usual, we first need to unwrap the Iteratee constructor and the monad to get at the heart of the Step value. Once we have that innerStep value, we pass it to the go function, which simply transforms that values in the Stream value from Strings to Ints.</p></section><section class="subtopic" id="file207-even-more-general"><h1>Even more general</h1><p class="hascomments" id="file207-even-more-general/moregen1">Of course, it would be nice if we could apply this transformation to *any* iteratee. To start with, let&#39;s just pass the inner iteratee and the mapping function as parameters.</p><pre class="codeblock" id="file207-even-more-general/x1">mapIter :: Monad m =&gt; (aOut -&gt; aIn) -&gt; Iteratee aIn m b -&gt; Iteratee aOut m b
mapIter f innerIter = Iteratee $ do
    innerStep &lt;- runIteratee innerIter
    return $ go innerStep
  where
    go (Yield res _) = Yield res EOF
    go (Error err) = Error err
    go (Continue k) = Continue $ \strings -&gt; Iteratee $ do
        let ints = fmap f strings
        step &lt;- runIteratee $ k ints
        return $ go step</pre><p class="hascomments" id="file207-even-more-general/moregen2">We could call this like:</p><pre class="codeblock" id="file207-even-more-general/x2">run_ (lineEnum $$ mapIter read sumIter) &gt;&gt;= print</pre><p class="hascomments" id="file207-even-more-general/moregen3">Nothing much to see here, it&#39;s basically identical to the previous version. What&#39;s funny is that enumerator comes built in with a <code id="file207-even-more-general/x3">map</code> function to do just this, but it has a significantly different type signature:</p><pre class="codeblock" id="file207-even-more-general/x4">map :: Monad m =&gt; (ao -&gt; ai) -&gt; Enumeratee ao ai m b</pre><p class="hascomments" id="file207-even-more-general/moregen4">since:</p><pre class="codeblock" id="file207-even-more-general/x5">type Enumeratee aOut aIn m b = Step aIn m b -&gt; Iteratee aOut m (Step aIn m b)</pre><p class="hascomments" id="file207-even-more-general/moregen5">that&#39;s equivalent to:</p><pre class="codeblock" id="file207-even-more-general/x6">map :: Monad m =&gt; (aOut -&gt; aIn) -&gt; Step aIn m b -&gt; Iteratee aOut m (Step aIn m b)</pre><p class="hascomments" id="file207-even-more-general/moregen6">What&#39;s with all this extra complication in type signature? Well, it&#39;s not necessary for map itself, but it <i id="file207-even-more-general/x7">is</i> necessary for a whole bunch of other similar functions. But let&#39;s focus on this map for a second so we don&#39;t get lost: the first argument is the same old mapping function we had before. The second argument is a Step value. This isn&#39;t really so surprising: in our mapIter, we took an Iteratee with the same parameters, and we internally just unwrapped it to a Step.</p><p class="hascomments" id="file207-even-more-general/moregen7">But what&#39;s happening with that return value? Remembering the meanings for all these datatypes, it&#39;s an Iteratee which will be fed a stream of <code id="file207-even-more-general/x8">aOut</code>s and return a Step (aka, a new iteratee, right?). This kind of makes intuitive sense: we&#39;ve introduced a middle man which accepts input from one source and transforms a Step to a newer state.</p><p class="hascomments" id="file207-even-more-general/moregen8">But now perhaps the trickiest part of the whole thing: how do we actually <i id="file207-even-more-general/x9">use</i> this map function? It turns out that an Enumeratee is close enough in type signature to an Enumerator that we can just do:</p><pre class="codeblock" id="file207-even-more-general/x10">map read $$ sumIter</pre><p class="hascomments" id="file207-even-more-general/moregen9">But the type signature on <i id="file207-even-more-general/x11">that</i> turns out to be a little bit weird:</p><pre class="codeblock" id="file207-even-more-general/x12">Iteratee String m (Step Int m Int)</pre><p class="hascomments" id="file207-even-more-general/moregen10">Remembering that an Iteratee is just a wrapped up Step, what we&#39;ve got <i id="file207-even-more-general/x13">here</i> is an iteratee that takes Strings and returns an Iteratee, which in turn takes Ints and produces an Int. Having this fancy result allows us to do one of our great tricks with iteratees: plug in data from multiple sources. For example, we could plug some Strings into this whole ugly thing, run it, get a <i id="file207-even-more-general/x14">new</i> iteratee which takes Ints, feed <i id="file207-even-more-general/x15">that</i> some Ints and get an Int result.</p><p class="hascomments" id="file207-even-more-general/moregen11">(If all that went over your head, don&#39;t worry. I won&#39;t be talking about that kind of stuff any more.)</p><p class="hascomments" id="file207-even-more-general/moregen12">But often times, we <i id="file207-even-more-general/x16">don&#39;t</i> need all of that power. We just want to stick our enumeratee onto our iteratee and get a new iteratee. In our case, we want to attach our map onto the sumIter to produce a new iteratee that takes Strings and returns Ints. In order to do that, we need a function like this:</p><pre class="codeblock" id="file207-even-more-general/x17">unnest :: Monad m =&gt; Iteratee String m (Step Int m Int) -&gt; Iteratee String m Int
unnest outer = do -- using the Monad instance of Iteratee
    inner &lt;- outer -- inner :: Step Int m Int
    go inner
  where
    go (Error e) = throwError e
    go (Yield x _) = yield x EOF
    go (Continue k) = k EOF &gt;&gt;== go</pre><p class="hascomments" id="file207-even-more-general/moregen13">We can then run our unholy mess with:</p><pre class="codeblock" id="file207-even-more-general/x18">run_ (lineEnum $$ unnest $ map read $$ sumIter) &gt;&gt;= print</pre><p class="hascomments" id="file207-even-more-general/moregen14">And actually, the unnest function is available in Data.Enumerator, and it&#39;s called joinI. So we should really write:</p><pre class="codeblock" id="file207-even-more-general/x19">run_ (lineEnum $$ joinI $ map read $$ sumIter) &gt;&gt;= print</pre></section><section class="subtopic" id="file208-skipping"><h1>Skipping</h1><p class="hascomments" id="file208-skipping/skipping1">Let&#39;s write a slightly more interesting enumeratee: this one skips every other input value.</p><pre class="codeblock" id="file208-skipping/x1">skip :: Monad m =&gt; Enumeratee a a m b
skip (Continue k) = do
    x &lt;- head
    _ &lt;- head -- the one we&#39;re skipping
    case x of
        Nothing -&gt; return $ Continue k
        Just y -&gt; do
            newStep &lt;- lift $ runIteratee $ k $ Chunks [y]
            skip newStep
skip step = return step</pre><p class="hascomments" id="file208-skipping/skipping2">What&#39;s interesting about the approach here is how similar it looks to an Enumerator. We&#39;re doing a lot of the same things: checking if the Step value is a Continue; if it&#39;s not, then simply return it. Then we capitalize on the Iteratee Monad instance, using the head function to pop two values out of the stream. If there&#39;s no more data, we return the original Continue value: just like with an Enumerator, we don&#39;t give an EOF so that we can feed more data into the iteratee later. If there is data, we pass it off to the iteratee, get our new step value and then loop.</p><p class="hascomments" id="file208-skipping/skipping3">And what&#39;s cool about enumeratees is we can chain these all together:</p><pre class="codeblock" id="file208-skipping/x2">run_ (lineEnum $$ joinI $ skip $$ joinI $ map read $$ sumIter) &gt;&gt;= print</pre><p class="hascomments" id="file208-skipping/skipping4">Here, we read lines, skip every other input, convert the Strings to Ints and sum them.</p></section><section class="subtopic" id="file209-real-life-examples-http-enumerator-package"><h1>Real life examples: http-enumerator package</h1><p class="hascomments" id="file209-real-life-examples-http-enumerator-package/reallife1">I started working on these tutorials as I was working on the <dfn class="apiname" id="file209-real-life-examples-http-enumerator-package/x1">http-enumerator</dfn> package. I think the usage of enumeratees there is a great explanation of the benefits they can offer in real life. There are three different ways the response body can be broken up:</p><ul id="file209-real-life-examples-http-enumerator-package/x2"><li id="file209-real-life-examples-http-enumerator-package/x3">Chunked encoding. In this case, the web server gives a hex string specifying the length of the next chunk and then that chunk. At the end, it sends a 0 to indicate the end of that response.</li><li id="file209-real-life-examples-http-enumerator-package/x4">Content length. Here, the web server sends a header before any of the body is sent specifying the total length of the body.</li><li id="file209-real-life-examples-http-enumerator-package/x5">Nothing at all. In this case, the response body lasts until an end-of-file.</li></ul><p class="hascomments" id="file209-real-life-examples-http-enumerator-package/reallife2">In addition, the body may or may not be GZIP compressed. We end up with the following enumeratees, each with type signature <code id="file209-real-life-examples-http-enumerator-package/x6">Enumeratee ByteString ByteString m b</code>: chunkedEncoding, contentLength and ungzip. We then get to do something akin to:</p><pre class="codeblock" id="file209-real-life-examples-http-enumerator-package/x7">let parseBody x =
        if (&quot;transfer-encoding&quot;, &quot;chunked&quot;) `elem` responseHeaders
            then joinI $ chunkedEncoding $$ x
            else case mlen of
                    Just len -&gt; joinI $ contentLength len $$ x
                    Nothing -&gt; x -- no enumeratee applied at all
let decompress x =
        if (&quot;content-encoding&quot;, &quot;gzip&quot;) `elem` responseHeaders
            then joinI $ ungzip $$ x
            else x
run_ $ socketEnumerator $$ parseBody $ decompress $ bodyIteratee</pre><p class="hascomments" id="file209-real-life-examples-http-enumerator-package/reallife3">We create a chain: the data from the server is fed into the parseBody function. In the case of chunked encoding, the data is processed appropriately and then headers are filtered out. If we are dealing with content length, then only the specified number of bytes are read. And in the case of neither of those, parseBody is a no-op.</p><p class="hascomments" id="file209-real-life-examples-http-enumerator-package/reallife4">Whatever the case may be, the raw response body is then fed into decompress. If the body is GZIPed, then ungzip inflates it, otherwise decompress is a no-op. Finally, the parsed and inflated data is fed into the user-supplied bodyIteratee function. The user remains blissfully unaware of any steps the data took to get to him/her.</p></section><section class="subtopic" id="file197-exercises"><h1>Exercises</h1><ol id="file197-exercises/x1"><li id="file197-exercises/x2">Write an enumeratee which takes hex chars (eg, &quot;DEADBEEF&quot;) to Word8s. Its type signature should be <code id="file197-exercises/x3">Enumeratee Char Word8 m b</code>.</li><li id="file197-exercises/x4">Write the opposite enumeratee, eg <code id="file197-exercises/x5">Enumeratee Word8 Char m b</code>.</li><li id="file197-exercises/x6">Create a quickcheck property that ensures that these two functions work correctly.</li></ol></section><section class="subtopic" id="file198-summary"><h1>Summary</h1><ul id="file198-summary/x1"><li id="file198-summary/x2">Enumeratees are the pipes connecting enumerators to iteratees.</li><li id="file198-summary/x3">The strange type signature of an Enumeratee hides a lot of possible power. Especially notice how similar their type signatures are to Enumerators.</li><li id="file198-summary/x4">You can merge an Enumeratee into an Iteratee with <code id="file198-summary/x5">joinI $ enumeratee $$ iteratee</code>.</li><li id="file198-summary/x6">Don&#39;t forget that you can use the Monad instance of Iteratee when creating your own enumeratees.</li><li id="file198-summary/x7">You can always compose multiple enumeratees together, such as in http-enumerator.</li></ul></section></section></article></body></html>
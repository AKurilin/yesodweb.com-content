<!DOCTYPE HTML>
<html><head><title>Creating a Subsite</title></head><body><header><h1>Creating a Subsite</h1></header><article id="file176-creating-a-subsite"><p class="hascomments" id="file176-creating-a-subsite/i1">How many sites provide authentication systems? Or need to provide CRUD (CRUD) management of some objects? Or a blog? Or a wiki?</p><p class="hascomments" id="file176-creating-a-subsite/i2">The theme here is that many websites include common components that can be reused throughout multiple sites. However, it is often quite difficult to get code to be modular enough to be truly plug-and-play: a component will require hooks into the routing system, usually for multiple routes, and will need some way of sharing styling information with the master site.</p><p class="hascomments" id="file176-creating-a-subsite/i3">In Yesod, the solution is subsites. A subsite is a collection of routes and their handlers that can be easily inserted into a master site. By using type classes, it is easy to ensure that the master site provides certain capabilities, and to access the default site layout. And with type-safe URLs, it&#39;s easy to link from the master site to subsites.</p><section class="subtopic" id="file175-hello-world"><h1>Hello World</h1><p class="hascomments" id="file175-hello-world/hw1">Writing subsites is a little bit tricky, involving a number of different types. Let&#39;s start off with a simple Hello World subsite:</p><pre class="codeblock" id="file175-hello-world/x1">-- START
{-# LANGUAGE QuasiQuotes, TypeFamilies, MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell, FlexibleInstances, OverloadedStrings #-}
import Yesod

-- Subsites have foundations just like master sites.
data HelloSub = HelloSub

-- We have a familiar analogue from mkYesod, with just one extra parameter.
-- We&#39;ll discuss that later.
mkYesodSub &quot;HelloSub&quot; [] [parseRoutes|
/ SubRootR GET
|]

-- And we&#39;ll spell out the handler type signature.
getSubRootR :: Yesod master =&gt; GHandler HelloSub master RepHtml
getSubRootR = defaultLayout [whamlet|Welcome to the subsite!|]

-- And let&#39;s create a master site that calls it.
data Master = Master
    { getHelloSub :: HelloSub
    }

mkYesod &quot;Master&quot; [parseRoutes|
/ RootR GET
/subsite SubsiteR HelloSub getHelloSub
|]

instance Yesod Master where
    approot _ = &quot;&quot;

-- Spelling out type signature again.
getRootR :: GHandler sub Master RepHtml -- could also replace sub with Master
getRootR = defaultLayout [whamlet|
&lt;h1&gt;Welcome to the homepage
&lt;p&gt;
    Feel free to visit the #
    &lt;a href=@{SubsiteR SubRootR}&gt;subsite
    \ as well.
|]

main = warpDebug 3000 $ Master HelloSub
</pre><p class="hascomments" id="file175-hello-world/hw2">This very simple example actually shows most of the complications involved in creating a subsite. Like a normal Yesod application, everything in a subsite is centered around a foundation datatype, <code id="file175-hello-world/x2">HelloSub</code> in our case. We then use <code id="file175-hello-world/x3">mkYesodSub</code>, in much the same way that we use <code id="file175-hello-world/x4">mkYesod</code>, to create the route datatype and the dispatch/render functions. (We&#39;ll come back to that extra parameter in a second.)</p><p class="hascomments" id="file175-hello-world/hw3">What&#39;s interesting is the type signature of <code id="file175-hello-world/x5">getSubRootR</code>. Up until now, we have tried to ignore the <code id="file175-hello-world/x6">GHandler</code> datatype, or <i id="file175-hello-world/x7">if</i> we need to acknowledge its existence, pretend like the first two type arguments are always the same. Now we get to finally acknowledge the truth about this funny datatype.</p><p class="hascomments" id="file175-hello-world/hw4">A handler function always has two foundation types associated with it: the subsite and the master site. When you write a normal application, <b id="file175-hello-world/x8">those two datatypes are the same</b>. However, when you are working in a subsite, they will necessarily be different. So the type signature for <code id="file175-hello-world/x9">getSubRootR</code> uses <code id="file175-hello-world/x10">HelloSub</code> for the first argument and <code id="file175-hello-world/x11">master</code> for the second.</p><p class="hascomments" id="file175-hello-world/hw5">The <code id="file175-hello-world/x12">defaultLayout</code> function is part of the Yesod typeclass. Therefore, in order to call it, the <code id="file175-hello-world/x13">master</code> type argument must be an instance of <code id="file175-hello-world/x14">Yesod</code>. The advantage of this approach is that any modifications to the master site&#39;s <code id="file175-hello-world/x15">defaultLayout</code> method will automatically be reflected in subsites.</p><p class="hascomments" id="file175-hello-world/hw6">When we embed a subsite in our master site route definition, we need to specify four pieces of information: the route to use as the base of the subsite (in this case, <code id="file175-hello-world/x16">/subsite</code>), the constructor for the subsite routes (<code id="file175-hello-world/x17">SubsiteR</code>), the subsite foundation data type (<code id="file175-hello-world/x18">HelloSub</code>) and a function that takes a master foundation value and returns a subsite foundation value (<code id="file175-hello-world/x19">getHelloSub</code>).</p><p class="hascomments" id="file175-hello-world/hw7">In the definition of getRootR, we can see how the route constructor gets used. In a sense, <code id="file175-hello-world/x20">SubsiteR</code> promotes any subsite route to a master site route, making it possible to safely link to it from any master site template.</p></section></article></body></html>
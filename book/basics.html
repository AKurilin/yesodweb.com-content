<!DOCTYPE HTML>
<html><head><title>Basics</title></head><body><header><h1>Basics</h1></header><article id="file18-basics">
        <p class="hascomments" id="file18-basics/x-3">The first step with any new technology is getting it running. The goal of this chapter is
            to get you started with a simple Yesod application, and cover some of the basic concepts
            and terminology.</p>
    <section class="subtopic" id="file8-getting-yesod"><h1>Getting Yesod</h1><p class="hascomments" id="file8-getting-yesod/assume-installed">In order to use Yesod, you&#39;re going to need to install it on your system.
            In addition, you&#39;re going to need a Haskell development environment. The recommended
            approach is to install the <a href="http://hackage.haskell.org/platform/">Haskell Platform</a>. This will include the
            Glasgow Haskell Compiler (GHC), Cabal (the package installer, similar to Perl&#39;s CPAN or
            Ruby&#39;s Gems) and some core libraries.</p>
        <p class="hascomments" id="file8-getting-yesod/x-3">Besides the Haskell Platform, there are two other common approaches to getting started
            with Haskell: downloading GHC directly, and (on Linux) installing from your
            distribution&#39;s package manager. I&#39;m going to advise against these:</p>
        <ul id="file8-getting-yesod/ul_brk_rrt_qd">
            <li id="file8-getting-yesod/x-4">Yesod is actively tested on the most recent Haskell Platform. We try to make sure it
                works with other versions of GHC as well, but you may run into issues.</li>
            <li id="file8-getting-yesod/x-5">The Haskell Platform includes some utilities (like alex and happy) that are not
                automatically installed with a normal GHC install.</li>
            <li id="file8-getting-yesod/x-6">Most distributions have very out-of-date versions of GHC. At the time of writing,
                for example, Ubuntu provides GHC 6.12, while the newest GHC is 7.2.</li>
        </ul>
        <p class="hascomments" id="file8-getting-yesod/x-7">One other note: on Linux systems, the Haskell Platform will rely on some system
            libraries, and without them, you may get some funny error messages. Please make sure you
            install all the <a href="http://www.vex.net/%7Etrebla/haskell/haskell-platform.xhtml">required C libraries</a>. On Debian-based systems,
            you would need to run:</p>
        <pre class="codeblock" id="file8-getting-yesod/x-9">sudo apt-get install libedit-dev libbsd-dev libgmp3-dev zlib1g-dev freeglut3-dev</pre>
        <p class="hascomments" id="file8-getting-yesod/x-10">Once you have the Haskell Platform installed, it&#39;s time to get familiar with Cabal. This
            utility will automatically resolve dependencies for your packages, download them from
            Hackage (the package database) and install them. Make sure you have the cabal executable
            available in your PATH variable, and then you can install Yesod with just two
            commands:</p>
        <dl id="file8-getting-yesod/x-11">
            
                <dt id="file8-getting-yesod/x-13"><code id="file8-getting-yesod/x-14">cabal update</code></dt>
                <dd id="file8-getting-yesod/x-15">This will download a list of all the packages available on Hackage. You should
                    run this every few days to stay up-to-date.</dd>
            
            
                <dt id="file8-getting-yesod/x-17"><code id="file8-getting-yesod/x-18">cabal install yesod</code></dt>
                <dd id="file8-getting-yesod/x-19">This will install Yesod and all its dependencies. Go get a cup of coffee.</dd>
            
        </dl></section><section class="subtopic" id="file9-scaffolded-site"><h1>The scaffolded site</h1>
    <p class="hascomments" id="file9-scaffolded-site/x-3">Installing Yesod will give you both the Yesod library, as well as a <code id="file9-scaffolded-site/x-4">yesod</code>
      executable. This executable accepts a few commands, but the first one you&#39;ll want to be
      acquainted with is <code id="file9-scaffolded-site/x-5">yesod init</code>. It will ask you some questions, and then
      generate a folder containing the default <dfn id="file9-scaffolded-site/x-6">scaffolded site</dfn>. Inside that folder, you
      can run <code id="file9-scaffolded-site/x-7">cabal install</code> to build any extra dependency, and then <a href="../../../topics/yesod-web-framework-book/basics/basics.html#file16-development-serverbasics"><code id="file9-scaffolded-site/x-9">yesod
        devel</code></a> to run your site. Here is an example session with the scaffolding
      tool:</p>
    <pre class="codeblock" id="file9-scaffolded-site/x-10">Welcome to the Yesod scaffolder.
I&#39;m going to be creating a skeleton Yesod project for you.

What is your name? We&#39;re going to put this in the cabal and LICENSE files.

Your name: <kbd id="file9-scaffolded-site/x-11">Michael</kbd>
Welcome Michael.
What do you want to call your project? We&#39;ll use this for the cabal name.

Project name: <kbd id="file9-scaffolded-site/x-12">my-first-project</kbd>
Great, we&#39;ll be creating my-first-project today, and placing it in my-first-project.
What&#39;s going to be the name of your foundation datatype? This name must
start with a capital letter.

Foundation: <kbd id="file9-scaffolded-site/x-13">FirstProject</kbd>
Yesod uses Persistent for its (you guessed it) persistence layer.
This tool will build in either SQLite or PostgreSQL or MongoDB support for you.
We recommend starting with SQLite: it has no dependencies.

We have another option: a tiny project with minimal dependencies.
Mostly this means no database and no authentication.

So, what&#39;ll it be?
s for sqlite, p for postgresql, m for mongodb, or t for tiny: <kbd id="file9-scaffolded-site/x-14">s</kbd>
That&#39;s it! I&#39;m creating your files now...
Generating deploy/Procfile
Generating config/sqlite.yml
Generating config/settings.yml
Generating main.hs
Generating my-first-project.cabal
Generating .ghci
Generating LICENSE
Generating Foundation.hs
Generating Import.hs
Generating Application.hs
Generating Handler/Root.hs
Generating Model.hs
Generating Settings.hs
Generating Settings/StaticFiles.hs
Generating templates/default-layout.lucius
Generating templates/default-layout.hamlet
Generating templates/default-layout-wrapper.hamlet
Generating templates/boilerplate-wrapper.hamlet
Generating templates/normalize.lucius
Generating templates/homepage.hamlet
Generating config/routes
Generating templates/homepage.lucius
Generating templates/homepage.julius
Generating config/models
Generating messages/en.msg

---------------------------------------

                     ___
                            {-)   |\
                       [m,].-&quot;-.   /
      [][__][__]         \(/\__/\)/
      [__][__][__][__]  |  |
      [][__][__][__][__][] /   |
      [__][__][__][__][__]| /| |
      [][__][__][__][__][]| || |  
  ejm [__][__][__][__][__]__,__,  \__/


---------------------------------------

The foundation for your site has been laid.


There are a lot of resources to help you use Yesod.
Start with the book: http://www.yesodweb.com/book
Take part in the community: http://yesodweb.com/page/community


Start your project:

   cd my-first-project &amp;&amp; cabal install &amp;&amp; yesod devel

or if you use cabal-dev:

   cd my-first-project &amp;&amp; cabal-dev install &amp;&amp; yesod --dev devel
</pre>
    <p class="hascomments" id="file9-scaffolded-site/x-15">The scaffolded site gives you a lot of best practices out of the box, setting up files and
      dependencies in a time-tested approach used by most production Yesod sites. However, all this
      convenience can get in the way of actually learning Yesod. Therefore, most of this book will
      avoid the scaffolding tool, and instead deal directly with Yesod as a library.</p>
    <p class="hascomments" id="file9-scaffolded-site/x-16">We will cover the structure of the scaffolded site in more detail <a href="../../../topics/yesod-web-framework-book/scaffolding-and-the-site-template/scaffolding-and-the-site-template.html#file166-scaffolding-and-the-site-templatescaffolding">later</a>.</p>
  </section><section class="subtopic" id="file10-hello-world"><h1>Hello World</h1><p class="hascomments" id="file10-hello-world/hw1">Let&#39;s get this book started properly: a simple web page that says Hello World:</p><pre class="codeblock" id="file10-hello-world/x1">-- START
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod &quot;HelloWorld&quot; [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld where
    approot _ = &quot;&quot;

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Hello World!|]

main :: IO ()
main = warpDebug 3000 HelloWorld
-- STOP</pre><p class="hascomments" id="file10-hello-world/hw2">If you save that code in <code id="file10-hello-world/x4">helloworld.hs</code> and run it with <code id="file10-hello-world/x5">runhaskell helloworld.hs</code>, you&#39;ll get a web server running on port 3000. If you point your browser to <a href="http://localhost:3000">http://localhost:3000</a>, you&#39;ll get the following HTML:</p><pre class="codeblock" id="file10-hello-world/x7">&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;</pre>
        <p class="hascomments" id="file10-hello-world/x-3">We&#39;ll refer back to this example through the rest of the chapter.</p></section><section class="subtopic" id="file11-routing"><h1>Routing</h1><p class="hascomments" id="file11-routing/routing1">Like most modern web frameworks, Yesod follows a <a href="http://en.wikipedia.org/wiki/Front_Controller_pattern">front controller pattern</a>. This means that every request to a
            Yesod application enters at the same point and is routed from there. As a contrast, in
            systems like PHP and ASP you usually create a number of different files, and the web
            server automatically directs requests to the relevant file.</p>
        <p class="hascomments" id="file11-routing/x-3">In addition, Yesod uses a declarative style for specifying routes. In our example above,
            this looked like:</p>
        <pre class="codeblock" id="file11-routing/x-4">mkYesod &quot;HelloWorld&quot; [parseRoutes|
/ HomeR GET
|]</pre>
        <p class="hascomments" id="file11-routing/x-5">In English, all this means is: <q id="file11-routing/x-6">In the HelloWorld application, create one route. I&#39;d like
                to call it HomeR, it should listen for requests to <code id="file11-routing/x-7">/</code> (the root of
                the application), and should answer GET requests</q>. We call HomeR a
                <dfn id="file11-routing/x-8">resource</dfn>, which is where the &quot;R&quot; suffix comes from.<aside class="note" id="file11-routing/x-9">The R suffix
                on resource names is simply convention, but it&#39;s a fairly universally followed
                convention. It makes it just a bit easier to read and understand code.</aside></p>
        <p class="hascomments" id="file11-routing/x-10">As mentioned, most modern web frameworks have some kind of routing system.
            Let&#39;s take a quick example from
                Django:<blockquote id="file11-routing/x-12"><pre class="codeblock" id="file11-routing/x-13">urlpatterns = patterns(&#39;&#39;,
    (r&#39;^articles/2003/$&#39;, &#39;news.views.special_case_2003&#39;),
    (r&#39;^articles/(\d{4})/$&#39;, &#39;news.views.year_archive&#39;),
    (r&#39;^articles/(\d{4})/(\d{2})/$&#39;, &#39;news.views.month_archive&#39;),
    (r&#39;^articles/(\d{4})/(\d{2})/(\d+)/$&#39;, &#39;news.views.article_detail&#39;),
)</pre><cite id="file11-routing/x-14">https://docs.djangoproject.com/en/dev/topics/http/urls/</cite></blockquote>These routes are
            specified via a regular expression. While this is declarative, the routes are really
            being resolved by running some extra code. This has some practical ramifications.
            Firstly, there&#39;s no great ways to optimize the routing: the only way to determine which
            route matches is to go through every single regular expression linearly. Yesod&#39;s routes
            are broken down into individual pieces, and can thus be optimized for routing.</p>
        <p class="hascomments" id="file11-routing/x-15">But the more important issue is overlapping. Yesod will stop you from accidently writing
            two routes that would match the same URL. This fits in with Yesod&#39;s overall philosophy
            of catching as many errors at possible at compile time.</p>
        <aside class="note" id="file11-routing/x-16">You&#39;re probably wondering what the Django example would look like in Yesod. It looks
            very similar
            actually:<pre class="codeblock" id="file11-routing/x-17">/articles/2003 News2003R GET
/articles/#Year NewsYearR GET
/articles/#Year/#Month NewsMonthR GET
/articles/#Year/#Month/#ArticleId NewsArticleR GET</pre>But
            if you notice, the first two routes overlap! By default, Yesod will give you a compiler
            error about this. If you really want to do it anyway, you can replace
                <code id="file11-routing/x-18">parseRoutes</code> with <code id="file11-routing/x-19">parseRoutesNoCheck</code>.</aside>
        <p class="hascomments" id="file11-routing/x-20">One other quick note: you may have noticed that parseRoutes is called with a bit of a
            strange syntax with the square brackets and pipes. That&#39;s because it&#39;s a
                <dfn id="file11-routing/x-21">quasi-quoter</dfn>. Quasiquotation is a powerful Haskell feature that allows
            you to embed any arbitrary syntax within your Haskell source files. This allows us to
            keep our route declarations short and sweet.</p>
        <p class="hascomments" id="file11-routing/x-22">A lot of the examples you&#39;ll see in the book will use quasi-quotation in one way or
            another. However, many developers prefer to keep their code and declarations separate.
            Yesod also lets you declare your routes in external files using <dfn id="file11-routing/x-23">Template
                Haskell</dfn>:<pre class="codeblock" id="file11-routing/x-24">mkYesod &quot;HelloWorld&quot; $(parseRoutesFile &quot;routes&quot;)</pre></p>
        <p class="hascomments" id="file11-routing/x-25">In general, we recommend for actual development to use external files. This is
            the approach taken by the scaffolding tool, and most production Yesod code. But for
            short examples and tutorials, quasi-quotation is a great fit.</p></section><section class="subtopic" id="file12-handler-function"><h1>Handler function</h1>
        <p class="hascomments" id="file12-handler-function/x-3">So we have a route named HomeR, and it responds to GET requests. How do you
            define your response? You write a <dfn id="file12-handler-function/x-4">handler function</dfn>. Yesod follows
            a very simple naming scheme for these functions: it&#39;s the lower case method name (e.g.,
            GET becomes get) followed by the route name. In this case, the function name would be
                <code id="file12-handler-function/x-5">getHomeR</code>.</p><p class="hascomments" id="file12-handler-function/handler1">Most of the code you write in Yesod lives in handler functions. This is where you
            process user input, perform database queries and create responses. In our simple
            example, we create a response using the <code id="file12-handler-function/x-6">defaultLayout</code> function. This
            function wraps up the content it&#39;s given in your site&#39;s template. By default, it
            produces a simple HTML file including a doctype, html, head and body tags. <a href="../../../topics/yesod-web-framework-book/yesod-typeclass/yesod-typeclass.html">As we&#39;ll
                see later</a>, this function can be overridden to do much more.</p><p class="hascomments" id="file12-handler-function/handler2">In our example, we pass <code id="file12-handler-function/x2">[whamlet|Hello World!|]</code> to
                <code id="file12-handler-function/x-7">defaultLayout</code>. <code id="file12-handler-function/x-8">whamlet</code> is another quasi-quoter. In
            this case, it converts Hamlet syntax into a Widget. Hamlet is the default HTML
            templating engine in Yesod. Together with its siblings Cassius, Lucius and Julius, you
            can create HTML, CSS and Javascript in a fully type-safe and compile-time-checked
            manner. We&#39;ll see much more about this in <a href="../../../topics/yesod-web-framework-book/shakespearean-templates/shakespearean-templates.html#file43-shakespearean-templatestemplates">the Shakespeare chapter</a>.</p>
        <p class="hascomments" id="file12-handler-function/x-10">Widgets are another cornerstone of Yesod. They allow you to create modular components of
            a site consisting of HTML, CSS and Javascript and reuse them throughout your site. We&#39;ll
            get into more detail on them in <a href="../../../topics/yesod-web-framework-book/widgets-09/widgets.html#file53-widgetswidgets">their own chapter</a>.</p></section><section class="subtopic" id="file13-the-foundation"><h1>The Foundation</h1><p class="hascomments" id="file13-the-foundation/foundation1">The word &quot;HelloWorld&quot; shows up a number of times in our example. Every Yesod
            application has a <dfn id="file13-the-foundation/x-3">foundation</dfn> datatype. This datatype must be an instance of
                <a href="../../../topics/yesod-web-framework-book/yesod-typeclass/yesod-typeclass.html#file65-yesod-typeclasstypeclass">the Yesod typeclass</a>, which provides a central place for declaring a number
            of different settings controlling the execution of our application.</p>
        <p class="hascomments" id="file13-the-foundation/x-5">In our case, this datatype is pretty boring: it doesn&#39;t contain any information.
            Nonetheless, the foundation is central to how our example runs: it ties together the
            routes with the instance declaration and lets it all be run. We&#39;ll see throughout this
            book that the foundation pops up in a whole bunch of places.</p>
        <p class="hascomments" id="file13-the-foundation/x-6">But foundations don&#39;t have to be boring: they can be used to store lots of useful
            information, usually stuff that needs to be initialized at program launch and used
            throughout. Some very common examples are:</p>
        <ul id="file13-the-foundation/ul_vzn_ucu_qd">
            <li id="file13-the-foundation/x-7">A database connection pool.</li>
            <li id="file13-the-foundation/x-8">Settings loaded from a settings file.</li>
        </ul><aside class="note" id="file13-the-foundation/x4">
            <p class="hascomments" id="file13-the-foundation/foundation3">By the way, the word Yesod (יסוד) means <i id="file13-the-foundation/x5">foundation</i> in
                Hebrew.</p>
        </aside></section><section class="subtopic" id="file14-running"><h1>Running</h1><p class="hascomments" id="file14-running/running1">Once again we mention HelloWorld in our main function. Our foundation contains all
            the information we need to route and respond to requests in our application, now we just
            need to convert it into something that can run. A great function for this in Yesod is
            warpDebug, which runs the Warp webserver with debug output enabled on the specified port
            (here, it&#39;s 3000).</p><p class="hascomments" id="file14-running/running3">One of the great features of Yesod is that you aren&#39;t tied down to a single deployment strategy. Yesod is built on top of the Web Application Interface (WAI), allowing it to run on FastCGI, SCGI, Warp, or even as a desktop application using the Webkit library. We&#39;ll discuss some of these options in the <a href="../../../topics/yesod-web-framework-book/deploying-your-webapp/deploying-your-webapp.html">deployment chapter</a>. And at the end of this chapter, we will explain the <a href="../../../topics/yesod-web-framework-book/basics/basics.html">development server</a>.</p>
        <p class="hascomments" id="file14-running/x-3">Warp is the premiere deployment option for Yesod. It is a lightweight, highly efficient
            web server developed specifically for hosting Yesod. It is also used outside of Yesod
            for other Haskell development (both framework and non-framework applications), as well
            as a standard file server in a number of production environments.</p></section><section class="subtopic" id="file15-resources-and-type-safe-urls"><h1>Resources and type-safe URLs</h1><p class="hascomments" id="file15-resources-and-type-safe-urls/resources1">In our hello world, we defined just a single resource (HomeR). A web application is usually much more exciting with more than one page on it. Let&#39;s take a look:</p><pre class="codeblock" id="file15-resources-and-type-safe-urls/x1">-- START
{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses, TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod &quot;Links&quot; [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links where
    approot _ = &quot;&quot;

getHomeR  = defaultLayout [whamlet|&lt;a href=@{Page1R}&gt;Go to page 1!|]
getPage1R = defaultLayout [whamlet|&lt;a href=@{Page2R}&gt;Go to page 2!|]
getPage2R = defaultLayout [whamlet|&lt;a href=@{HomeR}&gt;Go home!|]

main = warpDebug 3000 Links
-- STOP</pre><p class="hascomments" id="file15-resources-and-type-safe-urls/resources2">Overall, this is very similar to Hello World. Our foundation is now Links instead
            of HelloWorld, and in addition to the HomeR resource, we&#39;ve added Page1R and Page2R. As
            such, we&#39;ve also added two more handler functions: getPage1R and getPage2R.</p><p class="hascomments" id="file15-resources-and-type-safe-urls/resources3">The only truly new feature is inside the whamlet quasi-quotation. We&#39;ll delve
            into syntax later, but we can see that:</p><pre class="codeblock" id="file15-resources-and-type-safe-urls/x2">&lt;a href=@{Page1R}&gt;Go to page 1!</pre><p class="hascomments" id="file15-resources-and-type-safe-urls/resources4">creates a link to the Page1R resource. The important thing to note here is that Page1R is a data constructor. By making each resource a data constructor, we have a feature called <dfn id="file15-resources-and-type-safe-urls/x3">type-safe URLs</dfn>. Instead of splicing together strings to create URLs, we simply create a plain old Haskell value. By using at-sign interpolation (@{...}), Yesod automatically renders those values to textual URLs before sending things off to the user.</p>
        <p class="hascomments" id="file15-resources-and-type-safe-urls/x-3">It&#39;s hard to over-estimate the value of type-safe URLs. They give you a huge
            amount of flexibility and robustness when developing your application. You can easily
            move URLs around at will without ever breaking links. Later, <a href="../../../topics/yesod-web-framework-book/routing-and-handlers/routing-and-handlers.html#file80-routing-and-handlersrouting-and-handlers">we&#39;ll see that routes can take parameters</a>, such as a blog entry
            URL taking the blog post ID.</p>
        <p class="hascomments" id="file15-resources-and-type-safe-urls/x-5">Let&#39;s say you want to switch from routing on the numerical post ID to a
            year/month/slug setup. In a traditional web framework, you would need to go through
            every single reference to your blog post route and update appropriately. If you miss
            one, you&#39;ll have 404s at runtime. In Yesod, all you do is update your route and compile:
            GHC will automatically find every single line of code that needs to be corrected.</p></section><section class="subtopic" id="file16-development-server"><h1>Development server</h1><p class="hascomments" id="file16-development-server/wai-handler-devel1">One of the advantages interpreted languages have over compiled languages is fast prototyping: you save changes to a file and hit refresh. If we want to make any changes to our Yesod apps above, we&#39;ll need to call runhaskell from scratch, which can be a bit tedious.</p><p class="hascomments" id="file16-development-server/wai-handler-devel2">Fortunately, there&#39;s a nice solution to this: <code id="file16-development-server/x-4">yesod
                devel</code> automatically rebuilds and reruns your code changes for you. This can
            be a great way to develop your Yesod projects, and when you&#39;re ready to move to
            production, you still get to compile down to incredibly efficient code. The Yesod
            scaffolding automatically sets things up for you. This gives you the best of both
            worlds: rapid prototyping <b id="file16-development-server/x2">and</b> fast production code.</p><p class="hascomments" id="file16-development-server/wai-handler-devel3">It&#39;s a little bit more involved to set up your code to be used by
                <code id="file16-development-server/x-3">yesod devel</code>, so our examples will just use warpDebug. But when
            you&#39;re ready to make your real-world applications, yesod devel will be waiting for
            you.</p></section><section class="subtopic" id="file17-summary"><h1>Summary</h1><p class="hascomments" id="file17-summary/summary1">Every Yesod application is built around a foundation datatype. We associate some
            resources with that datatype and define some handler functions, and Yesod handles all of
            the routing. These resources are also data constructors, which lets us have type-safe
            URLs.</p><p class="hascomments" id="file17-summary/summary2">By being built on top of WAI, Yesod applications can run with a number of different backends. warpDebug is an easy way to get started, as it&#39;s included with Yesod. For rapid development, wai-handler-devel is a good choice. And when you&#39;re ready to move to production, there are high-performance options like Warp and FastCGI.</p>
        <p class="hascomments" id="file17-summary/x-3">When developing in Yesod, we get a number of choices for coding style: quasi-quotation or
            external files, warpDebug or yesod devel, and so on. The examples in this book will tend
            towards using the choices that are easiest to copy-and-paste, but the more powerful
            options will be available when you start building real Yesod applications.</p></section></article></body></html>
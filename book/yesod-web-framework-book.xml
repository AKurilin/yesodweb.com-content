<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V5.0//EN" "http://www.docbook.org/xml/5.0/dtd/docbook.dtd">
<book>
 <title>Yesod Web Framework Book</title>
 <part>
  <title>Basics</title>
  <include href="ch00.xml" xmlns="http://www.w3.org/2001/XInclude"/>
  <chapter>
   <title>Introduction</title>
   <para/>
   <para/>
   <para>Since web programming began, people have been trying to make the development process a more pleasant one. As a community, we have continually pushed new techniques to try and solve some of the lingering difficulties of security threats, the stateless nature of HTTP, the multiple languages (HTML, CSS, Javascript) necessary to create a powerful web application, and more.</para>
   <para>Yesod attempts to ease the web development process by playing to the strengths of the Haskell programming language. Haskell's strong compile-time guarantees of correctness not only encompass types; referential transparency ensures that we don't have any unintended side effects. Pattern matching on algebraic data types can help guarantee we've accounted for every possible case. By building upon Haskell, entire classes of bugs disappear.</para>
   <para>Unfortunately, using Haskell isn't enough. The web, by its very nature, is <emphasis>not</emphasis> type safe. Even the simplest case of distinguishing between an integer and string is impossible: all data on the web is transferred as raw bytes, evading our best efforts at type safety. Every app writer is left with the task of validating all input. I call this problem <glossterm>the boundary issue</glossterm>: as much as your application is type safe on the inside, every boundary with the outside world still needs to be sanitized.</para>
   <section>
    <title>Type Safety</title>
    <para/>
    <para>This is where Yesod comes in. By using high-level declarative techniques, you can specify the exact input types you are expecting. And the process works the other way as well: using a process of type-safe URLs, you can make sure that the data you send out is also guaranteed to be well formed.</para>
    <para>The boundary issue is not just a problem when dealing with the client: the same problem exists when persisting and loading data. Once again, Yesod saves you on the boundary by performing the marshaling of data for you. You can specify your entities in a high-level definition and remain blissfully ignorant of the details.</para>
   </section>
   <section>
    <title>Concise</title>
    <para/>
    <para>We all know that there is a lot of boilerplate coding involved in web applications. Wherever possible, Yesod tries to use Haskell's features to save your fingers the work:</para>
    <itemizedlist>
     <listitem>
      <para>The forms library reduces the amount of code used for common cases by leveraging the Applicative type class.</para>
     </listitem>
     <listitem>
      <para>Routes are declared in a very terse format, without sacrificing type safety.</para>
     </listitem>
     <listitem>
      <para>Serializing your data to and from a database is handled automatically via code generation.</para>
     </listitem>
    </itemizedlist>
    <para>In Yesod, we have two kinds of code generation. To get your project started, we provide a scaffolding tool to set up your file and folder structure. However, most code generation is done at compile time via meta programming. This means your generated code will never get stale, as a simple library upgrade will bring all your generated code up-to-date.</para>
    <para>But for those who like to stay in control, and know exactly what their code is doing, you can always run closer to the compiler and write all your code yourself.</para>
   </section>
   <section>
    <title>Performance</title>
    <para/>
    <para>Haskell's main compiler, the GHC, has amazing performance characteristics, and is improving all the time. This choice of language by itself gives Yesod a large performance advantage over other offerings. But that's not enough: we need an architecture designed for performance.</para>
    <para>Our approach to templates is one example: by allowing HTML, CSS and JavaScript to be
            analyzed at compile time, Yesod both avoids costly disk I/O at runtime and can optimize
            the rendering of this code. But the architectural decisions go deeper: we use advanced
            techniques such as conduits and builders in the underlying libraries to make sure our
            code runs in constant memory, without exhausting precious file handles and other
            resources. By offering high-level abstractions, you can get highly compressed and
            properly cached CSS and JavaScript.</para>
    <para>Yesod's flagship web server, Warp, is the fastest Haskell web server around. When these two pieces of technology are combined, it produces one of the fastest web application deployment solutions available.</para>
   </section>
   <section>
    <title>Modular</title>
    <para/>
    <para>Yesod has spawned the creation of dozens of packages, most of which are usable in a context outside of Yesod itself. One of the goals of the project is to contribute back to the community as much as possible; as such, even if you are not planning on using Yesod in your next project, a large portion of this book may still be relevant for your needs.</para>
    <para>Of course, these libraries have all been designed to integrate well together. Using the Yesod Framework should give you a strong feeling of consistency throughout the various APIs.</para>
   </section>
   <section>
    <title>A solid foundation</title>
    <para/>
    <para>I remember once seeing a PHP framework advertising support for UTF-8. This struck me as
            surprising: you mean having UTF-8 support isn't automatic? In the Haskell world, issues
            like character encoding are already well addressed and fully supported. In fact, we
            usually have the opposite problem: there are a number of packages providing powerful and
            well-designed support for the problem. The Haskell community is constantly pushing the
            boundaries finding the cleanest, most efficient solutions for each challenge.</para>
    <para>The downside of such a powerful ecosystem is the complexity of choice. By using Yesod, you will already have most of the tools chosen for you, and you can be guaranteed they work together. Of course, you always have the option of pulling in your own solution.</para>
    <para>As a real-life example, Yesod and Hamlet (the default templating language) use <function>blaze-builder</function> for textual content generation. This choice was made because blaze provides the fastest interface for generating UTF-8 data. Anyone who wants to use one of the other great libraries out there, such as <function>text</function>, should have no problem dropping it in.</para>
   </section>
   <section>
    <title>Introduction to Haskell</title>
    <para/>
    <para>Haskell is a powerful, fast, type-safe, functional programming language. This book takes as an assumption that you are already familiar with most of the basics of Haskell. There are two wonderful books for learning Haskell, both of which are available for reading online:</para>
    <itemizedlist>
     <listitem>
      <para>
       <link xlink:href="http://learnyouahaskell.com">Learn You a Haskell for Great Good!</link>
      </para>
     </listitem>
     <listitem>
      <para>
       <link xlink:href="http://book.realworldhaskell.org/read">Real World Haskell</link>
      </para>
     </listitem>
    </itemizedlist>
    <para>Yesod relies on a few features in Haskell that most introductory tutorials do not
            cover. Though you will rarely need to understand how these work, it's always best to
            start off with a good appreciation for what your tools are doing. These are covered in
            the next chapter.</para>
   </section>
  </chapter>
  <chapter>
   <title>Haskell</title>
   <para/>
   <para/>
   <para>In order to use Yesod, you're going to have to know at least the basics of Haskell.
   Additionally, Yesod uses some features of Haskell that aren't covered in most introductory texts.
   While this book assumes the reader has a basic familiarity with Haskell, this chapter is intended
   to fill in the gaps.</para>
   <para>If you are already fluent in Haskell, feel free to completely skip this chapter. Also, if you
   would prefer to start off by getting your feet wet with Yesod, you can always come back to this
   chapter later as a reference.</para>
   <para>If you are looking for a more thorough introduction to Haskell, I would recommend either Real
   World Haskell or Learn You a Haskell.</para>
   <section>
    <title>Terminology</title>
    <para/>
    <para>Even for those familiar with Haskell as a language, there can sometimes be some
   confusion about terminology. Let's establish some base terms that we can use throughout this
   book.</para>
    <variablelist>
     <varlistentry>
      <term>Data type</term>
      <listitem>
       <para>This is one of the core building blocks for a strongly typed language like Haskell. Some
     data types, like <literal>Int</literal>, can be treated as primitive values, while other data
     types will build on top of these to create more complicated values. For example, you might
     represent a person
     with:<programlisting language="haskell">data Person = Person Text Int</programlisting>Here, the
      <literal>Text</literal> would give the person's name, and the <literal>Int</literal> would give
     the person's age. Due to its simplicity, this specific example type will recur throughout the
     book. There are essentially three ways you can create a new data type:<itemizedlist>
         <listitem>
          <para>A <literal>type</literal> declaration such as <literal>type GearCount = Int</literal> merely
       creates a synonym for an existing type. The type system will do nothing to prevent you from
       using an <literal>Int</literal> where you asked for a <literal>GearCount</literal>. Using this
       can make your code more self-documenting.</para>
         </listitem>
         <listitem>
          <para>A <literal>newtype</literal> declaration such as <literal>newtype Make = Make Text</literal>.
       In this case, you cannot accidently use a <literal>Text</literal> in place of a
        <literal>Make</literal>; the compiler will stop you. The newtype wrapper always disappears
       during compilation, and will introduce no overhead.</para>
         </listitem>
         <listitem>
          <para>A <literal>data</literal> declaration, such as <literal>Person</literal> above. You can also
       create Algebraic Data Types (ADTs), such as <literal>data Vehicle = Bicycle GearCount | Car
        Make Model</literal>.</para>
         </listitem>
        </itemizedlist>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Data constructor</term>
      <listitem>
       <para>In our examples above, <literal>Person</literal>, <literal>Make</literal>,
      <literal>Bicycle</literal>, and <literal>Car</literal> are all data constructors.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Type constructor</term>
      <listitem>
       <para>In our examples above, <literal>Person</literal>, <literal>Make</literal>, and
      <literal>Vehicle</literal> are all type constructors.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Type variables</term>
      <listitem>
       <para>Consider the data type <literal>data Maybe a = Just a | Nothing</literal>. In this case,
      <literal>a</literal> is a type variable.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
   <section>
    <title>Tools</title>
    <para/>
    <para>There are two main tools you'll need to Haskell development. The Glasgow Haskell Compiler (GHC)
   is the standard Haskell compiler, and the only one officially supported by Yesod. You'll also
   need Cabal, which is the standard Haskell build tool. Not only do we use Cabal for building our
   local code, but it can automatically download and install dependencies from Hackage, the Haskell
   package repository.</para>
    <para>If you're on Windows or Mac, it is strongly recommended to download the <link xlink:href="http://hackage.haskell.org/platform/">Haskell
    Platform</link>. On Linux, many distributions include the Haskell Platform in their
   repositories. On Debian-based systems, for example, you can get started by running <literal>sudo
    apt-get install haskell-platform</literal>. If your distribution does not include the Haskell
   Platform, you can install it manually by following the instructions on the Haskell Platform's
   page.</para>
    <para>One important tool you'll need to update is <command>alex</command>. The Haskell Platform
   includes version 2, while the Javascript minifier Yesod uses, <function>hjsmin</function>, requires
   version three. Be sure to <command>cabal install alex</command> after getting set up with the
   Haskell Platform, or you'll run into error messages about the
    <function>language-javascript</function> package.</para>
    <note>
     <para>Some people like to live in the bleeding edge and install the latest version of GHC before
   it is available in the Haskell Platform. We try to keep Yesod up-to-date with all current
   versions of GHC, but we only officially support the Haskell Platform. If you do go the route of
   manually install GHC, here are a few notes:<itemizedlist>
       <listitem>
        <para>You'll need to install some additional build tools, <command>alex</command> and
      <command>happy</command> in particular.</para>
       </listitem>
       <listitem>
        <para>Make sure to install all of the <link xlink:href="http://www.vex.net/%7Etrebla/haskell/haskell-platform.xhtml">required C libraries</link>. On Debian-based systems, you would need to
     run:<programlisting>sudo apt-get install libedit-dev libbsd-dev libgmp3-dev zlib1g-dev freeglut3-dev</programlisting>
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </note>
    <para>Regardless of how you've installed your tools, you should sure to put <literal>cabal</literal>'s
   bin folder in your <literal>PATH</literal> variable. On Mac and Linux, this will be
    <literal>$HOME/.cabal/bin</literal> and on Windows it will be
   <literal>%APPDATA%\cabal\bin</literal>.</para>
    <para>
     <literal>cabal</literal> has lots of different options available, but for now, just try out two
   commands:</para>
    <itemizedlist>
     <listitem>
      <para>
       <command>cabal update</command> will download the most recent list of packages from
    Hackage.</para>
     </listitem>
     <listitem>
      <para>
       <command>cabal install yesod</command> will install Yesod and all its dependencies.</para>
     </listitem>
    </itemizedlist>
    <note>
     <para>Many people in the community prefer to perform sandboxed builds of their Haskell
   packages, which prevents your install Yesod from breaking existing packages, or packages you
   install in the future from breaking your Yesod install. I won't go into details on how to use
   these in the book, but the two most commonly used tools are <link xlink:href="http://hackage.haskell.org/package/cabal-dev">cabal-dev</link> and <link xlink:href="http://hackage.haskell.org/package/virthualenv">virthualenv</link>.</para>
    </note>
   </section>
   <section>
    <title>Language Pragmas</title>
    <para/>
    <para>GHC will run by default in something very close to Haskell98 mode. It also ships with a large
   number of language extensions, allowing more powerful type classes, syntax changes, and more.
   There are multiple ways to tell GHC to turn on these extensions. For most of the code snippets in
   this book, you'll see <glossterm>language pragmas</glossterm>, which look like this:</para>
    <programlisting language="haskell">{-# LANGUAGE MyLanguageExtension #-}</programlisting>
    <para>These should always appear at the top of your source file. Additionally, there are two
   other common approaches:</para>
    <itemizedlist>
     <listitem>
      <para>On the GHC command line, pass an extra argument
    <userinput>-XMyLanguageExtension</userinput>.</para>
     </listitem>
     <listitem>
      <para>In your <literal>cabal</literal> file, add an <literal>extensions</literal> block.</para>
     </listitem>
    </itemizedlist>
    <para>I personally never use the GHC command line argument approach. It's a personal preference, but
   I like to have my settings clearly stated in a file. In general it's recommended to avoid putting
   extensions in your <literal>cabal</literal> file; however, in the Yesod scaffolded site we specifically use this approach to avoid the
   boilerplate of specifying the same language pragmas in every source file.</para>
    <para>We'll end up using quite a few language extensions in this book (the scaffolding uses 11). We
   will not cover the meaning of all of them. Instead, please see the <link xlink:href="http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html">GHC documentation</link>.</para>
   </section>
   <section>
    <title>Overloaded Strings</title>
    <para/>
    <para>What's the type of <literal>"hello"</literal>? Traditionally, it's <literal>String</literal>, which
   is defined as <literal>type String = [Char]</literal>. Unfortunately, there are a number of
   limitations with this:</para>
    <itemizedlist>
     <listitem>
      <para>It's a very inefficient implementation of textual data. We need to allocate extra memory for
    each cons cell, plus the characters themselves each take up a full machine word.</para>
     </listitem>
     <listitem>
      <para>Sometimes we have string-like data that's not actually text, such as
     <literal>ByteString</literal>s and HTML.</para>
     </listitem>
    </itemizedlist>
    <para>To work around these limitations, GHC has a language extension called
    <literal>OverloadedStrings</literal>. When enabled, literal strings no longer have the monomorphic
   type <literal>String</literal>; instead, they have the type <literal>IsString a =&gt; a</literal>, where
    <literal>IsString</literal> is defined as:</para>
    <programlisting language="haskell">class IsString a where
    fromString :: String -&gt; a</programlisting>
    <para>There are <literal>IsString</literal> instances available for a number of types in Haskell, such
   as <literal>Text</literal> (a much more efficient packed <literal>String</literal> type),
    <literal>ByteString</literal>, and <literal>Html</literal>. Virtually every example in this book
   will assume that this language extension is turned on.</para>
    <para>Unfortunately, there is one drawback to this extension: it can sometimes confuse GHC's type
   checker. Imagine we have:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeSynonymInstances, FlexibleInstances #-}
import Data.Text (Text)

class DoSomething a where
    something :: a -&gt; IO ()

instance DoSomething String where
    something _ = putStrLn "String"

instance DoSomething Text where
    something _ = putStrLn "Text"

myFunc :: IO ()
myFunc = something "hello"</programlisting>
    <para>Will the program print out <literal>String</literal> or <literal>Text</literal>? It's not clear. So
   instead, you'll need to give an explicit type annotation to specify whether
    <literal>"hello"</literal> should be treated as a <literal>String</literal> or
   <literal>Text</literal>.</para>
   </section>
   <section>
    <title>Type Families</title>
    <para/>
    <para>The basic idea of a type family is to state some association between two different types.
   Suppose we want to write a function that will safely take the first element of a list. But we
   don't want it to work just on lists; we'd like it to treat a <literal>ByteString</literal> like a
   list of <literal>Word8</literal>s. To do so, we need to introduce some <glossterm>associated type</glossterm>
   to specify what the contents of a certain type are.</para>
    <programlisting language="haskell">{-# LANGUAGE TypeFamilies, OverloadedStrings #-}
import Data.Word (Word8)
import qualified Data.ByteString as S
import Data.ByteString.Char8 () -- get an orphan IsString instance

class SafeHead a where
    type Content a
    safeHead :: a -&gt; Maybe (Content a)

instance SafeHead [a] where
    type Content [a] = a
    safeHead [] = Nothing
    safeHead (x:_) = Just x

instance SafeHead S.ByteString where
    type Content S.ByteString = Word8
    safeHead bs
        | S.null bs = Nothing
        | otherwise = Just $ S.head bs

main :: IO ()
main = do
    print $ safeHead ("" :: String)
    print $ safeHead ("hello" :: String)

    print $ safeHead ("" :: S.ByteString)
    print $ safeHead ("hello" :: S.ByteString)</programlisting>
    <para>The new syntax is the ability to place a <literal>type</literal> inside of a
    <literal>class</literal> and <literal>instance</literal>. We can also use <literal>data</literal>
   instead, which will create a new datatype instead of reference an existing one.</para>
    <note>
     <para>There are other ways to use associated types outside the context of a typeclass. However, in
   Yesod, all of our associated types are in fact part of a type class. For more information on type
   families, see <link xlink:href="http://www.haskell.org/haskellwiki/GHC/Type_families">the Haskell wiki page</link>.</para>
    </note>
   </section>
   <section>
    <title>Template Haskell</title>
    <para/>
    <para>Template Haskell (TH) is an approach to <emphasis>code generation</emphasis>. We use it in Yesod in a number
   of places to reduce boilerplate, and to ensure that the generated code is correct. Template
   Haskell is essentially Haskell which generates a Haskell Abstract Syntax Tree (AST).</para>
    <note>
     <para>There's actually more power in TH than that, as it can actually introspect code. We don't
   use these facilities in Yesod, however.</para>
    </note>
    <para>Writing TH code can be tricky, and unfortunately there isn't very much type safety involved.
   You can easily write TH that will generate code that won't compile. This is only an issue for the
   developers of Yesod, not for its users. During development, we use a large collection of unit
   tests to ensure that the generated code is correct. As a user, all you need to do is call these
   already existing functions. For example, to include an externally defined Hamlet template, you
   can write:</para>
    <programlisting language="haskell">$(hamletFile "myfile.hamlet")</programlisting>
    <para>(Hamlet is discussed in the Shakespeare chapter.) The dollar sign immediately followed by parantheses
   tell GHC that what follows is a Template Haskell function. The code inside is then run by the
   compiler and generates a Haskell AST, which is then compiled. And yes, it's even possible to
    <link xlink:href="http://www.yesodweb.com/blog/2010/09/yo-dawg-template-haskell">go meta with this</link>.</para>
    <para>A nice trick is that TH code is allowed to perform arbitrary <literal>IO</literal> actions, and
   therefore we can place some input in external files and have it parsed at compile time. One
   example usage is to have compile-time checked HTML, CSS, and Javascript templates.</para>
    <para>If your Template Haskell code is being used to generate declarations, and is being placed at
   the top level of our file, we can leave off the dollar sign and parentheses. In other words:</para>
    <programlisting language="haskell">{-# LANGUAGE TemplateHaskell #-}

-- Normal function declaration, nothing special
myFunction = ...

-- Include some TH code
$(myThCode)

-- Or equivalently
myThCode</programlisting>
    <para>It can be useful to see what code is being generated by Template Haskell for you. To do so, you
   should use the <literal>-ddump-splices</literal> GHC option.</para>
    <note>
     <para>There are many other features of Template Haskell not covered here. For more information,
   see the <link xlink:href="http://www.haskell.org/haskellwiki/Template_Haskell">Haskell wiki page</link>.</para>
    </note>
   </section>
   <section>
    <title>QuasiQuotes</title>
    <para/>
    <para>QuasiQuotes (QQ) are a minor extension of Template Haskell that let us embed arbitrary content
   within our Haskell source files. For example, we mentioned previously the
    <literal>hamletFile</literal> TH function, which reads the template contents from an external
   file. We also have a quasi-quoter named <literal>hamlet</literal> that takes the content
   inline:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes #-}

[hamlet|&lt;p&gt;This is quasi-quoted Hamlet.|]</programlisting>
    <para>The syntax is set off using square brackets and pipes. The name of the quasi-quoter is given
   between the opening bracket and the first pipe, and the content is given between the pipes.</para>
    <para>Throughout the book, we will often times use the QQ-approach over a TH-powered external file
   since the former is simpler to copy-and-paste. However, in production, external files are
   recommended for all but the shortest of inputs as it gives a nice separation of the non-Haskell
   syntax from your Haskell code.</para>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>You don't need to be an expert in Haskell to use Yesod, a basic familiarity will suffice. This
   chapter hopefully gave you just enough extra information to feel more comfortable following the
   rest of the book.</para>
   </section>
  </chapter>
  <chapter>
   <title>Basics</title>
   <para/>
   <para/>
   <para>The first step with any new technology is getting it running. The goal of this chapter is
            to get you started with a simple Yesod application, and cover some of the basic concepts
            and terminology.</para>
   <section>
    <title>Hello World</title>
    <para/>
    <para>Let's get this book started properly: a simple web page that says Hello World:</para>
    <programlisting language="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data HelloWorld = HelloWorld

mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]

instance Yesod HelloWorld

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|Hello World!|]

main :: IO ()
main = warpDebug 3000 HelloWorld</programlisting>
    <para>If you save that code in <literal>helloworld.hs</literal> and run it with <literal>runhaskell helloworld.hs</literal>, you'll get a web server running on port 3000. If you point your browser to <link xlink:href="http://localhost:3000">http://localhost:3000</link>, you'll get the following HTML:</para>
    <programlisting>&lt;!DOCTYPE html&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;</programlisting>
    <para>We'll refer back to this example through the rest of the chapter.</para>
   </section>
   <section>
    <title>Routing</title>
    <para/>
    <para>Like most modern web frameworks, Yesod follows a <link xlink:href="http://en.wikipedia.org/wiki/Front_Controller_pattern">front controller pattern</link>. This means that every request to a
            Yesod application enters at the same point and is routed from there. As a contrast, in
            systems like PHP and ASP you usually create a number of different files, and the web
            server automatically directs requests to the relevant file.</para>
    <para>In addition, Yesod uses a declarative style for specifying routes. In our example above,
            this looked like:</para>
    <programlisting language="haskell">mkYesod "HelloWorld" [parseRoutes|
/ HomeR GET
|]</programlisting>
    <note>
     <para>
      <literal>mkYesod</literal> is a Template Haskell function, and
                <literal>parseRoutes</literal> is a QuasiQuoter.</para>
    </note>
    <para>In English, all this means is: <quote>In the HelloWorld application, create
                one route. I'd like to call it <literal>HomeR</literal>, it should listen for requests
                to <literal>/</literal> (the root of the application), and should answer
                    <literal>GET</literal> requests</quote>. We call <literal>HomeR</literal> a <glossterm>resource</glossterm>, which is where the "R" suffix comes from.<note>
      <para>The R suffix on resource names is simply convention, but it's a fairly universally
                followed convention. It makes it just a bit easier to read and understand
                code.</para>
     </note>
    </para>
    <para>The <literal>mkYesod</literal> TH function generates quite a bit of code here: a route data
            type, a dispatch function, and a render function. We'll look at this in more detail in
                the routing chapter. But by using the
                <literal>-ddump-splices</literal> GHC option, we can get an immediate look at the
            generated code. A much cleaned up version of it is:</para>
    <programlisting language="haskell">instance RenderRoute HelloWorld where
  data Route HelloWorld = HomeR
    deriving (Show, Eq, Read)
  renderRoute HomeR = ([], [])

instance YesodDispatch HelloWorld HelloWorld where
    yesodDispatch master sub toMaster app404 app405 method pieces =
        case dispatch pieces of
            Just f -&gt; f
                master
                sub
                toMaster
                app404
                app405
                method
            Nothing -&gt; app404
      where
        dispatch = Yesod.Routes.Dispatch.toDispatch
            [ Yesod.Routes.Dispatch.Route [] False onHome
            ]
        onHome [] = Just $ \master sub toMaster _app404 app405 method -&gt;
            case method of
                "GET" -&gt; yesodRunner
                    (fmap chooseRep getHomeR)
                    master
                    sub
                    (Just HomeR)
                    toMaster
                _ -&gt; app405 HomeR
</programlisting>
    <para>Some of that will likely not make sense yet. In particular, the implementation of
                <literal>yesodDispatch</literal> is a bit hairy to accomodate different dispatch
            approaches and fit the model necessary for our high-performance routing structures.
            However, the <literal>RenderRoute</literal> implementation with its associated data type
            should already give you a good feel for what's going on under the surface.</para>
   </section>
   <section>
    <title>Handler function</title>
    <para/>
    <para>So we have a route named <literal>HomeR</literal>, and it responds to
                <literal>GET</literal> requests. How do you define your response? You write a <glossterm>handler function</glossterm>. Yesod follows a standard naming scheme for these
            functions: it's the lower case method name (e.g., <literal>GET</literal> becomes
                <literal>get</literal>) followed by the route name. In this case, the function name
            would be <literal>getHomeR</literal>.</para>
    <para>Most of the code you write in Yesod lives in handler functions. This is where you
            process user input, perform database queries and create responses. In our simple
            example, we create a response using the <literal>defaultLayout</literal>
            function. This function wraps up the content it's given in your site's template. By
            default, it produces an HTML file with a doctype and <literal>html</literal>,
                <literal>head</literal> and <literal>body</literal> tags. As we'll
            see in the Yesod typeclass
                chapter, this function can be overridden to do much more.</para>
    <para>In our example, we pass <literal>[whamlet|Hello World!|]</literal> to
                <literal>defaultLayout</literal>. <literal>whamlet</literal> is another quasi-quoter. In
            this case, it converts Hamlet syntax into a Widget. Hamlet is the default HTML
            templating engine in Yesod. Together with its siblings Cassius, Lucius and Julius, you
            can create HTML, CSS and Javascript in a fully type-safe and compile-time-checked
            manner. We'll see much more about this in the Shakespeare chapter.</para>
    <para>Widgets are another cornerstone of Yesod. They allow you to create modular
            components of a site consisting of HTML, CSS and Javascript and reuse them throughout
            your site. We'll get into more detail on them in the widgets
            chapter.</para>
   </section>
   <section>
    <title>The Foundation</title>
    <para/>
    <para>The word "HelloWorld" shows up a number of times in our example. Every Yesod
            application has a <glossterm>foundation</glossterm> datatype. This datatype must be an instance of
                the Yesod typeclass, which provides a central place for declaring a number
            of different settings controlling the execution of our application.</para>
    <para>In our case, this datatype is pretty boring: it doesn't contain any information.
            Nonetheless, the foundation is central to how our example runs: it ties together the
            routes with the instance declaration and lets it all be run. We'll see throughout this
            book that the foundation pops up in a whole bunch of places.</para>
    <para>But foundations don't have to be boring: they can be used to store lots of useful
            information, usually stuff that needs to be initialized at program launch and used
            throughout. Some very common examples are:</para>
    <itemizedlist>
     <listitem>
      <para>A database connection pool.</para>
     </listitem>
     <listitem>
      <para>Settings loaded from a config file.</para>
     </listitem>
     <listitem>
      <para>An HTTP connection manager.</para>
     </listitem>
    </itemizedlist>
    <note>
     <para>
            By the way, the word Yesod (יסוד) means <emphasis>foundation</emphasis> in
                Hebrew.
        </para>
    </note>
   </section>
   <section>
    <title>Running</title>
    <para/>
    <para>Once again we mention <literal>HelloWorld</literal> in our main function. Our
            foundation contains all the information we need to route and respond to requests in our
            application; now we just need to convert it into something that can run. A useful
            function for this in Yesod is <literal>warpDebug</literal>, which runs the Warp webserver
            with debug output enabled on the specified port (here, it's 3000).</para>
    <para>One of the features of Yesod is that you aren't tied down to a single deployment
            strategy. Yesod is built on top of the Web Application Interface (WAI), allowing it to
            run on FastCGI, SCGI, Warp, or even as a desktop application using the Webkit library.
            We'll discuss some of these options in the deployment
            chapter. And at the end of this chapter, we will explain the development server.</para>
    <para>Warp is the premiere deployment option for Yesod. It is a lightweight, highly efficient
            web server developed specifically for hosting Yesod. It is also used outside of Yesod
            for other Haskell development (both framework and non-framework applications), as well
            as a standard file server in a number of production environments.</para>
   </section>
   <section>
    <title>Resources and type-safe URLs</title>
    <para/>
    <para>In our hello world, we defined just a single resource (<literal>HomeR</literal>). A
            web application is usually much more exciting with more than one page on it. Let's take
            a look:</para>
    <programlisting language="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses,
             TemplateHaskell, OverloadedStrings #-}
import Yesod

data Links = Links

mkYesod "Links" [parseRoutes|
/ HomeR GET
/page1 Page1R GET
/page2 Page2R GET
|]

instance Yesod Links

getHomeR  = defaultLayout [whamlet|&lt;a href=@{Page1R}&gt;Go to page 1!|]
getPage1R = defaultLayout [whamlet|&lt;a href=@{Page2R}&gt;Go to page 2!|]
getPage2R = defaultLayout [whamlet|&lt;a href=@{HomeR}&gt;Go home!|]

main = warpDebug 3000 Links</programlisting>
    <para>Overall, this is very similar to Hello World. Our foundation is now
                <literal>Links</literal> instead of <literal>HelloWorld</literal>, and in addition to
            the <literal>HomeR</literal> resource, we've added <literal>Page1R</literal> and
                <literal>Page2R</literal>. As such, we've also added two more handler functions:
                <literal>getPage1R</literal> and <literal>getPage2R</literal>.</para>
    <para>The only truly new feature is inside the <literal>whamlet</literal>
            quasi-quotation. We'll delve into syntax in the Shakespeare chapter, but we can see that:</para>
    <programlisting>&lt;a href=@{Page1R}&gt;Go to page 1!</programlisting>
    <para>creates a link to the <literal>Page1R</literal> resource. The important thing to
            note here is that <literal>Page1R</literal> is a data constructor. By making each resource
            a data constructor, we have a feature called <glossterm>type-safe URLs</glossterm>.
            Instead of splicing together strings to create URLs, we simply create a plain old
            Haskell value. By using at-sign interpolation (<literal>@{...}</literal>), Yesod
            automatically renders those values to textual URLs before sending things off to the
            user. We can see how this is implemented by looking again at the
                <command>-ddump-splices</command> output:</para>
    <programlisting language="haskell">instance RenderRoute Links where
    data Route Links = HomeR | Page1R | Page2R
      deriving (Show, Eq, Read)

    renderRoute HomeR  = ([], [])
    renderRoute Page1R = (["page1"], [])
    renderRoute Page2R = (["page2"], [])
</programlisting>
    <para>In the <literal>Route</literal> associated type for <literal>Links</literal>, we have
            additional constructors for <literal>Page1R</literal> and <literal>Page2R</literal>. We also
            now have a better glimpse of the return values for <literal>returnRoute</literal>. The
            first part of the tuple gives the <glossterm>path pieces</glossterm> for the given route. The
            second part gives the query string parameters; for almost all use cases, this will be an
            empty list.</para>
    <para>It's hard to over-estimate the value of type-safe URLs. They give you a huge
            amount of flexibility and robustness when developing your application. You can move URLs
            around at will without ever breaking links. In the routing chapter, we'll see that routes can take
            parameters, such as a blog entry URL taking the blog post ID.</para>
    <para>Let's say you want to switch from routing on the numerical post ID to a
            year/month/slug setup. In a traditional web framework, you would need to go through
            every single reference to your blog post route and update appropriately. If you miss
            one, you'll have 404s at runtime. In Yesod, all you do is update your route and compile:
            GHC will pinpoint every single line of code that needs to be corrected.</para>
   </section>
   <section>
    <title>The scaffolded site</title>
    <para/>
    <para>Installing Yesod will give you both the Yesod library, as well as a <literal>yesod</literal> executable. This executable accepts a few commands, but the first one you'll
      want to be acquainted with is <literal>yesod init</literal>. It will ask you some
      questions, and then generate a folder containing the default <glossterm>scaffolded
        site</glossterm>. Inside that folder, you can run <literal>cabal install
        --only-dependencies</literal> to build any extra dependencies (such as your database
      backends), and then <literal>yesod devel</literal> to run your site.</para>
    <para>The scaffolded site gives you a lot of best practices out of the box, setting up files and
      dependencies in a time-tested approach used by most production Yesod sites. However, all this
      convenience can get in the way of actually learning Yesod. Therefore, most of this book will
      avoid the scaffolding tool, and instead deal directly with Yesod as a library.</para>
    <para>We will cover the structure of the scaffolded site in more detail later.</para>
   </section>
   <section>
    <title>Development server</title>
    <para/>
    <para>One of the advantages interpreted languages have over compiled languages
            is fast prototyping: you save changes to a file and hit refresh. If we want to make any
            changes to our Yesod apps above, we'll need to call <command>runhaskell</command> from
            scratch, which can be a bit tedious.</para>
    <para>Fortunately, there's a solution to this: <literal>yesod
                devel</literal> automatically rebuilds and reloads your code for you. This can be a
            great way to develop your Yesod projects, and when you're ready to move to production,
            you still get to compile down to incredibly efficient code. The Yesod scaffolding
            automatically sets things up for you. This gives you the best of both worlds: rapid
            prototyping <emphasis role="bold">and</emphasis> fast production code.</para>
    <para>It's a little bit more involved to set up your code to be used by
                <command>yesod devel</command>, so our examples will just use
                <literal>warpDebug</literal>. But when you're ready to make your real-world
            applications, <command>yesod devel</command> will be waiting for you.</para>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>Every Yesod application is built around a foundation datatype. We associate some
            resources with that datatype and define some handler functions, and Yesod handles all of
            the routing. These resources are also data constructors, which lets us have type-safe
            URLs.</para>
    <para>By being built on top of WAI, Yesod applications can run with a number of different
            backends. <literal>warpDebug</literal> is an easy way to get started, as it's included
            with Yesod. For rapid development, you can use <literal>yesod devel</literal> is a good
            choice. And when you're ready to move to production, you have Warp as a high-performance
            option.</para>
    <para>When developing in Yesod, we get a number of choices for coding style:
            quasi-quotation or external files, <literal>warpDebug</literal> or <literal>yesod
                devel</literal>, and so on. The examples in this book will tend towards using the
            choices that are easiest to copy-and-paste, but the more powerful options will be
            available when you start building real Yesod applications.</para>
   </section>
  </chapter>
  <chapter>
   <title>Shakespearean Templates</title>
   <para/>
   <para/>
   <para>Yesod uses the Shakespearean family of template languages as its standard approach to HTML, CSS
   and Javascript creation. This language family shares some common syntax, as well as overarching
    principles:<itemizedlist>
     <listitem>
      <para>As little interference to the underlying language as possible, while providing
     conveniences where unobtrusive.</para>
     </listitem>
     <listitem>
      <para>Compile-time guarantees on well-formed content.</para>
     </listitem>
     <listitem>
      <para>Static type safety, greatly helping the prevention of <link xlink:href="http://en.wikipedia.org/wiki/Cross-site_scripting">XSS
      (cross-site scripting)</link> attacks.</para>
     </listitem>
     <listitem>
      <para>Automated checking of valid URLs, whenever possible, through <glossterm>type-safe
     URLs</glossterm>.</para>
     </listitem>
    </itemizedlist>
   </para>
   <para>There is nothing inherently tying Yesod to these languages, or the other way around:
   each can be used independently of the other. This chapter will address these template languages
   on their own, while the remainder of the book will use them to enhance Yesod application
   development.</para>
   <section>
    <title>Synopsis</title>
    <para/>
    <para>There are four main languages at play: Hamlet is an HTML templating language, Julius is
            for Javascript, and Cassius and Lucius are both for CSS. Hamlet and Cassius are both
            whitespace-sensitive formats, using indentation to denote nesting. By contrast, Lucius
            is a superset of CSS, keeping CSS's braces for denoting nesting. Julius is a simple
            passthrough language for producing Javascript; the only added feature is variable
            interpolation.</para>
    <section>
     <title>Hamlet (HTML)</title>
     <para/>
     <programlisting>$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle} - My Site
        &lt;link rel=stylesheet href=@{Stylesheet}&gt;
    &lt;body&gt;
        &lt;h1 .page-title&gt;#{pageTitle}
        &lt;p&gt;Here is a list of your friends:
        $if null friends
            &lt;p&gt;Sorry, I lied, you don't have any friends.
        $else
            &lt;ul&gt;
                $forall Friend name age &lt;- friends
                    &lt;li&gt;#{name} (#{age} years old)
        &lt;footer&gt;^{copyright}</programlisting>
    </section>
    <section>
     <title>Cassius (CSS)</title>
     <para/>
     <programlisting>#myid
    color: #{red}
    font-size: #{bodyFontSize}
foo bar baz
    background-image: url(@{MyBackgroundR})</programlisting>
    </section>
    <section>
     <title>Lucius (CSS)</title>
     <para/>
     <programlisting>section.blog {
    padding: 1em;
    border: 1px solid #000;
    h1 {
        color: #{headingColor};
    }
}</programlisting>
    </section>
    <section>
     <title>Julius (Javascript)</title>
     <para/>
     <programlisting>$(function(){
    $("section.#{sectionClass}").hide();
    $("#mybutton").click(function(){document.location = "@{SomeRouteR}";});
    ^{addBling}
});</programlisting>
    </section>
   </section>
   <section>
    <title>Types</title>
    <para/>
    <para>Before we jump into syntax, let's take a look at the various types involved. We
   mentioned in the introduction that types help protect us from XSS attacks. For example, let's say
   that we have an HTML template that should display someone's name; it might look like
    this:<programlisting>&lt;p&gt;Hello, my name is #{name}</programlisting>
     <note>
      <para>
       <literal>#{...}</literal> is how we do variable interpolation in
    Shakespeare.</para>
     </note>
    </para>
    <para>What should happen to <varname>name</varname>, and what should its datatype be?
   A naive approach would be to use a <literal>Text</literal> value, and insert it verbatim. But that
   would give us quite a problem when <literal>name="&lt;script
    src='http://nefarious.com/evil.js'&gt;&lt;/script&gt;"</literal>. What we want is to be able to
   entity-encode the name, so that <literal>&lt;</literal> becomes <literal>&amp;lt;</literal>.</para>
    <para>An equally naive approach is to simply entity-encode <emphasis role="bold">every</emphasis> piece of text
   that gets embedded. What happens when you have some preexisting HTML generated from another
   process? For example, on the Yesod website, all Haskell code snippets are run through a
   colorizing function that wraps up words in appropriate <literal>span</literal> tags. If we
   entity escaped everything, code snippets would be completely unreadable!</para>
    <para>Instead, we have an <literal>Html</literal> datatype. In order to generate an
    <literal>Html</literal> value, we have two options for APIs: the <literal>ToHtml</literal> typeclass
   provides a way to convert <literal>String</literal> and <literal>Text</literal> values into
    <literal>Html</literal>, via its <literal>toHtml</literal> function, automatically escaping entities
   along the way. This would be the approach we'd want for the name above. For the code snippet
   example, we would use the preEscaped family of functions.</para>
    <para>When you use variable interpolation in Hamlet (the HTML Shakespeare language), it
   automatically applies a <literal>toHtml</literal> call to the value inside. So if you interpolate a
    <literal>String</literal>, it will be entity-escaped. But if you provide an <literal>Html</literal>
   value, it will appear unmodified. In the code snippet example, we might interpolate with
   something like <literal>#{preEscapedText myHaskellHtml}</literal>.</para>
    <note>
     <para>The <literal>Html</literal> datatype, as well as the functions mentioned, are all
   provided by the <function>blaze-html</function> package. This allows Hamlet to interact
   with all other blaze-html packages, and lets Hamlet provide a general solution for producing
   blaze-html values. Also, we get to take advantage of blaze-html's amazing performance.</para>
    </note>
    <para>Similarly, we have <literal>Css</literal>/<literal>ToCss</literal>, as
   well as <literal>Javascript</literal>/<literal>ToJavascript</literal>. These
   provide some compile-time sanity checks that we haven't accidently stuck some HTML in our
   CSS.</para>
    <note>
     <para>One other advantage on the CSS side is some helper datatypes for colors and units.
   For example:<programlisting>.red { color: #{colorRed} }</programlisting>Please see the
   Haddock documentation for more details.</para>
    </note>
    <section>
     <title>Type-safe URLs</title>
     <para/>
     <para>Possibly the most unique feature in Yesod is type-safe URLs, and the ability to use
   them conveniently is provided directly by Shakespeare. Usage is nearly identical to variable
   interpolation, we just use the at-sign (@) instead of the hash (#). We'll cover the syntax later;
   first, let's clarify the intuition.</para>
     <para>Suppose we have an application with two routes: <filename>http://example.com/profile/home</filename> is the homepage, and <filename>http://example.com/display/time</filename> displays the current time. And let's say we want to
   link from the homepage to the time. I can think of three different ways of constructing the
    URL:<orderedlist>
       <listitem>
        <para>As a relative link: <filename>../display/time</filename>
        </para>
       </listitem>
       <listitem>
        <para>As an absolute link, without a domain: <filename>/display/time</filename>
        </para>
       </listitem>
       <listitem>
        <para>As an absolute link, with a domain: <filename>http://example.com/display/time</filename>
        </para>
       </listitem>
      </orderedlist>
     </para>
     <para>There are problems with each approach: the first will break if either URL changes. Also, it's
   not suitable for all use cases; RSS and Atom feeds, for instance, require absolute URLs. The
   second is more resilient to change than the first, but still won't be acceptable for RSS and
   Atom. And while the third works fine for all use cases, you'll need to update every single URL in
   your application whenever your domain name changes. You think that doesn't happen often? Just
   wait till you move from your development to staging and finally production server.</para>
     <para>But more importantly, there is one huge problem with all approaches: if you change your routes
   at all, the compiler won't warn you about the broken links. Not to mention that typos can wreak
   havoc as well.</para>
     <para>The goal of type-safe URLs is to let the compiler check things for us as much as
   possible. In order to facilitate this, our first step must be to move away from plain old text,
   which the compiler doesn't understand, to some well defined datatypes. For our simple
   application, let's model our routes with a sum
   type:<programlisting language="haskell">data MyRoute = Home | Time</programlisting>
     </para>
     <para>Instead of placing a link like /display/time in our template, we can use the
    <literal>Time</literal> constructor. But at the end of the day, HTML is made up of text, not data
   types, so we need some way to convert these values to text. We call this a <glossterm>URL
    rendering function</glossterm>, and a simple one
   is:<programlisting language="haskell">renderMyRoute :: MyRoute -&gt; Text
renderMyRoute Home = "http://example.com/profile/home"
renderMyRoute Time = "http://example.com/display/time"</programlisting>
     </para>
     <para>
      <note>
       <para>URL rendering functions are actually a bit more complicated than this. They need to address
    query string parameters, handle records within the constructor, and more intelligently handle
    the domain name. But in practice, you don't need to worry about this, since Yesod will
    automatically create your render functions. The one thing to point out is that the type
    signature is actually a little more complicated to handle query
    strings:<programlisting language="haskell">type Query = [(Text, Text)]
type Render url = url -&gt; Query -&gt; Text
renderMyRoute :: Render MyRoute
renderMyRoute Home _ = ...
renderMyRoute Time _ = ...</programlisting>
       </para>
      </note>
     </para>
     <para>OK, we have our render function, and we have type-safe URLs embedded in the templates.
   How does this fit together exactly? Instead of generating an <literal>Html</literal> (or
    <literal>Css</literal> or <literal>Javascript</literal>) value directly, Shakespearean templates
   actually produce a function, which takes this render function and produces HTML. To see this
   better, let's have a quick (fake) peek at how Hamlet would work under the surface. Supposing we
   had a
   template:<programlisting>&lt;a href=@{Time}&gt;The time</programlisting>this
   would translate roughly into the Haskell
   code:<programlisting language="haskell">\render -&gt; mconcat ["&lt;a href='", render Time, "'&gt;The time&lt;/a&gt;"]</programlisting>
     </para>
    </section>
   </section>
   <section>
    <title>Syntax</title>
    <para/>
    <para>All Shakespearean languages share the same interpolation syntax, and are able to
            utilize type-safe URLs. They differ in the syntax specific for their target language
            (HTML, CSS, or Javascript).</para>
    <section>
     <title>Hamlet Syntax</title>
     <para/>
     <para>Hamlet is the most sophisticated of the languages. Not only does it provide
            syntax for generating HTML, it also allows for basic control structures: conditionals,
            looping, and maybes.</para>
     <section>
      <title>Tags</title>
      <para/>
      <para>Obviously tags will play an important part of any HTML template language. In Hamlet, we try to
   stick very close to existing HTML syntax to make the language more comfortable. However, instead
   of using closing tags to denote nesting, we use indentation. So something like this in
   HTML:<programlisting>&lt;body&gt;
&lt;p&gt;Some paragraph.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item 1&lt;/li&gt;
&lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/body&gt;</programlisting>would
   be<programlisting>&lt;body&gt;
    &lt;p&gt;Some paragraph.
    &lt;ul&gt;
        &lt;li&gt;Item 1
        &lt;li&gt;Item 2</programlisting>
      </para>
      <para>In general, we find this to be easier to follow than HTML once you get accustomed to it. The
   only tricky part comes with dealing with whitespace before and after tags. For example, let's say
   you want to create the
   HTML<programlisting>&lt;p&gt;Paragraph &lt;i&gt;italic&lt;/i&gt; end.&lt;/p&gt;</programlisting>We want to make sure
   that there is a whitespace preserved after the word "Paragraph" and before the word "end". To do
   so, we use two simple escape
   characters:<programlisting>&lt;p&gt;
    Paragraph #
    &lt;i&gt;italic
    \ end.</programlisting>The
   whitespace escape rules are actually very simple:<orderedlist>
        <listitem>
         <para>If the first non-space character in a line is a backslash, the backslash is ignored.</para>
        </listitem>
        <listitem>
         <para>If the last character in a line is a hash, it is ignored.</para>
        </listitem>
       </orderedlist>
      </para>
      <para>One other thing. Hamlet does <emphasis role="bold">not</emphasis> escape entities within its content.
   This is done on purpose to allow existing HTML to be more easily copied in. So the example above
   could also be written
   as:<programlisting>&lt;p&gt;Paragraph &lt;i&gt;italic&lt;/i&gt; end.</programlisting>Notice
   that the first tag will be automatically closed by Hamlet, while the inner "i" tag will not. You
   are free to use whichever approach you want, there is no penalty for either choice. Be aware,
   however, that the <emphasis role="bold">only</emphasis> time you use closing tags in Hamlet is for such inline tags; normal
   tags are not closed.</para>
     </section>
     <section>
      <title>Interpolation</title>
      <para/>
      <para>What we have so far is a nice, simplified HTML, but it doesn't let us interact with our Haskell
   code at all. How do we pass in variables? Simple: with
   interpolation:<programlisting>&lt;head&gt;
    &lt;title&gt;#{title}</programlisting>The hash followed by a pair
   of braces denotes <emphasis role="bold">variable interpolation</emphasis>. In the case above, the <literal>title</literal>
   variable from the scope in which the template was called will be used. Let me state that again:
   Hamlet automatically has access to the variables in scope when it's called. There is no need to
   specifically pass variables in.</para>
      <para>You can apply functions within an interpolation. You can use string and numeric
   literals in an interpolation. You can use qualified modules. Both parentheses and the dollar sign
   can be used to group statements together. And at the end, the <literal>toHtml</literal>
   function is applied to the result, meaning <emphasis>any</emphasis> instance of <literal>ToHtml</literal> can be interpolated. Take, for instance, the following code.</para>
      <programlisting language="haskell">-- Just ignore the quasiquote stuff for now, and that shamlet thing.
-- It will be explained later.
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (shamlet)
import Text.Blaze.Renderer.String (renderHtml)
import Data.Char (toLower)
import Data.List (sort)

data Person = Person
    { name :: String
    , age  :: Int
    }

main :: IO ()
main = putStrLn $ renderHtml [shamlet|
&lt;p&gt;Hello, my name is #{name person} and I am #{show $ age person}.
&lt;p&gt;
    Let's do some funny stuff with my name: #
    &lt;b&gt;#{sort $ map toLower (name person)}
&lt;p&gt;Oh, and in 5 years I'll be #{show ((+) 5 (age person))} years old.
|]
  where
    person = Person "Michael" 26</programlisting>
      <para>What about our much-touted type-safe URLs? They are almost identical to variable
   interpolation in every way, except they start with an at-sign (@) instead. In addition, there is
   embedding via a caret (^) which allows you to embed another template of the same type. The next
   code sample demonstrates both of these.</para>
      <programlisting language="haskell">{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Text.Blaze.Renderer.String (renderHtml)
import Data.Text (Text)

data MyRoute = Home

render :: MyRoute -&gt; [(Text, Text)] -&gt; Text
render Home _ = "/home"

footer :: HtmlUrl MyRoute
footer = [hamlet|
&lt;footer&gt;
    Return to #
    &lt;a href=@{Home}&gt;Homepage
    .
|]

main :: IO ()
main = putStrLn $ renderHtml $ [hamlet|
&lt;body&gt;
    &lt;p&gt;This is my page.
    ^{footer}
|] render</programlisting>
     </section>
     <section>
      <title>Attributes</title>
      <para/>
      <para>In that last example, we put an href attribute on the "a" tag. Let's elaborate on the
    syntax:<itemizedlist>
        <listitem>
         <para>You can have interpolations within the attribute value.</para>
        </listitem>
        <listitem>
         <para>The equals sign and value for an attribute are optional, just like in HTML. So
      <literal>&lt;input type=checkbox checked&gt;</literal> is perfectly valid.</para>
        </listitem>
        <listitem>
         <para>There are two convenience attributes: for id, you can use the hash, and for classes,
     the period. In other words, <literal>&lt;p #paragraphid .class1
     .class2&gt;</literal>.</para>
        </listitem>
        <listitem>
         <para>While quotes around the attribute value are optional, they are required if you want
     to embed spaces.</para>
        </listitem>
        <listitem>
         <para>You can add an attribute optionally by using colons. To make a checkbox only checked
     if the variable isChecked is True, you would write <literal>&lt;input type=checkbox
      :isChecked:checked&gt;</literal>. To have a paragraph be optionally red, you could use <literal>&lt;p :isRed:style="color:red"&gt;</literal>.</para>
        </listitem>
       </itemizedlist>
      </para>
     </section>
     <section>
      <title>Conditionals</title>
      <para/>
      <para>Eventually, you'll want to put in some logic in your page. The goal of Hamlet is to
            make the logic as minimalistic as possible, pushing the heavy lifting into Haskell. As
            such, our logical statements are very basic... so basic, that it's <literal>if</literal>,
                <literal>elseif</literal>, and
            <literal>else</literal>.<programlisting>$if isAdmin
    &lt;p&gt;Welcome to the admin section.
$elseif isLoggedIn
    &lt;p&gt;You are not the administrator.
$else
    &lt;p&gt;I don't know who you are. Please log in so I can decide if you get access.</programlisting>All
            the same rules of normal interpolation apply to the content of the conditionals.</para>
     </section>
     <section>
      <title>Maybe</title>
      <para/>
      <para>Similarly, we have a special construct for dealing with Maybe values. This could
   technically be dealt with using <literal>if</literal>, <literal>isJust</literal> and
    <literal>fromJust</literal>, but this is more convenient and avoids partial
   functions.<programlisting>$maybe name &lt;- maybeName
    &lt;p&gt;Your name is #{name}
$nothing
    &lt;p&gt;I don't know your name.</programlisting>In
   addition to simple identifiers, you can use a few other, more complicated values on the left hand
   side, such as constructors and tuples.</para>
      <programlisting>$maybe Person firstName lastName &lt;- maybePerson
    &lt;p&gt;Your name is #{firstName} #{lastName}</programlisting>
      <para>The right-hand-side follows the same rules as interpolations, allow variables, function
   application, and so on.</para>
     </section>
     <section>
      <title>Forall</title>
      <para/>
      <para>And what about looping over lists? We have you covered there
   too:<programlisting>$if null people
    &lt;p&gt;No people.
$else
    &lt;ul&gt;
        $forall person &lt;- people
            &lt;li&gt;#{person}</programlisting>
      </para>
     </section>
     <section>
      <title>Case</title>
      <para/>
      <para>Pattern matching is one of the great strengths of Haskell. Sum types let you cleanly model many
   real-world types, and <literal>case</literal> statements let you safely match, letting the compiler
   warn you if you missed a case. Hamlet gives you the same power.</para>
      <programlisting>$case foo
    $of Left bar
        &lt;p&gt;It was left: #{bar}
    $of Right baz
        &lt;p&gt;It was right: #{baz}</programlisting>
     </section>
     <section>
      <title>With</title>
      <para/>
      <para>Rounding out our statements, we have <literal>with</literal>. It's basically just a
            convenience for declaring a synonym for a long
            expression.<programlisting>$with foo &lt;- some very (long ugly) expression that $ should only $ happen once
    &lt;p&gt;But I'm going to use #{foo} multiple times. #{foo}</programlisting>
      </para>
     </section>
     <section>
      <title>Doctype</title>
      <para/>
      <para>Last bit of syntactic sugar: the doctype statement. We have support for a number of
            different versions of a <literal>doctype</literal>, though we recommend <literal>$doctype
                5</literal> for modern web applications, which generates <literal>&lt;!DOCTYPE
                html&gt;</literal>.<programlisting>$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Hamlet is Awesome
    &lt;body&gt;
        &lt;p&gt;All done.</programlisting>
       <note>
        <para>There
                is an older and still supported syntax: three exclamation points
                    (<literal>!!!</literal>). You may still see this in code out there. We have no
                plans to remove support for this, but in general find the <literal>$doctype</literal>
                approach easier to read.</para>
       </note>
      </para>
     </section>
    </section>
    <section>
     <title>Cassius Syntax</title>
     <para/>
     <para>Cassius is the original CSS template language. It uses simple whitespace rules to delimit
   blocks, making braces and semicolons unnecessary. It supports both variable and URL
   interpolation, but not embedding. The syntax is very
   straight-forward:<programlisting>#banner
    border: 1px solid #{bannerColor}
    background-image: url(@{BannerImageR})</programlisting>
     </para>
    </section>
    <section>
     <title>Lucius Syntax</title>
     <para/>
     <para>While Cassius uses a modified, whitespace-sensitive syntax for CSS, Lucius is true to
   the original. You can take any CSS file out there and it will be a valid Lucius file. There are,
   however, a few additions to Lucius:<itemizedlist>
       <listitem>
        <para>Like Cassius, we allow both variable and URL interpolation.</para>
       </listitem>
       <listitem>
        <para>CSS blocks are allowed to nest.</para>
       </listitem>
       <listitem>
        <para>You can declare variables in your templates.</para>
       </listitem>
      </itemizedlist>
     </para>
     <para>Starting the with second point: let's say you want to have some special styling for
   some tags within your <literal>article</literal>. In plain ol' CSS, you'd have to
   write:<programlisting>article code { background-color: grey; }
article p { text-indent: 2em; }
article a { text-decoration: none; }</programlisting>In
   this case, there aren't that many clauses, but having to type out article each time is still a
   bit of a nuisance. Imagine if you had a dozen or so of these. Not the worst thing in the world,
   but a bit of an annoyance. Lucius helps you out
   here:<programlisting>article {
    code { background-color: grey; }
    p { text-indent: 2em; }
    a { text-decoration: none; }
}</programlisting>
     </para>
     <para>Having Lucius variables allows you to avoid repeating yourself. A simple example would be to
   define a commonly used color:</para>
     <programlisting>@textcolor: #ccc; /* just because we hate our users */
body { color: #{textcolor} }
a:link, a:visited { color: #{textcolor} }</programlisting>
     <para>Other than that, Lucius is identical to CSS.</para>
    </section>
    <section>
     <title>Julius Syntax</title>
     <para/>
     <para>Julius is the simplest of the languages discussed here. In fact, some might even say
   it's really just Javascript. Julius allows the three forms of interpolation we've mentioned so
   far, and otherwise applies no transformations to your content.<note>
       <para>If you use Julius
    with the scaffolded Yesod site, you may notice that your Javascript is automatically minified.
    This is not a feature of Julius; instead, Yesod uses the <function>hjsmin</function>
    package to minify Julius output.</para>
      </note>
     </para>
    </section>
   </section>
   <section>
    <title>Calling Shakespeare</title>
    <para/>
    <para>The question of course arises at some point: how do I actually use this stuff? There are three
   different ways to call out to Shakespeare from your Haskell code:</para>
    <variablelist>
     <varlistentry>
      <term>Quasiquotes</term>
      <listitem>
       <para>Quasiquotes allow you to embed arbitrary content within your Haskell, and for it to be
     converted into Haskell code at compile time.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>External file</term>
      <listitem>
       <para>In this case, the template code is in a separate file which is referenced via Template
     Haskell.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Reload mode</term>
      <listitem>
       <para>Both of the above modes require a full recompile to see any changes. In reload
     mode, your template is kept in a separate file and referenced via Template Haskell. But at
     runtime, the external file is reparsed from scratch each time.<note>
         <para>Reload mode is not
      available for Hamlet, only for Cassius, Lucius and Julius. There are too many sophisticated
      features in Hamlet that rely directly on the Haskell compiler and could not feasible be
      reimplemented at runtime.</para>
        </note>
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>One of the first two approaches should be used in production. They both embed the entirety of
   the template in the final executable, simplifying deployment and increasing performance. The
   advantage of the quasiquoter is the simplicity: everything stays in a single file. For short
   templates, this can be a very good fit. However, in general, the external file approach is
   recommended because:<itemizedlist>
      <listitem>
       <para>It follows nicely in the tradition of separate logic from presentation.</para>
      </listitem>
      <listitem>
       <para>You can easily switch between external file and debug mode with some simple CPP macros,
     meaning you can keep rapid development and still achieve high performance in production.</para>
      </listitem>
     </itemizedlist>
    </para>
    <para>Since these are special QuasiQuoters and Template Haskell functions, you need to be
   sure to enable the appropriate language extensions and use correct syntax. You can see a simple
   example of each in the figures.</para>
    <figure xml:id="calling-shakespeare-x17">
     <title>Quasiquoter</title>
     <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE QuasiQuotes #-}
import Text.Hamlet (HtmlUrl, hamlet)
import Data.Text (Text)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -&gt; [(Text, Text)] -&gt; Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: Text -&gt; HtmlUrl MyRoute
template title = [hamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{title}
        &lt;link rel=stylesheet href=@{Stylesheet}&gt;
    &lt;body&gt;
        &lt;h1&gt;#{title}
|]

main :: IO ()
main = putStrLn $ renderHtml $ template "My Title" render</programlisting>
    </figure>
    <figure xml:id="calling-shakespeare-x20">
     <title>External file</title>
     <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-} -- we're using Text below
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE CPP #-} -- to control production versus debug
import Text.Lucius (CssUrl, luciusFile, luciusFileDebug, renderCss)
import Data.Text (Text)
import qualified Data.Text.Lazy.IO as TLIO

data MyRoute = Home | Time | Stylesheet

render :: MyRoute -&gt; [(Text, Text)] -&gt; Text
render Home _ = "/home"
render Time _ = "/time"
render Stylesheet _ = "/style.css"

template :: CssUrl MyRoute
#if PRODUCTION
template = $(luciusFile "template.lucius")
#else
template = $(luciusFileDebug "template.lucius")
#endif

main :: IO ()
main = TLIO.putStrLn $ renderCss $ template render</programlisting>
     <programlisting>-- @template.lucius
foo { bar: baz }</programlisting>
    </figure>
    <para>The naming scheme for the functions is very consistent.</para>
    <table>
     <title/>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Language</entry>
        <entry>Quasiquoter</entry>
        <entry>External file</entry>
        <entry>Reload</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>Hamlet</entry>
        <entry>
         <function>hamlet</function>
        </entry>
        <entry>
         <literal>hamletFile</literal>
        </entry>
        <entry>
         <emphasis>N/A</emphasis>
        </entry>
       </row>
       <row>
        <entry>Cassius</entry>
        <entry>
         <literal>cassius</literal>
        </entry>
        <entry>
         <literal>cassiusFile</literal>
        </entry>
        <entry>
         <literal>cassiusFileReload</literal>
        </entry>
       </row>
       <row>
        <entry>Lucius</entry>
        <entry>
         <literal>lucius</literal>
        </entry>
        <entry>
         <literal>luciusFile</literal>
        </entry>
        <entry>
         <literal>luciusFileReload</literal>
        </entry>
       </row>
       <row>
        <entry>Julius</entry>
        <entry>
         <literal>julius</literal>
        </entry>
        <entry>
         <literal>juliusFile</literal>
        </entry>
        <entry>
         <literal>juliusFileReload</literal>
        </entry>
       </row>
      </tbody>
     </tgroup>
    </table>
    <section>
     <title>Alternate Hamlet Types</title>
     <para/>
     <para>So far, we've seen how to generate an <literal>HtmlUrl</literal> value from Hamlet, which is a
   piece of HTML with embedded type-safe URLs. There are currently three other values we can
   generate using Hamlet: plain HTML, HTML with URLs <emphasis role="bold">and</emphasis> internationalized messages, and
   widgets. That last one will be covered in the widgets chapter.</para>
     <para>To generate plain HTML without any embedded URLs, we use "simplified Hamlet". There are a few
    changes:<itemizedlist>
       <listitem>
        <para>We use a different set of functions, prefixed with an "s". So the quasiquoter is
      <literal>shamlet</literal> and the external file function is <literal>shamletFile</literal>. How
     we pronounce those is still up for debate.</para>
       </listitem>
       <listitem>
        <para>No URL interpolation is allowed. Doing so will result in a compile-time error.</para>
       </listitem>
       <listitem>
        <para>Embedding (the caret-interpolator) no longer allows arbitrary <literal>HtmlUrl</literal> values. The rule is that the embedded value must have the same type as the
     template itself, so in this case it must be <literal>Html</literal>. That means that for
      <literal>shamlet</literal>, embedding can be completely replaced with normal variable
     interpolation (with a hash).</para>
       </listitem>
      </itemizedlist>
     </para>
     <para>Dealing with internationalization (i18n) in Hamlet is a bit complicated. Hamlet
   supports i18n via a message datatype, very similar in concept and implementation to a type-safe
   URL. As a motivating example, let's say we want to have an application that tells you hello and
   how many apples you have eaten. We could represent those messages with a
   datatype.<programlisting language="haskell">data Msg = Hello | Apples Int</programlisting>Next,
   we would want to be able to convert that into something human-readable, so we define some render
   functions:<programlisting language="haskell">renderEnglish :: Msg -&gt; Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought ", T.pack $ show i, " apples."]</programlisting>Now
   we want to interpolate those Msg values directly in the template. For that, we use underscore
   interpolation.<programlisting>$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;i18n
    &lt;body&gt;
        &lt;h1&gt;_{Hello}
        &lt;p&gt;_{Apples count}</programlisting>
     </para>
     <para>This kind of a template now needs some way to turn those values into HTML. So just
   like type-safe URLs, we pass in a render function. To represent this, we define a new type
   synonym:<programlisting language="haskell">type Render url = url -&gt; [(Text, Text)] -&gt; Text
type Translate msg = msg -&gt; Html
type HtmlUrlI18n msg url = Translate msg -&gt; Render url -&gt; Html</programlisting>At
   this point, you can pass <literal>renderEnglish</literal>, <literal>renderSpanish</literal>, or <literal>renderKlingon</literal> to this template, and it
   will generate nicely translated output (depending, of course, on the quality of your
   translators). The complete program is:</para>
     <programlisting language="haskell">{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Data.Text (Text)
import qualified Data.Text as T
import Text.Hamlet (HtmlUrlI18n, ihamlet)
import Text.Blaze (toHtml)
import Text.Blaze.Renderer.String (renderHtml)

data MyRoute = Home | Time | Stylesheet

renderUrl :: MyRoute -&gt; [(Text, Text)] -&gt; Text
renderUrl Home _ = "/home"
renderUrl Time _ = "/time"
renderUrl Stylesheet _ = "/style.css"

data Msg = Hello | Apples Int

renderEnglish :: Msg -&gt; Text
renderEnglish Hello = "Hello"
renderEnglish (Apples 0) = "You did not buy any apples."
renderEnglish (Apples 1) = "You bought 1 apple."
renderEnglish (Apples i) = T.concat ["You bought ", T.pack $ show i, " apples."]

template :: Int -&gt; HtmlUrlI18n Msg MyRoute
template count = [ihamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;i18n
    &lt;body&gt;
        &lt;h1&gt;_{Hello}
        &lt;p&gt;_{Apples count}
|]

main :: IO ()
main = putStrLn $ renderHtml
     $ (template 5) (toHtml . renderEnglish) renderUrl</programlisting>
    </section>
   </section>
   <section>
    <title>Other Shakespeare</title>
    <para/>
    <para>In addition to HTML, CSS and Javascript helpers, there is also some more general-purpose
   Shakespeare available. <function>shakespeare-text</function> provides a simple way to create
   interpolated strings, much like people are accustomed to in scripting languages like Ruby and
   Python. This package's utility is definitely not limited to Yesod.</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, OverloadedStrings #-}
import Text.Shakespeare.Text
import qualified Data.Text.Lazy.IO as TLIO
import Data.Text (Text)
import Control.Monad (forM_)

data Item = Item
    { itemName :: Text
    , itemQty :: Int
    }

items :: [Item]
items =
    [ Item "apples" 5
    , Item "bananas" 10
    ]

main :: IO ()
main = forM_ items $ \item -&gt; TLIO.putStrLn
    [lt|You have #{show $ itemQty item} #{itemName item}.|]</programlisting>
    <para>Some quick points about this simple example:</para>
    <itemizedlist>
     <listitem>
      <para>Notice that we have three different textual datatypes involved
     (<literal>String</literal>, strict <literal>Text</literal> and lazy <literal>Text</literal>). They
    all play together well.</para>
     </listitem>
     <listitem>
      <para>We use a quasiquoter named <literal>lt</literal>, which generates lazy text. There is also
     <literal>st</literal>.</para>
     </listitem>
     <listitem>
      <para>Also, there are longer names for these quasiquoters (<literal>ltext</literal> and
     <literal>stext</literal>).</para>
     </listitem>
    </itemizedlist>
   </section>
   <section>
    <title>General Recommendations</title>
    <para/>
    <para>Here are some general hints from the Yesod community on how to get the most out of
                                                  Shakespeare.</para>
    <itemizedlist>
     <listitem>
      <para>For actual sites, use external files. For libraries, it's OK to use quasiquoters, assuming they aren't too long.</para>
     </listitem>
     <listitem>
      <para>Patrick Brisbin has put together a <link xlink:href="https://github.com/pbrisbin/html-template-syntax">Vim code
                    highlighter</link> that can help out immensely.</para>
     </listitem>
     <listitem>
      <para>You should almost always start Hamlet tags on their own line instead of embedding
                                                  start/end tags after an existing tag. The only
                                                  exception to this is the occasional
                                                  <literal>&lt;i&gt;</literal> or
                                                  <literal>&lt;b&gt;</literal> tag inside a large
                                                  block of text.</para>
     </listitem>
    </itemizedlist>
   </section>
  </chapter>
  <chapter>
   <title>Widgets</title>
   <para/>
   <para/>
   <para>One of the challenges in web development is that we have to coordinate three different client-side technologies: HTML, CSS and Javascript. Worse still, we have to place these components in different locations on the page: CSS in a style tag in the head, Javascript in a script tag in the head, and HTML in the body. And never mind if you want to put your CSS and Javascript in separate files!</para>
   <para>In practice, this works out fairly nicely when building a single page, because we can
            separate our structure (HTML), style (CSS) and logic (Javascript). But when we want to
            build modular pieces of code that can be easily composed, it can be a headache to
            coordinate all three pieces separately. Widgets are Yesod's solution to the problem.
            They also help with the issue of including libraries, such as jQuery, one time only.</para>
   <para>Our four template languages- Hamlet, Cassius, Lucius and Julius- provide the raw tools for constructing your output. Widgets provide the glue that allows them to work together seamlessly.</para>
   <section>
    <title>Synopsis</title>
    <para/>
    <programlisting language="haskell">getRootR = defaultLayout $ do
    setTitle "My Page Title"
    toWidget [lucius| h1 { color: green; } |]
    addScriptRemote "https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"
    toWidget [julius|
$(function() {
    $("h1").click(function(){ alert("You clicked on the heading!"); });
});
|]
    toWidgetHead [hamlet| &lt;meta name=keywords content="some sample keywords"&gt;|]
    toWidget [hamlet| &lt;h1&gt;Here's one way of including content |]
    [whamlet| &lt;h2&gt;Here's another |]
    toWidgetBody [julius| alert("This is included in the body itself"); |]
</programlisting>
    <para>This produces the following HTML (indentation added):</para>
    <programlisting>&lt;!DOCTYPE html&gt; 
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My Page Title&lt;/title&gt;
        &lt;style&gt;h1 { color : green }&lt;/style&gt;
        &lt;script src="https://ajax.googleapis.com/ajax/libs/jquery/1.6.2/jquery.min.js"&gt;&lt;/script&gt;
        &lt;script&gt;
$(function() {
    $("h1").click(function(){ alert("You clicked on the heading!"); });
});
&lt;/script&gt;
        &lt;meta name="keywords" content="some sample keywords"&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Here's one way of including content &lt;/h1&gt;
        &lt;h2&gt;Here's another &lt;/h2&gt;
        &lt;script&gt; alert("This is included in the body itself"); &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
   </section>
   <section>
    <title>What's in a Widget?</title>
    <para/>
    <para>At a very superficial level, an HTML document is just a
            bunch of nested tags. This is the approach most HTML generation
            tools take: you simply define hierarchies of tags and are done with
            it. But let's imagine that I want to write a component of a page
            for displaying the navbar. I want this to be "plug and play": I
            simply call the function at the right time, and the navbar is
            inserted at the correct point in the hierarchy.</para>
    <para>This is where our superficial HTML generation breaks down. Our navbar likely consists of
            some CSS and JavaScript in addition to HTML. By the time we call the navbar function, we
            have already rendered the <literal>&lt;head&gt;</literal> tag, so it is too late to add a
            new <literal>&lt;style&gt;</literal> tag for our CSS declarations. Under normal
            strategies, we would need to break up our navbar function into three parts: HTML, CSS
            and JavaScript, and make sure that we always call all three pieces.</para>
    <para>Widgets take a different approach. Instead of viewing an
            HTML document as a monolithic tree of tags, widgets see a number of
            distinct components in the page. In particular:</para>
    <itemizedlist>
     <listitem>
      <para>The title</para>
     </listitem>
     <listitem>
      <para>External stylesheets</para>
     </listitem>
     <listitem>
      <para>External Javascript</para>
     </listitem>
     <listitem>
      <para>CSS declarations</para>
     </listitem>
     <listitem>
      <para>Javascript code</para>
     </listitem>
     <listitem>
      <para>Arbitrary <literal>&lt;head&gt;</literal> content</para>
     </listitem>
     <listitem>
      <para>Arbitrary <literal>&lt;body&gt;</literal> content</para>
     </listitem>
    </itemizedlist>
    <para>Different components have different semantics. For example,
            there can only be one title, but there can be multiple external
            scripts and stylesheets. However, those external scripts and
            stylesheets should only be included once. Arbitrary head and body
            content, on the other hand, has no limitation (someone may want to
            have five lorem ipsum blocks after all).</para>
    <para>The job of a widget is to hold onto these disparate components and apply proper logic
            for combining different widgets together. This consists of things like taking the first
            title set and ignoring others, filtering duplicates from the list of external scripts
            and stylesheets, and concatenating head and body content.</para>
   </section>
   <section>
    <title>Constructing Widgets</title>
    <para/>
    <para>In order to use widgets, you'll obviously need to be able to get your hands on them.
   The most common way will be via the <literal>ToWidget</literal> typeclass, and its
    <literal>toWidget</literal> method. This allows you to convert your Shakespearean templates
   directly to a <literal>Widget</literal>: Hamlet code will appear in the body, Julius scripts inside
   a <literal>&lt;script&gt;</literal> tag in the head, and Cassius and Lucius in a
    <literal>&lt;style&gt;</literal> tag.</para>
    <note>
     <para>You can actually override the default behavior and have the script and style code
   appear in a separate file. The scaffolded site provides this for you automatically. Additionally,
   we'll see in the Yesod typeclass chapter how to turn on asynchronous script loading, which
   will place your script content at the end of the body.</para>
    </note>
    <para>But what if you want to add some <literal>&lt;meta&gt;</literal> tags, which need to
   appear in the head? Or if you want some Javascript to appear in the body instead of the head? For
   these purposes, Yesod provides two additional type classes: <literal>ToWidgetHead</literal> and
    <literal>ToWidgetBody</literal>. These work exactly as they seem they should.</para>
    <para>In addition, there are a number of other functions for creating specific kinds of Widgets:</para>
    <variablelist>
     <varlistentry>
      <term>setTitle</term>
      <listitem>
       <para>Turns some HTML into the page title.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>addCassiusMedia, addLuciusMedia</term>
      <listitem>
       <para>Works the same as toWidget, but takes an additional parameter to indicate what kind of media
     this applies to. Useful for creating print stylesheets, for instance.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>addStylesheet</term>
      <listitem>
       <para>Adds a reference, via a <literal>&lt;link&gt;</literal> tag, to an external
     stylesheet. Takes a type-safe URL.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>addStylesheetRemote</term>
      <listitem>
       <para>Same as <literal>addStylesheet</literal>, but takes a normal URL. Useful for
     referring to files hosted on a CDN, like Google's jQuery UI CSS files.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>addScript</term>
      <listitem>
       <para>Adds a reference, via a <literal>&lt;script&gt;</literal> tag, to an external script.
     Takes a type-safe URL.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>addScriptRemote</term>
      <listitem>
       <para>Same as <literal>addScript</literal>, but takes a normal URL. Useful for referring to
     files hosted on a CDN, like Google's jQuery.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
   <section>
    <title>Combining Widgets</title>
    <para/>
    <para>The whole idea of widgets is to increase composability. You can take these individual
   pieces of HTML, CSS and Javascript, combine them together into something more complicated, and
   then combine these larger entities into complete pages. This all works naturally through the
    <literal>Monad</literal> instance of <literal>Widget</literal>, meaning you can use do-notation to
   compose pieces together.</para>
    <figure xml:id="combining-widgets-x2">
     <title>Combining Widgets</title>
     <programlisting language="haskell">myWidget1 = do
    toWidget [hamlet|&lt;h1&gt;My Title|]
    toWidget [lucius|h1 { color: green } |]

myWidget2 = do
    setTitle "My Page Title"
    addScriptRemote "http://www.example.com/script.js"

myWidget = do
    myWidget1
    myWidget2

-- or, if you want
myWidget' = myWidget1 &gt;&gt; myWidget2</programlisting>
    </figure>
    <note>
     <para>If you're so inclined, there's also a <literal>Monoid</literal> instance of
    <literal>Widget</literal>, meaning you can use <literal>mconcat</literal> or a
    <literal>Writer</literal> monad to build things up. In my experience, it's easiest and most
   natural to just use do-notation.</para>
    </note>
   </section>
   <section>
    <title>Generate IDs</title>
    <para/>
    <para>If we're really going for true code reuse here, we're eventually going to run into name
   conflicts. Let's say that there are two helper libraries that both use the class name "foo" to
   affect styling. We want to avoid such a possibility. Therefore, we have the
    <literal>newIdent</literal> function. This function automatically generates a word that is unique
   for this handler.</para>
    <figure xml:id="generate-ids-x2">
     <title>Using newIdent</title>
     <programlisting language="haskell">getRootR = defaultLayout $ do
    headerClass &lt;- lift newIdent
    toWidget [hamlet|&lt;h1 .#{headerClass}&gt;My Header|]
    toWidget [lucius| .#{headerClass} { color: green; } |]
</programlisting>
    </figure>
    <note>
     <para>You might be wondering: what does lift mean? A <literal>Widget</literal> is a monad
   transformer, sitting on top of a <literal>Handler</literal>. <literal>newIdent</literal> is a
   function of a <literal>Handler</literal>, so we need to "lift" the function from the
    <literal>Handler</literal> layer to the <literal>Widget</literal> layer to use it. We can actually
   use this same approach to perform complex actions, like database queries, from within a widget.
   We'll cover that when we discuss Yesod's monads.</para>
    </note>
   </section>
   <section>
    <title>whamlet</title>
    <para/>
    <para>Let's say you've got a fairly standard Hamlet template, that embeds another Hamlet template to
   represent the footer:</para>
    <programlisting language="haskell">page = [hamlet|
&lt;p&gt;This is my page. I hope you enjoyed it.
^{footer}
|]

footer = [hamlet|
&lt;footer&gt;
    &lt;p&gt;That's all folks!
|]</programlisting>
    <para>That works fine if the footer is plain old HTML, but what if we want to add some style? Well,
   we can easily spice up the footer by turning it into a Widget:</para>
    <programlisting language="haskell">footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
&lt;footer&gt;
    &lt;p&gt;That's all folks!
|]</programlisting>
    <para>But now we've got a problem: a Hamlet template can only embed another Hamlet template;
      it knows nothing about a Widget. This is where <literal>whamlet</literal> comes in. It takes
      exactly the same syntax as normal Hamlet, and variable (#{...}) and URL (@{...}) interpolation
      are unchanged. But embedding (^{...}) takes a <literal>Widget</literal>, and the final result is
      a <literal>Widget</literal>. To use it, we can just do:</para>
    <programlisting language="haskell">page = [whamlet|
&lt;p&gt;This is my page. I hope you enjoyed it.
^{footer}
|]</programlisting>
    <para>There is also <literal>whamletFile</literal>, if you would prefer to keep your template
      in a separate file.</para>
    <note>
     <para>The scaffolded site has an even more convenient function, <literal>widgetFile</literal>,
      which will also include your Lucius, Cassius, and Julius files automatically. We'll cover that
      in the scaffolding chapter.</para>
    </note>
    <section>
     <title>Types</title>
     <para/>
     <para>You may have noticed that I've been avoiding type signatures so far. That's because
   there's a little bit of a complication involved here. At the most basic level, all you need to
   know is that there's a type synonym called <literal>Widget</literal> which you will almost always
   use. The technical details follow, but don't worry if it's a little hazy.</para>
     <para>There isn't actually a <literal>Widget</literal> type defined in the Yesod libraries, since the
   exact meaning of it changes between sites. Instead, we have a more general type <literal>GWidget
    sub master a</literal>. The first two parameters give the sub and master foundation types,
   respectively. The final parameter is the contained value, just like any <literal>Monad</literal>
   has.</para>
     <para>So what's the deal with that sub/master stuff? Well, when you're writing some reusable code,
   such as a CRUD application, you can write it as a subsite that can be embedded within any other
   Yesod application. In such a case, we need to keep track of information for both the sub and
   master sites. The simplest example is for the type-safe URLs: Yesod needs to know how to take a
   route for your CRUD subsite and turn it into a route for the master site so that it can be
   properly rendered.</para>
     <para>However, that sub/master distinction only ever matters when you're interacting with subsites.
   When you're writing your standard response code, you're dealing with just your application, and
   so the sub and master sites will be the same. Since this is the most common case, the scaffolded
   site declares a type synonym to help you out. Let's say your foundation type is MyCoolApp, it
   will define <literal>type Widget = GWidget MyCoolApp MyCoolApp ()</literal>. Therefore, we can get
   some very user-friendly type signatures on our widgets:</para>
     <programlisting language="haskell">footer :: Widget
footer = do
    toWidget [lucius| footer { font-weight: bold; text-align: center } |]
    toWidget [hamlet|
&lt;footer&gt;
    &lt;p&gt;That's all folks!
|]

page :: Widget
page = [whamlet|
&lt;p&gt;This is my page. I hope you enjoyed it.
^{footer}
|]</programlisting>
     <para>If you've been paying close attention, you might be confused. We used <literal>lift</literal> on <literal>Widget</literal> in the ID generation example above, but
    <literal>GWidget</literal> isn't actually a monad transformer. What's going on here?
   Well, in older versions of Yesod, it <emphasis>was</emphasis> a transformer around the <literal>Handler</literal> type. Unfortunately, this led to difficult-to-parse error messages.
   As a result, <literal>GWidget</literal> is now a <literal>newtype</literal>
   wrapper that hides away its monad-transformer essence. But we still want to be able to <literal>lift</literal> functions from the inner <literal>Handler</literal> monad.</para>
     <para>To solve this, Yesod provides an alternate, more general <literal>lift</literal> function that
   works for both standard <literal>MonadTrans</literal> instances, and special
    <literal>newtype</literal> wrappers like <literal>GWidget</literal>. As a result, you can pretend
   like <literal>GWidget</literal> is a standard transformer, while still getting to keep your nice
   error message.</para>
     <para>One last point: just like we have the breakdown between <literal>Widget</literal> and
    <literal>GWidget</literal>, we have a similar breakdown between <literal>Handler</literal> and
    <literal>GHandler</literal>.</para>
    </section>
   </section>
   <section>
    <title>Using Widgets</title>
    <para/>
    <para>It's all well and good that we have these beautiful Widget datatypes, but how exactly
            do we turn them into something the user can interact with? The most commonly used
            function is <literal>defaultLayout</literal>, which essentially has the type signature
                <literal>Widget -&gt; Handler RepHtml</literal>. (I say "essentially" because
            of the whole <literal>GHandler</literal> issue.) <literal>RepHtml</literal> is a datatype
            containing some raw HTML output ready to be sent over the wire.</para>
    <para>
     <literal>defaultLayout</literal> is actually a typeclass method, which can be overridden
            for each application. This is how Yesod apps are themed. So we're still left with the
            question: when we're inside <literal>defaultLayout</literal>, how do we unwrap a
                <literal>Widget</literal>? The answer is <literal>widgetToPageContent</literal>. Let's
            look at some (simplified) types:</para>
    <programlisting language="haskell">widgetToPageContent :: Widget -&gt; Handler (PageContent url)
data PageContent url = PageContent
    { pageTitle :: Html
    , pageHead :: HtmlUrl url
    , pageBody :: HtmlUrl url
    }</programlisting>
    <para>This is getting closer to what we need. We now have direct access to the HTML making up
            the head and body, as well as the title. At this point, we can use Hamlet to combine
            them all together into a single document, along with our site layout, and we use
                <literal>hamletToRepHtml</literal> to render that Hamlet result into actual HTML
            that's ready to be shown to the user. The next figure demonstrates this process.</para>
    <figure xml:id="using-widgets-x6">
     <title>Using widgetToPageContent</title>
     <programlisting language="haskell">myLayout :: GWidget s MyApp () -&gt; GHandler s MyApp RepHtml
myLayout widget = do
    pc &lt;- widgetToPageContent widget
    hamletToRepHtml [hamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        &lt;meta charset=utf-8&gt;
        &lt;style&gt;body { font-family: verdana }
        ^{pageHead pc}
    &lt;body&gt;
        &lt;article&gt;
            ^{pageBody pc}
|]

instance Yesod MyApp where
    defaultLayout = myLayout
</programlisting>
    </figure>
    <note>
     <para>You may have noticed that we used <literal>GWidget</literal> and
                <literal>GHandler</literal> instead of <literal>Widget</literal> and
                <literal>Handler</literal>. That's because <literal>defaultLayout</literal> is a method
            that can be called by subsites to ensure that they get the same styling as the master
            site. Therefore, we need to keep our types flexible here.</para>
    </note>
    <para>This is all well and good, but there's one thing that bothers me: that
                <literal>style</literal> tag. There are a few problems with it:</para>
    <itemizedlist>
     <listitem>
      <para>Unlike Lucius or Cassius, it doesn't get compile-time checked for correctness.</para>
     </listitem>
     <listitem>
      <para>Granted that the current example is very simple, but in something more complicated we could
    get into character escaping issues.</para>
     </listitem>
     <listitem>
      <para>We'll now have two style tags instead of one: the one produced by
                    <literal>myLayout</literal>, and the one generated in the
                    <literal>pageHead</literal> based on the styles set in the widget.</para>
     </listitem>
    </itemizedlist>
    <para>We have one more trick in our bag to address this: we apply some last-minute
            adjustments to the widget itself before calling <literal>widgetToPageContent</literal>. It's actually very easy to do: we just use
            do-notation again, as in <xref linkend="using-widgets-last-minute-widget-adjustment"/>.</para>
    <figure xml:id="using-widgets-last-minute-widget-adjustment">
     <title>Last-Minute Widget Adjustment</title>
     <programlisting language="haskell">myLayout :: GWidget s MyApp () -&gt; GHandler s MyApp RepHtml
myLayout widget = do
    pc &lt;- widgetToPageContent $ do
        widget
        toWidget [lucius| body { font-family: verdana } |]
    hamletToRepHtml [hamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        &lt;meta charset=utf-8&gt;
        ^{pageHead pc}
    &lt;body&gt;
        &lt;article&gt;
            ^{pageBody pc}
|]
</programlisting>
    </figure>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>The basic building block of each page is a widget. Individual snippets of HTML, CSS, and
   Javascript can be turned into widgets via the polymorphic <literal>toWidget</literal> function.
   Using do-notation, you can combine these individual widgets into larger widgets, eventually
   containing all the content of your page.</para>
    <para>Unwrapping these widgets is usually performed within the defaultLayout function, which can be
   used to apply a unified look-and-feel to all your pages.</para>
   </section>
  </chapter>
  <chapter>
   <title>Yesod Typeclass</title>
   <para/>
   <para/>
   <para>Every one of our Yesod applications requires an instance of the <literal>Yesod</literal> typeclass. So far, we've only seen <literal>defaultLayout</literal>. In this chapter, we'll explore the meaning of many of the
            methods of the <literal>Yesod</literal> typeclass.</para>
   <para>The <literal>Yesod</literal> typeclass gives us a central place for defining
            settings for our application. Eeverything else has a default definition which is usually
            the right thing. But in order to build a powerful, customized application, you'll
            usually end up wanting to override at least a few of these methods.</para>
   <section>
    <title>Rendering and Parsing URLs</title>
    <para/>
    <para>We've already mentioned how Yesod is able to automatically render type-safe URLs into a textual URL that can be inserted into an HTML page. Let's say we have a route definition that looks like:</para>
    <programlisting language="haskell">mkYesod "MyApp" [parseRoutes|
/some/path SomePathR GET
]</programlisting>
    <para>If we place <literal>SomePathR</literal> into a hamlet template, how does Yesod render
            it? Yesod always tries to construct <emphasis>absolute</emphasis> URLs. This is especially
            useful once we start creating XML sitemaps and Atom feeds, or sending emails. But in
            order to construct an absolute URL, we need to know the domain name of the
            application.</para>
    <para>You might think we could get that information from the user's request, but we still
            need to deal with ports. And even if we get the port number from the request, are we
            using HTTP or HTTPS? And even if you know <emphasis>that</emphasis>, such an approach would
            mean that, depending on how the user submitted a request would generate different URLs.
            For example, we would generate different URLs depending if the user connected to
            "example.com" or "www.example.com". For Search Engine Optimization, we want to be able
            to consolidate on a single canonical URL.</para>
    <para>And finally, Yesod doesn't make any assumption about <emphasis>where</emphasis> you host your application. For example, I may have a mostly static site (http://static.example.com/), but I'd like to stick a Yesod-powered Wiki at /wiki/. There is no reliable way for an application to determine what subpath it is being hosted from. So instead of doing all of this guesswork, Yesod needs you to tell it the <glossterm>application root</glossterm>.</para>
    <para>Using the wiki example, you would write your <literal>Yesod</literal> instance as:</para>
    <programlisting language="haskell">instance Yesod MyWiki where
    approot _ = "http://static.example.com/wiki" -- FIXME this is out-of-date</programlisting>
    <para>Notice that there is no trailing slash there. Next, when Yesod wants to construct a URL
            for <literal>SomePathR</literal>, it determines that the relative path for
                <literal>SomePathR</literal> is <literal>/some/path</literal>, appends that to your
            approot and creates <literal>http://static.example.com/wiki/some/path</literal>.</para>
    <para>This also explains our cryptic <literal>approot _ = ""</literal> FIXME: for our
            examples in the book, we're always serving from the root of the domain (in our case,
                <literal>localhost</literal>). By using an empty string, <literal>SomePathR</literal>
            renders to <literal>/some/path</literal>, which works just fine. In real life
            applications, however, you should use a real application root.</para>
    <note>
     <para>The first argument to <literal>approot</literal> FIXME is the site foundation. This means
            that you could load your approot at program initialization, store it in the foundation,
            and then retrieve it. This is in fact what the scaffolded site does, using a YAML config
            file.</para>
    </note>
    <para>And by the way, the scaffolded site can load different settings for developing,
            testing, staging, and production builds, so you can easily test on one domain- like
            localhost- and serve from a different domain.</para>
    <note>
     <para>To reiterate: even though for the simple cases in this book, the first argument to
                    <literal>approot</literal> is usually ignored, in real life code it usually isn't.
                We also need to keep that argument so that Haskell's type system can determine which
                instance of <literal>Yesod</literal> to use in grabbing the
                <literal>approot</literal>.</para>
    </note>
    <section>
     <title>joinPath</title>
     <para/>
     <para>In order to convert a type-safe URL into a text value, Yesod uses two helper functions.
            The first is the <literal>renderRoute</literal> method of the <literal>RenderRoute</literal> typeclass. Every type-safe URL is an instance of this
            typeclass. <literal>renderRoute</literal> converts a value into a list of path
            pieces. For example, our <literal>SomePathR</literal> from above would be
            converted into <literal>["some", "path"]</literal>.</para>
     <note>
      <para>Actually, <literal>renderRoute</literal> produces both the path pieces and a list of
                query-string parameters. The default instances of <literal>renderRoute</literal>
                always provide an empty list of query string parameters. However, it is possible to
                override this. One notable case is the static subsite, which puts a hash of the file
                contents in the query string for caching purposes.</para>
     </note>
     <para>The other function is the <literal>joinPath</literal> method of the Yesod
            typeclass. This function takes four arguments: the foundation value, the application
            root, a list of path segments and a list of query string parameters, and returns a
            textual URL. The default implementation does the "right thing": it separates the path
            pieces by forward slashes, prepends the application root and appends the query
            string.</para>
     <para>If you are happy with default URL rendering, you should not need to modify it. However, if you want to modify URL rendering to do things like append a trailing slash, this would be the place to do it.</para>
    </section>
    <section>
     <title>cleanPath</title>
     <para/>
     <para>The flip side to <literal>joinPath</literal> is <literal>cleanPath</literal>. Let's look at how it gets used in the dispatch process:</para>
     <orderedlist>
      <listitem>
       <para>The path info requested by the user is split into a series of path pieces.</para>
      </listitem>
      <listitem>
       <para>We pass the path pieces to the <literal>cleanPath</literal> function.</para>
      </listitem>
      <listitem>
       <para>If <literal>cleanPath</literal> indicates a redirect (a <literal>Left</literal> response),
                then a 301 response is sent to the client. This is used to force canonical URLs (eg,
                remove extra slashes).</para>
      </listitem>
      <listitem>
       <para>Otherwise, we try to dispatch using the response from <literal>cleanPath</literal> (a
                    <literal>Right</literal>). If this works, we return a response. Otherwise, we
                return a 404.</para>
      </listitem>
     </orderedlist>
     <para>This combination allows subsites to retain full control of how their URLs appear, yet allows master sites to have modified URLs. As a simple example, let's see how we could modify Yesod to always produce trailing slashes on URLs:</para>
     <programlisting language="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, MultiParamTypeClasses, TemplateHaskell, OverloadedStrings #-}
import Yesod
import Network.HTTP.Types (encodePath)
import Blaze.ByteString.Builder.Char.Utf8 (fromText)
import qualified Data.Text as T
import qualified Data.Text.Encoding as TE
import Control.Arrow ((***))
import Data.Monoid (mappend)

data Slash = Slash

mkYesod "Slash" [parseRoutes|
/ RootR GET
/foo FooR GET
|]

instance Yesod Slash where
    joinPath _ ar pieces' qs' =
        fromText ar `mappend` encodePath pieces qs
      where
        qs = map (TE.encodeUtf8 *** go) qs'
        go "" = Nothing
        go x = Just $ TE.encodeUtf8 x
        pieces = pieces' ++ [""]

    -- We want to keep canonical URLs. Therefore, if the URL is missing a
    -- trailing slash, redirect. But the empty set of pieces always stays the
    -- same.
    cleanPath _ [] = Right []
    cleanPath _ s
        | dropWhile (not . T.null) s == [""] = -- the only empty string is the last one
            Right $ init s
        -- Since joinPath will append the missing trailing slash, we simply
        -- remove empty pieces.
        | otherwise = Left $ filter (not . T.null) s

getRootR = defaultLayout [whamlet|
&lt;p&gt;
    &lt;a href=@{RootR}&gt;RootR
&lt;p&gt;
    &lt;a href=@{FooR}&gt;FooR
|]

getFooR = getRootR

main = warpDebug 3000 Slash
</programlisting>
     <para>First, let's look at our <literal>joinPath</literal> implementation. This is copied almost
            verbatim from the default Yesod implementation, with one difference: we append an extra
            empty string to the end. When dealing with path pieces, an empty string will append
            another slash. So adding an extra empty string will force a trailing slash.</para>
     <para>
      <literal>cleanPath</literal> is a little bit trickier. First, we check for the empty path
            like before, and if so pass it through as-is. We use Right to indicate that a redirect
            is not necessary. The next clause is actually checking for two different possible URL
            issues:</para>
     <itemizedlist>
      <listitem>
       <para>There is a double slash, which would show up as an empty string in the middle of our paths.</para>
      </listitem>
      <listitem>
       <para>There is a missing trailing slash, which would show up as the last piece not being an empty string.</para>
      </listitem>
     </itemizedlist>
     <para>Assuming neither of those conditions hold, then only the last piece is empty, and we
            should dispatch based on all but the last piece. However, if this is not the case, we
            want to redirect to a canonical URL. In this case, we strip out all empty pieces and do
            not bother appending a trailing slash, since <literal>joinPath</literal> will do that for
            us.</para>
    </section>
   </section>
   <section>
    <title>defaultLayout</title>
    <para/>
    <para>Most websites like to apply some general template to all of their pages.
                <literal>defaultLayout</literal> is the recommended approach for this. While you could
            just as easily define your own function and call that instead, when you override
                <literal>defaultLayout</literal> all of the Yesod-generated pages (error pages,
            authentication pages) automatically get this style.</para>
    <para>Overriding is very straight-forward: we use <literal>widgetToPageContent</literal>
            to convert a <literal>Widget</literal> to a title, head tags and body tags, and then use
                <literal>hamletToRepHtml</literal> to convert a Hamlet template into a
                <literal>RepHtml</literal>. We can even add extra widget components, like a Lucius
            template. from within <literal>defaultLayout</literal>. An example should make this all
            clear:</para>
    <programlisting language="haskell">    defaultLayout contents = do
        PageContent title headTags bodyTags &lt;- widgetToPageContent $ do
            toWidget [cassius|
#body
    font-family: sans-serif
#wrapper
    width: 760px
    margin: 0 auto
|]
            addWidget contents
        hamletToRepHtml [hamlet|
$doctype 5

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{title}
        ^{headTags}
    &lt;body&gt;
        &lt;div id="wrapper"&gt;
            ^{bodyTags}
|]
</programlisting>
    <section>
     <title>getMessage</title>
     <para/>
     <para>Even though we haven't covered sessions yet, I'd like to mention
                <literal>getMessage</literal> here. A common pattern in web development is setting a
            message in one handler and displaying it in another. For example, if a user
                <literal>POST</literal>s a form, you may want to redirect him/her to another page
            along with a "Form submission complete" message.</para>
     <note>
      <para>This is commonly known as <link xlink:href="http://en.wikipedia.org/wiki/Post/Redirect/Get">Post/Redirect/Get</link>.</para>
     </note>
     <para>To facilitate this, Yesod comes built in with a pair of functions:
                <literal>setMessage</literal> sets a message in the user session, and
                <literal>getMessage</literal> retrieves the message (and clears it, so it doesn't
            appear a second time). It's recommended that you put the result of
                <literal>getMessage</literal> into your <literal>defaultLayout</literal>. For
            example:</para>
     <programlisting language="haskell">    defaultLayout contents = do
        PageContent title headTags bodyTags &lt;- widgetToPageContent contents
        mmsg &lt;- getMessage
        hamletToRepHtml [hamlet|
$doctype 5

&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{title}
        ^{headTags}
    &lt;body&gt;
        $maybe msg &lt;- mmsg
            &lt;div #message&gt;#{msg}
        ^{bodyTags}
|]
</programlisting>
     <para>We'll cover <literal>getMessage</literal>/<literal>setMessage</literal> in more detail when
            we discuss sessions.</para>
    </section>
   </section>
   <section>
    <title>Custom error pages</title>
    <para/>
    <para>One of the marks of a professional web site is a properly designed error page. Yesod
            gets you a long way there by automatically using your <literal>defaultLayout</literal> for
            displaying error pages. But sometimes, you'll want to go even further. For this, you'll
            want to override the <literal>errorHandler</literal> method:</para>
    <programlisting language="haskell">    errorHandler NotFound = fmap chooseRep $ defaultLayout $ do
        setTitle "Request page not located"
        toWidget [hamlet|
&lt;h1&gt;Not Found
&lt;p&gt;We apologize for the inconvenience, but the requested page could not be located.
|]
    errorHandler other = defaultErrorHandler other
</programlisting>
    <para>Here we specify a custom 404 error page. We can also use the
                <literal>defaultErrorHandler</literal> when we don't want to write a custom handler
            for each error type. Due to type constraints, we need to start off our methods with
                <literal>fmap chooseRep</literal>, but otherwise you can write a typical handler
            function.</para>
    <para>In fact, you could even use special responses like redirects:</para>
    <programlisting language="haskell">    errorHandler NotFound = redirect RootR
    errorHandler other = defaultErrorHandler other
</programlisting>
    <note>
     <para>Even though you <emphasis>can</emphasis> do this, I don't actually recommend such practices. A 404 should be a 404.</para>
    </note>
   </section>
   <section>
    <title>External CSS and Javascript</title>
    <para/>
    <note>
     <para>The functionality described here is automatically included in the
   scaffolded site, so you don't need to worry about implementing this yourself.</para>
    </note>
    <para>One of the most powerful, and most intimidating, methods in the Yesod typeclass is
    <literal>addStaticContent</literal>. Remember that a Widget consists of multiple
   components, including CSS and Javascript. How exactly does that CSS/JS arrive in the user's
   browser? By default, they are served in the <literal>&lt;head&gt;</literal> of the page, inside
    <literal>&lt;style&gt;</literal> and <literal>&lt;script&gt;</literal> tags, respectively.</para>
    <para>That might be simple, but it's far from efficient. Every page load will now require loading up
   the CSS/JS from scratch, even if nothing changed! What we really want is to store this content in
   an external file and then refer to it from the HTML.</para>
    <para>This is where <literal>addStaticContent</literal> comes in. It takes three arguments:
   the filename extension of the content (<literal>css</literal> or <literal>js</literal>), the
   mime-type of the content (<literal>text/css</literal> or <literal>text/javascript</literal>) and the
   content itself. It will then return one of three possible results:</para>
    <variablelist>
     <varlistentry>
      <term>Nothing</term>
      <listitem>
       <para>No static file saving occurred; embed this content directly in the HTML. This is the default
     behavior.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Just (Left Text)</term>
      <listitem>
       <para>This content was saved in an external file, and use the given textual link to refer to
     it.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Just (Right (Route a, Query))</term>
      <listitem>
       <para>Same, but now use a type-safe URL along with some query string parameters.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>The <literal>Left</literal> result is useful if you want to store your static files on
   an external server, such as a CDN or memory-backed server. The <literal>Right</literal> result is
   more commonly used, and ties in very well with the static subsite. This is the recommended
   approach for most applications, and is provided by the scaffolded site by default.</para>
    <note>
     <para>You might be wondering: if this is the recommended approach, why isn't it the default? The
   problem is that it makes a number of assumptions that don't universally hold: your application
   has a static subsite, and the location of your static files.</para>
    </note>
    <para>The scaffolded <literal>addStaticContent</literal> does a number of intelligent things
   to help you out:</para>
    <itemizedlist>
     <listitem>
      <para>It automatically minifies your Javascript using the <function>hjsmin</function> package.</para>
     </listitem>
     <listitem>
      <para>It names the output files based on a hash of the file contents. This means you can set your
    cache headers to far in the future without fears of stale content.</para>
     </listitem>
     <listitem>
      <para>Also, since filenames are based on hashes, you can be guaranteed that a file doesn't need to
    be written if a file with the same name already exists. The scaffold code automatically checks
    for the existence of that file, and avoids the costly disk I/O of a write if it's not
    necessary.</para>
     </listitem>
    </itemizedlist>
   </section>
   <section>
    <title>Smarter Static Files</title>
    <para/>
    <para>Google recommends an important optimization: <link xlink:href="http://code.google.com/speed/page-speed/docs/request.html#ServeFromCookielessDomain">serve static files from a separate domain</link>. The advantage
   to this approach is that cookies set on your main domain are not sent when retrieving static
   files, thus saving on a bit of bandwidth.</para>
    <para>To facilitate this, we have the <literal>urlRenderOverride</literal> method. This method
   intercepts the normal URL rendering and sets a special value for some routes. For example, the
   scaffolding defines this method as:</para>
    <programlisting language="haskell">    urlRenderOverride y (StaticR s) =
        Just $ uncurry (joinPath y (Settings.staticRoot $ settings y)) $ renderRoute s
    urlRenderOverride _ _ = Nothing</programlisting>
    <para>This means that static routes are served from a special static root, which you can configure to
   be a different domain. This is a great example of the power and flexibility of type-safe URLs:
   with a single line of code you're able to change the rendering of static routes throughout all of
   your handlers.</para>
   </section>
   <section>
    <title>Authentication/Authorization</title>
    <para/>
    <para>For simple applications, checking permissions inside each handler function can be a
   simple, convenient approach. However, it doesn't scale well. Eventually, you're going to want to
   have a more declarative approach. Many systems out there define ACLs, special config files, and a
   lot of other hocus-pocus. In Yesod, it's just plain old Haskell. There are three methods
   involved:</para>
    <variablelist>
     <varlistentry>
      <term>isWriteRequest</term>
      <listitem>
       <para>Determine if the current request is a "read" or "write" operations. By default,
     Yesod follows RESTful principles, and assumes <literal>GET</literal>, <literal>HEAD</literal>,
      <literal>OPTIONS</literal>, and <literal>TRACE</literal> requests are read-only, while all others
     are can write.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>isAuthorized</term>
      <listitem>
       <para>Takes a route (i.e., type-safe URL) and a boolean indicating whether or not the
     request is a write request. It returns an <literal>AuthResult</literal>, which can have one of
     three values:<itemizedlist>
         <listitem>
          <para>
           <literal>Authorized</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>AuthenticationRequired</literal>
          </para>
         </listitem>
         <listitem>
          <para>
           <literal>Unauthorized</literal>
          </para>
         </listitem>
        </itemizedlist>By default, it returns <literal>Authorized</literal> for all requests.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>authRoute</term>
      <listitem>
       <para>If <literal>isAuthorized</literal> returns <literal>AuthenticationRequired</literal>,
     then redirect to the given route. If no route is provided (the default), return a 403
     "Permission Denied" message.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>These methods tie in nicely with the <function>yesod-auth</function> package,
   which is used by the scaffolded site to provide a number of authentication options, such as
   OpenID, BrowserID, email, username and Twitter. We'll cover more concrete examples in the auth chapter.</para>
   </section>
   <section>
    <title>Some Simple Settings</title>
    <para/>
    <para>Not everything in the Yesod typeclass is complicated. Some methods are simple
   functions. Let's just go through the list:</para>
    <variablelist>
     <varlistentry>
      <term>encryptKey</term>
      <listitem>
       <para>Yesod uses client-side sessions, which are stored in encrypted,
     cryptographically-hashed cookies. Well, as long as you provide an encryption key. If this
     function returns Nothing, then sessions are disabled. This can be a useful optimization on
     sites that don't need session facilities, as it avoids an encrypt/decrypt pair on each
      request.<note>
         <para>The combination of encryption and hashing guarantees two properties: the session
      payload is tamper-proof, and is opaque. Encryption without hashing would allow a user to
      randomly change the cookie data and still have it accepted by the server, while hashing
      without encryption would allow inspection of the data.</para>
        </note>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>clientSessionDuration</term>
      <listitem>
       <para>How long a session should last for. By default, this is two hours.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>sessionIpAddress</term>
      <listitem>
       <para>By default, sessions are tied to an individual IP address. If your users are sitting behind
     a proxy server, this can cause trouble when their IP suddenly changes. This setting lets you
     disable this security feature.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>cookiePath</term>
      <listitem>
       <para>What paths within your current domain to set cookies for. The default is "/", and will
     almost always be correct. One exception might be when you're serving from a subpath within a
     domain (like our wiki example above).</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>maximumContentLength</term>
      <listitem>
       <para>To prevent Denial of Server (DoS) attacks, Yesod will limit the size of request bodies. Some
     of the time, you'll want to bump that limit for some routes (e.g., a file upload page). This is
     where you'd do that.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>yepnopeJs</term>
      <listitem>
       <para>You can specify the location of the <link xlink:href="http://yepnopejs.com/">yepnope</link> Javascript library. If this is given, then yepnope will be
     used to asynchronously load all of the Javascript on your page.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>The Yesod typeclass has a number of overrideable methods that allow you to configure your
            application. They are all optional, and provide
            sensible defaults. By using built-in Yesod constructs like
                <literal>defaultLayout</literal> and <literal>getMessage</literal>, you'll get a
            consistent look-and-feel throughout your site, including pages automatically generated
            by Yesod such as error pages and authentication.</para>
    <para>We haven't covered all the methods in the Yesod typeclass in this chapter. For a full
            listing of methods available, you should consult the Haddock documentation.</para>
   </section>
  </chapter>
  <chapter>
   <title>Routing and Handlers</title>
   <para/>
   <para/>
   <para>If we look at Yesod as a Model-View-Controller framework, routing and handlers make up the controller. For contrast, let's describe two other routing approaches used in other web development environments:</para>
   <itemizedlist>
    <listitem>
     <para>Dispatch based on file name. This is how PHP and ASP work, for example.</para>
    </listitem>
    <listitem>
     <para>Have a centralized routing function that parses routes based on regular expressions. Django and Rails follow this approach.</para>
    </listitem>
   </itemizedlist>
   <para>Yesod is closer in principle to the latter technique. Even so, there are significant differences. Instead of using regular expressions, Yesod matches on pieces of a route. Instead of having a one-way route-to-handler mapping, Yesod has an intermediate data type (called the route datatype, or a type-safe URL) and creates two-way conversion functions.</para>
   <para>Coding this more advanced system manually is tedious and error prone. Therefore,
            Yesod defines a Domain Specific Language (DSL) for specifying routes, and provides
            Template Haskell functions to convert this DSL to Haskell code. This chapter will
            explain the syntax of the routing declarations, give you a glimpse of what code is
            generated for you, and explain the interaction between routing and handler
            functions.</para>
   <section>
    <title>Route Syntax</title>
    <para/>
    <para>Instead of trying to shoe-horn route declarations into an existing syntax,
            Yesod's approach is to use a simplified syntax designed just for routes. This has the
            advantage of making the code not only easy to write, but simple enough for someone with
            no Yesod experience to read and understand the sitemap of your application.</para>
    <para>A basic example of this syntax is:</para>
    <programlisting>/             RootR     GET
/blog         BlogR     GET POST
/blog/#BlogId BlogPostR GET POST

/static       StaticR   Static getStatic</programlisting>
    <para>The next few sections will explain the full details of what goes on in the route
            declaration.</para>
    <section>
     <title>Pieces</title>
     <para/>
     <para>One of the first thing Yesod does when it gets a request is split up the requested
            path into pieces. The pieces are tokenized at all forward slashes. For example:</para>
     <programlisting language="haskell">toPieces "/" = []
toPieces "/foo/bar/baz/" = ["foo", "bar", "baz", ""]</programlisting>
     <para>You may notice that there are some funny things going on with trailing slashes, or
            double slashes ("/foo//bar//"), or a few other things. Yesod believes in having <glossterm>canonical URLs</glossterm>; if someone requests a URL with a trailing slash, or
            with a double slash, they automatically get a redirect to the canonical version. This
            ensures you have one URL for one resource, and can help with your search rankings.</para>
     <para>What this means for you is that you needn't concern yourself
                with the exact structure of your URLs: you can safely think
                about pieces of a path, and Yesod automatically handles
                intercalating the slashes and escaping problematic
                characters.</para>
     <para>If, by the way, you want more fine-tuned control of how paths are split into pieces
            and joined together again, you'll want to look at the <literal>cleanPath</literal> and
                <literal>joinPath</literal> methods in the Yesod typeclass chapter.</para>
     <section>
      <title>Types of Pieces</title>
      <para/>
      <para>When you are declaring your routes, you have three types of pieces at your disposal:</para>
      <variablelist>
       <varlistentry>
        <term>Static</term>
        <listitem>
         <para>This is a plain string that must be matched against precisely in the URL.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Dynamic single</term>
        <listitem>
         <para>This is a single piece (ie, between two forward slashes), but can be a user-submitted value. This is the primary method of receiving extra user input on a page request. These pieces begin with a hash (#) and are followed by a data type. The datatype must be an instance of <literal>PathPiece</literal>.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Dynamic multi</term>
        <listitem>
         <para>The same as before, but can receive multiple pieces of the URL. This must always be the last piece in a resource pattern. It is specified by an asterisk (*) followed by a datatype, which must be an instance of <literal>PathMultiPiece</literal>. Multi pieces are not as common as the other two, though they are very important for implementing features like static trees representing file structure or wikis with arbitrary hierarchies.</para>
        </listitem>
       </varlistentry>
      </variablelist>
      <para>Let us take a look at some standard kinds of resource patterns you may want to write. Starting simply, the root of an application will just be <literal>/</literal>. Similarly, you may want to place your FAQ at <literal>/page/faq</literal>.</para>
      <para>Now let's say you are going to write a Fibonacci website. You may construct your URLs like <literal>/fib/#Int</literal>. But there's a slight problem with this: we do not want to allow negative numbers or zero to be passed into our application. Fortunately, the type system can protect us:</para>
      <programlisting language="haskell">newtype Natural = Natural Int
instance PathPiece Natural where
    toPathPiece (Natural i) = T.pack $ show i
    fromPathPiece s =
        case reads $ T.unpack s of
            (i, ""):_
                | i &lt; 1 -&gt; Nothing
                | otherwise -&gt; Just $ Natural i
            [] -&gt; Nothing
</programlisting>
      <para>On line 1 we define a simple newtype wrapper around Int to protect ourselves from
            invalid input. We can see that <literal>PathPiece</literal> is a typeclass with two
            methods. <literal>toPathPiece</literal> does nothing more than convert to a
                <literal>Text</literal>. <literal>fromPathPiece</literal>
       <emphasis>attempts</emphasis> to convert a <literal>Text</literal> to our datatype,
            returning <literal>Nothing</literal> when this conversion is impossible. By using
            this datatype, we can ensure that our handler function is only ever given natural
            numbers, allowing us to once again use the type system to battle the boundary issue.</para>
      <note>
       <para>In a real life application, we would also want to ensure we never accidently
            constructed an invalid <literal>Natural</literal> value internally to our app. To do so,
            we could use an approach like <link xlink:href="http://www.haskell.org/haskellwiki/Smart_constructors">smart constructors</link>. For the purposes of this example, we've
            kept the code simple.</para>
      </note>
      <para>Defining a <literal>PathMultiPiece</literal> is just as simple. Let's say we want to
            have a Wiki with at least two levels of hierarchy; we might define a datatype such
            as:</para>
      <programlisting language="haskell">data Page = Page Text Text [Text] -- 2 or more
instance PathMultiPiece Page where
    toPathMultiPiece (Page x y z) = x : y : z
    fromPathMultiPiece (x:y:z) = Just $ Page x y z
    fromPathMultiPiece _ = Nothing
</programlisting>
     </section>
    </section>
    <section>
     <title>Resource name</title>
     <para/>
     <para>Each resource pattern also has a name associated with it. That
                name will become the constructor for the <glossterm>type safe
                    URL</glossterm> datatype associated with your application.
                Therefore, it has to start with a capital letter. By
                convention, these resource names all end with a capital R.
                There is nothing forcing you to do this, it is just
                common practice.</para>
     <para>The exact definition of our constructor depends upon the
                resource pattern it is attached to. Whatever datatypes are
                included in single and multi pieces of the pattern become
                arguments to the datatype. This gives us a 1-to-1
                correspondence between our type safe URL values and valid URLs
                in our application.</para>
     <note>
      <para>This doesn't necessarily mean that <emphasis>every</emphasis> value
                    is a working page, just that it is is a potentially valid
                    URL. As an example, that value <literal>PersonR
                        "Michael"</literal> may not resolve to a valid page if
                    there is no Michael in the database.</para>
     </note>
     <para>Let's get some real examples going here. If you had the resource patterns <literal>/person/#Text</literal> named <literal>PersonR</literal>, <literal>/year/#Int</literal> named <literal>YearR</literal> and <literal>/page/faq</literal> named <literal>FaqR</literal>, you would end up with a
            route data type roughly looking like:</para>
     <programlisting language="haskell">data MyRoute = PersonR Text
             | YearR Int
             | FaqR</programlisting>
     <para>If a user requests the relative URL of
                 <literal>/year/2009</literal>, Yesod will convert it into the value
                 <literal>YearR 2009</literal>. <literal>/person/Michael</literal> becomes
                 <literal>PersonR "Michael"</literal> and <literal>/page/faq</literal>
                 becomes <literal>FaqR</literal>. On the other hand,
                 <literal>/year/two-thousand-nine</literal>,
                 <literal>/person/michael/snoyman</literal> and
                 <literal>/page/FAQ</literal> would all result in 404 errors without
                 ever seeing your code.</para>
    </section>
    <section>
     <title>Handler specification</title>
     <para/>
     <para>The last piece of the puzzle when declaring your resources is how they will be handled. There are three options in Yesod:</para>
     <itemizedlist>
      <listitem>
       <para>A single handler function for all request methods on a given route.</para>
      </listitem>
      <listitem>
       <para>A separate handler function for each request method on a given route. Any other request
                method will generate a 405 Bad Method response.</para>
      </listitem>
      <listitem>
       <para>You want to pass off to a <glossterm>subsite</glossterm>.</para>
      </listitem>
     </itemizedlist>
     <para>The first two can be easily specified. A single handler function will be a line with
            just a resource pattern and the resource name, such as <literal>/page/faq
                FaqR</literal>. In this case, the handler function must be named <literal>handleFaqR</literal>.</para>
     <para>A separate handler for each request method will be the same, plus a list of request
            methods. The request methods must be all capital letters. For example, <literal>/person/#String PersonR GET POST DELETE</literal>. In this case, you would need to
            define three handler functions: <literal>getPersonR</literal>, <literal>postPersonR</literal> and <literal>deletePersonR</literal>.</para>
     <para>Subsites are a very useful— but complicated— topic in Yesod. We
                 will cover writing subsites
                     later, but using them is not too difficult. The
                 most commonly used subsite is the static subsite, which serves
                 static files for your application. In order to serve static
                 files from <literal>/static</literal>, you would need a resource
                 line like:</para>
     <programlisting>/static StaticR Static getStatic</programlisting>
     <para>In this line, <literal>/static</literal> just says where in your URL
                 structure to serve the static files from. There is nothing
                 magical about the word static, you could easily replace it
                 with <literal>/my/non-dynamic/files</literal>.</para>
     <para>The next word, <literal>StaticR</literal>, gives the resource name. The next two words
            are what specify that we are using a subsite. <literal>Static</literal> is the
            name of the <glossterm>subsite foundation datatype</glossterm>, and <literal>getStatic</literal> is a function that gets a <literal>Static</literal> value
            from a value of your master foundation datatype.</para>
     <para>Let's not get too caught up in the details of subsites now. We
                 will look more closely at the static subsite in the scaffolded site chapter.</para>
    </section>
   </section>
   <section>
    <title>Dispatch</title>
    <para/>
    <para>Once you have specified your routes, Yesod will take care of all the pesky details
            of URL dispatch for you. You just need to make sure to provide the appropriate <glossterm>handler functions</glossterm>. For subsite routes, you do not need to write any
            handler functions, but you do for the other two. We mentioned the naming rules above
                (<literal>MyHandlerR GET</literal> becomes <literal>getMyHandlerR</literal>, <literal>MyOtherHandlerR</literal> becomes <literal>handleMyOtherHandlerR</literal>). Now we need the type signature.</para>
    <section>
     <title>Return Type</title>
     <para/>
     <para>Let's look at a simple handler function:</para>
     <programlisting language="haskell">mkYesod "Simple" [parseRoutes|
/ HomeR GET
|]

getHomeR :: Handler RepHtml
getHomeR = defaultLayout [whamlet|&lt;h1&gt;This is simple
|]
</programlisting>
     <para>Look at the type signature of <literal>getHomeR</literal>. The first component is
                <literal>Handler</literal>. <literal>Handler</literal> is a special monad that
            all handler functions live in. It provides access to request information, let's you send
            redirects, and lots of other stuff we'll get to
            soon.</para>
     <para>Next we have <literal>RepHtml</literal>. When we discuss
                representations we will explore the <emphasis>why</emphasis> of things more; for now, we
            are just interested in the <emphasis>how</emphasis>.</para>
     <para>As you might guess, <literal>RepHtml</literal> is a datatype for HTML responses.
            And as you also may guess, web sites need to return responses besides HTML. CSS,
            Javascript, images, XML are all necessities of a website. Therefore, the return value of
            a handler function can be any instance of <literal>HasReps</literal>.</para>
     <para>
      <literal>HasReps</literal> is a powerful concept that allows Yesod to
            automatically choose the correct representation of your data based on the client
            request. For now, we will focus just on simple instances such as
                <literal>RepHtml</literal>, which only provide one representation.</para>
    </section>
    <section>
     <title>Arguments</title>
     <para/>
     <para>Not every route is as simple as the <literal>HomeR</literal> we just defined. Take
            for instance our <literal>PersonR</literal> route from earlier. The name of the person
            needs to be passed to the handler function. This translation is very straight-forward,
            and hopefully intuitive. For example:</para>
     <programlisting language="haskell">mkYesod "Args" [parseRoutes|
/person/#Text PersonR GET
/year/#Integer/month/#Text/day/#Int DateR
/wiki/*Texts WikiR GET
|]

getPersonR :: Text -&gt; Handler RepHtml
getPersonR name = defaultLayout [whamlet|&lt;h1&gt;Hello #{name}!|]

handleDateR :: Integer -&gt; Text -&gt; Int -&gt; Handler RepPlain -- text/plain
handleDateR year month day =
    return $ RepPlain $ toContent $
        T.concat [month, " ", T.pack $ show day, ", ", T.pack $ show year]

getWikiR :: [Text] -&gt; Handler RepPlain
getWikiR = return . RepPlain . toContent . T.unwords
</programlisting>
     <para>The arguments have the types of the dynamic pieces for each route, in the order specified. Also, notice how we are able to use both <literal>RepHtml</literal> and <literal>RepPlain</literal>.</para>
    </section>
   </section>
   <section>
    <title>The Handler Monad</title>
    <para/>
    <para>The vast majority of code you write in Yesod sits in the <literal>Handler</literal>
            monad. If you are approaching this from an MVC (Model-View-Controller) background, your
                <literal>Handler</literal> code is the Controller. Some important points to know about
                <literal>Handler</literal>:</para>
    <itemizedlist>
     <listitem>
      <para>It is an instance of <literal>MonadIO</literal>, so you can run any IO
                action in your handlers with <literal>liftIO</literal>. By the way, <literal>liftIO</literal> is exported by the <literal>Yesod</literal> module
                for your convenience.</para>
     </listitem>
     <listitem>
      <para>Like <literal>Widget</literal>, <literal>Handler</literal> is a
                fake-monad-transformer. It wraps around a <literal>ResourceT IO</literal> monad. We
                discuss this type at length in the conduits appendix, but for now, we'll just say it let's you
                safely allocate resources.</para>
     </listitem>
     <listitem>
      <para>By "fake", I mean you can't use the standard <literal>lift</literal> function
                provided by the <function>transformers</function> package, you must use the
                Yesod-supplied one (just like with widgets).</para>
     </listitem>
     <listitem>
      <para>
       <literal>Handler</literal> is just a type synonym around
                    <literal>GHandler</literal>. <literal>GHandler</literal> let's you specify exactly
                which subsite and master site you're using. The <literal>Handler</literal> synonym
                says that the sub and master sites are your application's type.</para>
     </listitem>
     <listitem>
      <para>
       <literal>Handler</literal> provides a lot of different functionality, such as:<itemizedlist>
        <listitem>
         <para>Providing request information.</para>
        </listitem>
        <listitem>
         <para>Keeping a list of the extra response headers you've added.</para>
        </listitem>
        <listitem>
         <para>Allowing you to modify the user's session.</para>
        </listitem>
        <listitem>
         <para>Short-circuiting responses, for redirecting, sending static files, or
                        reporting errors.</para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
    </itemizedlist>
    <para>The remainder of this chapter will give a brief introduction to some of the most
            common functions living in the <literal>Handler</literal> monad. I am specifically <emphasis>not</emphasis> covering any of the session functions; that will be addressed in
            the sessions chapter.</para>
    <section>
     <title>Application Information</title>
     <para/>
     <para>There are a number of functions that return information about your application as a whole, and give no information about individual requests. Some of these are:</para>
     <variablelist>
      <varlistentry>
       <term>getYesod</term>
       <listitem>
        <para>Returns your applicaton foundation value. If you store configuration values in your foundation, you will probably end up using this function a lot.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>getYesodSub</term>
       <listitem>
        <para>Get the subsite foundation value. Unless you are working in a subsite, this will return the same value as <literal>getYesod</literal>.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>getUrlRender</term>
       <listitem>
        <para>Returns the <glossterm>URL rendering function</glossterm>, which converts a type-safe
                    URL into a <literal>Text</literal>. Most of the time- like with Hamlet-
                    Yesod calls this function for you, but you may occassionally need to call it
                    directly.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>getUrlRenderParams</term>
       <listitem>
        <para>A variant of <literal>getUrlRender</literal> that converts both a type-safe URL and a list of query-string parameters. This function handles all percent-encoding necessary.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </section>
    <section>
     <title>Request Information</title>
     <para/>
     <para>The most common information you will want to get about the current request is the
            requested path, the query string parameters and POSTed form data. The first of those is
            dealt with in the routing, as described above. The other two are best dealt with using
            the forms module.</para>
     <para>That said, you will sometimes need to get the data in a more raw format. For this purpose, Yesod exposes the <literal>Request</literal> datatype along with the <literal>getRequest</literal> function to retrieve it. This gives you access to the full list of GET parameters, cookies, and preferred languages. There are some convenient functions to make these lookups easier, such as <literal>lookupGetParam</literal>, <literal>lookupCookie</literal> and <literal>languages</literal>. For raw access to the POST parameters, you should use <literal>runRequest</literal>.</para>
     <para>If you need even more raw data, like request headers, you can use <literal>waiRequest</literal> to access the Web Application Interface (WAI) request value.
            See the WAI appendix for more details.</para>
    </section>
    <section>
     <title>Short Circuiting</title>
     <para/>
     <para>The following functions immediately end execution of a handler function and return a result to the user.</para>
     <variablelist>
      <varlistentry>
       <term>redirect</term>
       <listitem>
        <para>Sends a redirect response to the user (a 303 response). If you want to use a different
                    response code (e.g., a permanent 301 redirect), you can use
                        <literal>redirectWith</literal>.<note>
          <para>Yesod uses a 303 response for HTTP/1.1
                        clients, and a 302 response for HTTP/1.0 clients. You can read up on this
                        sordid saga in the HTTP spec.</para>
         </note>
        </para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>notFound</term>
       <listitem>
        <para>Return a 404 response. This can be useful if a user requests a database value that doesn't exist.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>permissionDenied</term>
       <listitem>
        <para>Return a 403 response with a specific error message.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>invalidArgs</term>
       <listitem>
        <para>A 400 response with a list of invalid arguments.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>sendFile</term>
       <listitem>
        <para>Sends a file from the filesystem with a specified content type. This is the preferred way to send static files, since the underlying WAI handler may be able to optimize this to a <literal>sendfile</literal> system call. Using <literal>readFile</literal> for sending static files should not be necessary.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>sendResponse</term>
       <listitem>
        <para>Send a normal <literal>HasReps</literal> response with a 200 status code. This is really
                    just a convenience for when you need to break out of some deeply nested code
                    with an immediate response.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>sendWaiResponse</term>
       <listitem>
        <para>When you need to get low-level and send out a raw WAI response. This can be
                    especially useful for creating streaming responses or a technique like
                    server-sent events.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </section>
    <section>
     <title>Response Headers</title>
     <para/>
     <variablelist>
      <varlistentry>
       <term>setCookie</term>
       <listitem>
        <para>Set a cookie on the client. Instead of taking an expiration date, this function takes a cookie duration in minutes. Remember, you won't see this cookie using <literal>lookupCookie</literal> until the <emphasis>following</emphasis> request.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>deleteCookie</term>
       <listitem>
        <para>Tells the client to remove a cookie. Once again, <literal>lookupCookie</literal> will not reflect this change until the next request.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>setHeader</term>
       <listitem>
        <para>Set an arbitrary response header.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>setLanguage</term>
       <listitem>
        <para>Set the preferred user language, which will show up in the result of the <literal>languages</literal> function.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>cacheSeconds</term>
       <listitem>
        <para>Set a Cache-Control header to indicate how many seconds this response can be cached. This can be particularly useful if you are using <link xlink:href="http://www.varnish-cache.org">varnish on your server</link>.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>neverExpires</term>
       <listitem>
        <para>Set the Expires header to the year 2037. You can use this with content which should never expire, such as when the request path has a hash value associated with it.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>alreadyExpired</term>
       <listitem>
        <para>Sets the Expires header to the past.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>expiresAt</term>
       <listitem>
        <para>Sets the Expires header to the specified date/time.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </section>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>Routing and dispatch is arguably the core of Yesod: it is from here that our
            type-safe URLs are defined, and the majority of our code is written within the
                <literal>Handler</literal> monad. This chapter covered some of the most important and
            central concepts of Yesod, so it is important that you properly digest it.</para>
    <para>This chapter also hinted at a number of more complex Yesod topics that we will be covering later. But you should be able to write some very sophisticated web applications with just the knowledge you have learned up until here.</para>
   </section>
  </chapter>
  <chapter>
   <title>Forms</title>
   <para/>
   <para/>
   <para>I've mentioned the boundary issue already: whenever data enters or leaves an
   application, we need to validate it. Probably the most difficult place this occurs is forms.
   Coding forms is complex; in an ideal world, we'd like a solution that addresses the following
   problems:</para>
   <itemizedlist>
    <listitem>
     <para>Ensure data is valid.</para>
    </listitem>
    <listitem>
     <para>Marshal string data in the form submission to Haskell datatypes.</para>
    </listitem>
    <listitem>
     <para>Generate HTML code for displaying the form.</para>
    </listitem>
    <listitem>
     <para>Generate Javascript to do clientside validation and provide more user-friendly widgets, such
    as date pickers.</para>
    </listitem>
    <listitem>
     <para>Build up more complex forms by combining together simpler forms.</para>
    </listitem>
    <listitem>
     <para>Automatically assign names to our fields that are guaranteed to be unique.</para>
    </listitem>
   </itemizedlist>
   <para>The <function>yesod-form</function> package provides all these features in a simple, declarative
   API. It builds on top of Yesod's widgets to simplify styling of forms and applying Javascript
   appropriately. And like the rest of Yesod, it uses Haskell's type system to make sure everything
   is working correctly.</para>
   <section>
    <title>Synopsis</title>
    <para/>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, MultiParamTypeClasses,
    OverloadedStrings, TypeFamilies #-}
import Yesod
import Yesod.Form.Jquery
import Data.Time (Day)
import Data.Text (Text)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))

data Synopsis = Synopsis

mkYesod "Synopsis" [parseRoutes|
/ RootR GET
/person PersonR POST
|]

instance Yesod Synopsis

-- Tells our application to use the standard English messages.
-- If you want i18n, then you can supply a translating function instead.
instance RenderMessage Synopsis FormMessage where
    renderMessage _ _ = defaultFormMessage

-- And tell us where to find the jQuery libraries. We'll just use the defaults,
-- which point to the Google CDN.
instance YesodJquery Synopsis

-- The datatype we wish to receive from the form
data Person = Person
    { personName :: Text
    , personBirthday :: Day
    , personFavoriteColor :: Maybe Text
    , personEmail :: Text
    , personWebsite :: Maybe Text
    }
  deriving Show

-- Declare the form. The type signature is a bit intimidating, but here's the
-- overview:
--
-- * The Html parameter is used for encoding some extra information. See the
-- discussion regarding runFormGet and runFormPost below for further
-- explanation.
--
-- * We have the sub and master site types, as usual.
--
-- * FormResult can be in three states: FormMissing (no data available),
-- FormFailure (invalid data) and FormSuccess
--
-- * The Widget is the viewable form to place into the web page.
--
-- Note that the scaffolded site provides a convenient Form type synonym,
-- so that our signature could be written as:
--
-- &gt; personForm :: Form Person
--
-- For our purposes, it's good to see the long version.
personForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Person, Widget)
personForm = renderDivs $ Person
    &lt;$&gt; areq textField "Name" Nothing
    &lt;*&gt; areq (jqueryDayField def
        { jdsChangeYear = True -- give a year dropdown
        , jdsYearRange = "1900:-5" -- 1900 till five years ago
        }) "Birthday" Nothing
    &lt;*&gt; aopt textField "Favorite color" Nothing
    &lt;*&gt; areq emailField "Email address" Nothing
    &lt;*&gt; aopt urlField "Website" Nothing

-- The GET handler displays the form
getRootR :: Handler RepHtml
getRootR = do
    -- Generate the form to be displayed
    (widget, enctype) &lt;- generateFormPost personForm
    defaultLayout [whamlet|
&lt;p&gt;The widget generated contains only the contents of the form, not the form tag itself. So...
&lt;form method=post action=@{PersonR} enctype=#{enctype}&gt;
    ^{widget}
    &lt;p&gt;It also doesn't include the submit button.
    &lt;input type=submit&gt;
|]

-- The POST handler processes the form. If it is successful, it displays the
-- parsed person. Otherwise, it displays the form again with error messages.
postPersonR :: Handler RepHtml
postPersonR = do
    ((result, widget), enctype) &lt;- runFormPost personForm
    case result of
        FormSuccess person -&gt; defaultLayout [whamlet|&lt;p&gt;#{show person}|]
        _ -&gt; defaultLayout [whamlet|
&lt;p&gt;Invalid input, let's try again.
&lt;form method=post action=@{PersonR} enctype=#{enctype}&gt;
    ^{widget}
    &lt;input type=submit&gt;
|]

main :: IO ()
main = warpDebug 3000 Synopsis</programlisting>
   </section>
   <section>
    <title>Kinds of Forms</title>
    <para/>
    <para>Before jumping into the types themselves, we should begin with an overview of the different
   kinds of forms. There are three categories:</para>
    <variablelist>
     <varlistentry>
      <term>Applicative</term>
      <listitem>
       <para>These are the most commonly used (it's what appeared in the synopsis). Applicative
     gives us some nice properties of letting error messages coallesce together and keep a very
     high-level, declarative approach. (For more information on applicative code, see <link xlink:href="http://www.haskell.org/haskellwiki/Applicative_functor">the Haskell wiki</link>.)</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Monadic</term>
      <listitem>
       <para>A more powerful alternative to applicative. While this allows you more flexibility,
     it does so at the cost of being more verbose. Useful if you want to create forms that don't fit
     into the standard two-column look.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Input</term>
      <listitem>
       <para>Used only for receiving input. Does not generate any HTML for receiving the user input.
     Useful for interacting with existing forms.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>In addition, there are a number of different variables that come into play for each form and
   field you will want to set up:</para>
    <itemizedlist>
     <listitem>
      <para>Is the field required or optional?</para>
     </listitem>
     <listitem>
      <para>Should it be submitted with GET or POST?</para>
     </listitem>
     <listitem>
      <para>Does it have a default value, or not?</para>
     </listitem>
    </itemizedlist>
    <para>An overriding goal is to minimize the number of field definitions and let them work in
   as many contexts as possible. One result of this is that we end up with a few extra words for
   each field. In the synopsis, you may have noticed things like <literal>areq</literal> and that
   extra <literal>Nothing</literal> parameter. We'll cover why all of those exist in the course of
   this chapter, but for now realize that by making these parameters explicit, we are able to reuse
   the individuals fields (like <function>intField</function>)
   in many different ways.</para>
    <para>A quick note on naming conventions. Each form type has a one-letter prefix (A, M and I) which
   is used in a few places, such as saying MForm. We also use req and opt to mean required and
   optional. Combining these, we create a required applicative field with <literal>areq</literal>, or
   an optional input field with <literal>iopt</literal>.</para>
   </section>
   <section>
    <title>Types</title>
    <para/>
    <para>The <function>Yesod.Form.Types</function> module declares a few types. Let's start off
   with some simple helpers:</para>
    <variablelist>
     <varlistentry>
      <term>Enctype</term>
      <listitem>
       <para>The encoding type, either <literal>UrlEncoded</literal> or <literal>Multipart</literal>.
     This datatype declares an instance of <literal>ToHtml</literal>, so you can use the enctype
     directly in Hamlet.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Env</term>
      <listitem>
       <para>Maps a parameter name to a list of values.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>FileEnv</term>
      <listitem>
       <para>Maps a parameter name to the associated uploaded file.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Ints</term>
      <listitem>
       <para>As mentioned in the introduction, <literal>yesod-form</literal> automatically assigns
     a unique name to each field. <literal>Ints</literal> is used to keep track of the next number to
     assign.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>FormResult</term>
      <listitem>
       <para>Has one of three possible states: <literal>FormMissing</literal> if no data was
     submitted, <literal>FormFailure</literal> if there was an error parsing the form (e.g., missing a
     required field, invalid content), or <literal>FormSuccess</literal> if everything went
     smoothly.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>Next we have three datatypes used for defining individual fields.</para>
    <note>
     <para>A field is a single piece of information, such as a number, a string or an email address.
   Fields are combined together to build forms.</para>
    </note>
    <variablelist>
     <varlistentry>
      <term>Field</term>
      <listitem>
       <para>Defines two pieces of functionality: how to parse the text input from a user into a
     Haskell value, and how to create the widget to be displayed to the user.
      <literal>yesod-form</literal> defines a number of individual Fields in <function>Yesod.Form.Fields</function>.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>FieldSettings</term>
      <listitem>
       <para>Basic information on how a field should be displayed, such as the display name, an
     optional tooltip, and possibly hardcoded <literal>id</literal> and <literal>name</literal>
     attributes. (If none are provided, they are automatically generated.)<note>
         <para>
          <literal>FieldSettings</literal> provides an <literal>IsString</literal> instance, so when you
      need to provide a <literal>FieldSettings</literal> value, you can actually type in a literal
      string. That's how we interacted with it in the synopsis.</para>
        </note>
       </para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>FieldView</term>
      <listitem>
       <para>An intermediate format containing a bunch of view information on a field. This is hardly
     ever used directly by the user, we'll see more details later.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>And finally, we get to the important stuff: the forms themselves. There are three
   types for this: <literal>MForm</literal> is for monadic forms, <literal>AForm</literal> for
   applicative and <literal>IForm</literal> (declared in <function>IForm</function>) for input. <literal>MForm</literal> is actually a
   type synonym for a monad stack that provides the following features:</para>
    <itemizedlist>
     <listitem>
      <para>A <literal>Reader</literal> monad giving us the parameters (<literal>Env</literal> and
     <literal>FileEnv</literal>), the master site argument and the list of languages the user
    supports. The last two are used for i18n (more on this later).</para>
     </listitem>
     <listitem>
      <para>A <literal>Writer</literal> monad keeping track of the <literal>Enctype</literal>. A
    form will always be <literal>UrlEncoded</literal>, unless there is a file input field, which will
    force us to use multipart instead.</para>
     </listitem>
     <listitem>
      <para>A <literal>State</literal> monad holding an <literal>Ints</literal> to keep track of the
    next unique name to produce.</para>
     </listitem>
    </itemizedlist>
    <para>An <literal>AForm</literal> is pretty similar. However, there are a few major
   differences:</para>
    <itemizedlist>
     <listitem>
      <para>It produces a list of <literal>FieldViews</literal>. This allows us to keep an
    abstract idea of the form display, and then at the end of the day choose an appropriate function
    for laying it out on the page. In the synopsis, we used <literal>renderDivs</literal>, which
    creates a bunch of div tags. Another option would be <literal>renderTable</literal>.</para>
     </listitem>
     <listitem>
      <para>It does not provide a <literal>Monad</literal> instance. The goal of
     <literal>Applicative</literal> is to allow the entire form to run, grab as much information on
    each field as possible, and then create the final result. This cannot work in the context of
     <literal>Monad</literal>.</para>
     </listitem>
    </itemizedlist>
    <para>An <literal>IForm</literal> is even simpler: it returns either a list of error messages
   or a result.</para>
   </section>
   <section>
    <title>Converting</title>
    <para/>
    <para>"But wait a minute," you say. "You said the synopsis uses applicative forms, but I'm
   sure the type signature said <literal>MForm</literal>. Shouldn't it be Monadic?" That's true, the
   final form we produced was monadic. But what really happened is that we converted an applicative
   form to a monadic one.</para>
    <para>Again, our goal is to reuse code as much as possible, and minimize the number of
   functions in the API. And Monadic forms are more powerful than Applicative, if more clumsy, so
   anything that can be expressed in an Applicative form could also be expressed in a Monadic form.
   There are two core functions that help out with this: <literal>aformToForm</literal> converts any
   applicative form to a monadic one, and <literal>formToAForm</literal> converts certain kinds of
   monadic forms to applicative forms.</para>
    <para>"But wait <emphasis role="bold">another</emphasis> minute," you insist. "I didn't see any
    <literal>aformToForm</literal>!" Also true. The <literal>renderDivs</literal> function takes care of
   that for us.</para>
   </section>
   <section>
    <title>Create AForms</title>
    <para/>
    <para>Now that I've (hopefully) convinced you that in our synopsis we were really dealing with
   applicative forms, let's have a look and try to understand how these things get created. Let's
   take a simple example:</para>
    <programlisting language="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    }
  deriving Show

carAForm :: AForm Synopsis Synopsis Car
carAForm = Car
    &lt;$&gt; areq textField "Model" Nothing
    &lt;*&gt; areq intField "Year" Nothing

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable carAForm
</programlisting>
    <para>Here, we've explicitly split up applicative and monadic forms. In <literal>carAForm</literal>, we use the <literal>&lt;$&gt;</literal> and <literal>&lt;*&gt;</literal> operators. This should not be surprising; these are
            almost always used in applicative-style code. And we have one line for each record in
            our <literal>Car</literal> datatype. Perhaps unsurprisingly, we have a <literal>textField</literal> for the <literal>Text</literal> record, and an
                <literal>intField</literal> for the <literal>Int</literal>
            record.</para>
    <para>Let's look a bit more closely at the <literal>areq</literal> function. Its (simplified)
            type signature is <literal>Field a -&gt; FieldSettings -&gt; Maybe a -&gt; AForm
                a</literal>. So that first argument is going to determine the datatype of this field,
            how to parse it, and how to render it. The next argument,
            <literal>FieldSettings</literal>, tells us the label, tooltip, name and ID of the field.
            In this case, we're using the previously-mentioned <literal>IsString</literal> instance of
                <literal>FieldSettings</literal>.</para>
    <para>And what's up with that <literal>Maybe a</literal>? It provides the optional default
            value. For example, if we want our form to fill in "2007" as the default car year, we
            would use <literal>areq intField "Year" (Just 2007)</literal>. We can even take
            this to the next level, and have a form that takes an optional parameter giving the
            default values.</para>
    <figure xml:id="create-aforms-x9">
     <title>Form with default values</title>
     <programlisting language="haskell">carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq intField "Year" (carYear &lt;$&gt; mcar)
</programlisting>
    </figure>
    <section>
     <title>Optional fields</title>
     <para/>
     <para>Suppose we wanted to have an optional field (like the car color). All we do instead is
            use the <literal>aopt</literal> function.</para>
     <figure xml:id="optional-fields-x2">
      <title>Optional fields</title>
      <programlisting language="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Text
    }
  deriving Show

carAForm :: AForm Synopsis Synopsis Car
carAForm = Car
    &lt;$&gt; areq textField "Model" Nothing
    &lt;*&gt; areq intField "Year" Nothing
    &lt;*&gt; aopt textField "Color" Nothing
</programlisting>
     </figure>
     <para>And like required fields, the last argument is the optional default value. However,
            this has two layers of Maybe wrapping. This may seem redundant (and it is), but it makes
            it much easier to write code that takes an optional default form parameter, such as in
            the next example.</para>
     <figure xml:id="optional-fields-x6">
      <title>Default optional fields</title>
      <programlisting language="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Text
    }
  deriving Show

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq intField  "Year"  (carYear  &lt;$&gt; mcar)
    &lt;*&gt; aopt textField "Color" (carColor &lt;$&gt; mcar)

carForm :: Html -&gt; MForm Synopsis Synopsis (FormResult Car, Widget)
carForm = renderTable $ carAForm $ Just $ Car "Forte" 2010 $ Just "gray"
</programlisting>
     </figure>
    </section>
   </section>
   <section>
    <title>Validation</title>
    <para/>
    <para>How would we make our form only accept cars created after 1990? If you remember, we
            said above that the <literal>Field</literal> itself contained the information on what is a
            valid entry. So all we need to do is write a new <literal>Field</literal>, right? Well,
            that would be a bit tedious. Instead, let's just modify an existing one:</para>
    <programlisting language="haskell">carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField    "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year"  (carYear  &lt;$&gt; mcar)
    &lt;*&gt; aopt textField    "Color" (carColor &lt;$&gt; mcar)
  where
    errorMessage :: Text
    errorMessage = "Your car is too old, get a new one!"

    carYearField = check validateYear intField

    validateYear y
        | y &lt; 1990 = Left errorMessage
        | otherwise = Right y
</programlisting>
    <para>The trick here is the <literal>check</literal> function. It takes a function
                (<literal>validateYear</literal>) that returns either an error message or a modified
            field value. In this example, we haven't modified the value at all. That is usually
            going to be the case. This kind of checking is very common, so we have a shortcut:</para>
    <programlisting language="haskell">    carYearField = checkBool (&gt;= 1990) errorMessage intField
</programlisting>
    <para>
     <literal>checkBool</literal> takes two parameters: a condition that must be fulfilled,
            and an error message to be displayed if it was not.</para>
    <note>
     <para>You may have noticed the explicit <literal>Text</literal> type signature on
                <literal>errorMessage</literal>. In the presence of
            <literal>OverloadedStrings</literal>, this is necessary. In order to support i18n,
            messages can have many different datatypes, and GHC has no way of determining which
            instance of <literal>IsString</literal> you intended to use.</para>
    </note>
    <para>It's great to make sure the car isn't too old. But what if we want to make sure that
            the year specified is not from the future? In order to look up the current year, we'll
            need to run some <literal>IO</literal>. For such circumstances, we'll need
                <literal>checkM</literal>:</para>
    <programlisting language="haskell">    carYearField = checkM inPast $ checkBool (&gt;= 1990) errorMessage intField

    inPast y = do
        thisYear &lt;- liftIO getCurrentYear
        return $ if y &lt;= thisYear
            then Right y
            else Left ("You have a time machine!" :: Text)

getCurrentYear :: IO Int
getCurrentYear = do
    now &lt;- getCurrentTime
    let today = utctDay now
    let (year, _, _) = toGregorian today
    return $ fromInteger year
</programlisting>
    <para>
     <literal>inPast</literal> is a function that will return an <literal>Either</literal>
            result. However, it uses a <literal>Handler</literal> monad. We use <literal>liftIO getCurrentYear</literal> to get the current year and then compare it against
            the user-supplied year. Also, notice how we can chain together multiple validators.</para>
    <note>
     <para>Since the <literal>checkM</literal> validator runs in the <literal>Handler</literal>
            monad, it has access to a lot of the stuff you can normally do in Yesod. This is
            especially useful for running database actions, which we'll cover in the Persistent
                chapter.</para>
    </note>
   </section>
   <section>
    <title>More sophisticated fields</title>
    <para/>
    <para>Our color entry field is nice, but it's not exactly user-friendly. What we really want
            is a drop-down list.</para>
    <figure xml:id="more-sophiticated-fields-x2">
     <title>Drop-down lists</title>
     <programlisting language="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year" (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (selectFieldList colors) "Color" (carColor &lt;$&gt; mcar)
  where
    colors :: [(Text, Color)]
    colors = [("Red", Red), ("Blue", Blue), ("Gray", Gray), ("Black", Black)]
</programlisting>
    </figure>
    <para>
     <literal>selectFieldList</literal> takes a list of pairs. The first item in the pair is
            the text displayed to the user in the drop-down list, and the second item is the actual
            Haskell value. Of course, the code above looks really repetitive; we can get the same
            result using the Enum and Bounded instance GHC automatically derives for us.</para>
    <figure xml:id="more-sophiticated-fields-x6">
     <title>Uses Enum and Bounded</title>
     <programlisting language="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year" (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (selectFieldList colors) "Color" (carColor &lt;$&gt; mcar)
  where
    colors = map (pack . show &amp;&amp;&amp; id) $ [minBound..maxBound]
</programlisting>
    </figure>
    <para>
     <literal>[minBound..maxBound]</literal> gives us a list of all the different
                <literal>Color</literal> values. We then apply a <literal>map</literal> and
                <literal>&amp;&amp;&amp;</literal> (a.k.a, the fan-out operator) to turn that into a
            list of pairs.</para>
    <para>Some people prefer radio buttons to drop-down lists. Fortunately, this is just a
            one-word change. For example, see Radio buttons</para>
    <figure xml:id="more-sophiticated-fields-radio-buttons">
     <title>Radio buttons</title>
     <programlisting language="haskell">data Car = Car
    { carModel :: Text
    , carYear :: Int
    , carColor :: Maybe Color
    }
  deriving Show

data Color = Red | Blue | Gray | Black
    deriving (Show, Eq, Enum, Bounded)

carAForm :: Maybe Car -&gt; AForm Synopsis Synopsis Car
carAForm mcar = Car
    &lt;$&gt; areq textField "Model" (carModel &lt;$&gt; mcar)
    &lt;*&gt; areq carYearField "Year" (carYear &lt;$&gt; mcar)
    &lt;*&gt; aopt (radioFieldList colors) "Color" (carColor &lt;$&gt; mcar)
  where
    colors = map (pack . show &amp;&amp;&amp; id) $ [minBound..maxBound]
</programlisting>
    </figure>
   </section>
   <section>
    <title>Running forms</title>
    <para/>
    <para>At some point, we're going to need to take our beautiful forms and produce some results. There
   are a number of different functions available for this, each with its own purpose. I'll go
   through them, starting with the most common.</para>
    <variablelist>
     <varlistentry>
      <term>runFormPost</term>
      <listitem>
       <para>This will run your form against any submitted <literal>POST</literal>
     parameters. If this is not a <literal>POST</literal> submission, it will return a
      <literal>FormMissing</literal>. This automatically inserts a security token as a hidden
     form field to avoid <link xlink:href="http://en.wikipedia.org/wiki/Cross-site_request_forgery">CSRF</link> attacks.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>runFormGet</term>
      <listitem>
       <para>Same as <literal>runFormPost</literal>, for GET parameters. In order to
     distinguish a normal <literal>GET</literal> page load from a <literal>GET</literal> submission, it includes an extra <literal>_hasdata</literal> hidden field
     in the form.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>runFormPostNoNonce</term>
      <listitem>
       <para>Same as <literal>runFormPost</literal>, but does not include (or require) the CSRF
     security token.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>generateFormPost</term>
      <listitem>
       <para>Instead of binding to existing <literal>POST</literal> parameters, acts as if there
     are none. This can be useful when you want to generate a new form after a previous form was
     submitted, such as in a wizard.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>generateFormGet</term>
      <listitem>
       <para>Same as <literal>generateFormPost</literal>, but for <literal>GET</literal>.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>The return type from the first three is <literal>((FormResult a, Widget),
    Enctype)</literal>. The <literal>Widget</literal> will already have any validation errors and
   previously submitted values.</para>
   </section>
   <section>
    <title>i18n</title>
    <para/>
    <para>There have been a few references to i18n in this chapter. The topic will get more
   thorough coverage in its
    own chapter, but since it has such a profound effect on <literal>yesod-form</literal>, I
   wanted to give a brief overview. The idea behind i18n in Yesod is to have data types represent
   messages. Each site can have an instance of <literal>RenderMessage</literal> for a given datatype
   which will translate that message based on a list of languages the user accepts. As a result of
   all this, there are a few things you should be aware of:</para>
    <itemizedlist>
     <listitem>
      <para>There is an automatic instance of <literal>RenderMessage</literal> for
     <literal>Text</literal> in every site, so you can just use plain strings if you don't care about
    i18n support. However, you may need to use explicit type signatures occassionally.</para>
     </listitem>
     <listitem>
      <para>
       <literal>yesod-form</literal> expresses all of its messages in terms of the
     <literal>FormMessage</literal> datatype. Therefore, to use <literal>yesod-form</literal>, you'll
    need to have an appropriate <literal>RenderMessage</literal> instance. A simple one that uses the
    default English translations would
    be:<programlisting language="haskell">instance RenderMessage MyApp FormMessage where
    renderMessage _ _ = defaultFormMessage</programlisting>This
    is provided automatically by the scaffolded site.</para>
     </listitem>
<!-- Perhaps include this later? <li id="x5">In order to allow multiple different message types to co-exist, we use an existential
    type called <codeph id="x-12">SomeMessage</codeph>. You will occassionally need to wrap your values inside
    of it, though this is not common in normal library use.</li>-->
    </itemizedlist>
   </section>
   <section>
    <title>Monadic Forms</title>
    <para/>
    <para>Often times, a simple form layout is adequate, and applicative forms excel at
            this approach. Sometimes, however, you'll want to have a more customized look to your
            form.</para>
    <figure xml:id="monadic-x-4">
     <title>A non-standard form layout</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/forms-09/monadic-form.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <para>For these use cases, monadic forms fit the bill. They are a bit more verbose
            than their applicative cousins, but this verbosity allows you to have complete control
            over what the form will look like. In order to generate the form above, we could code
            something like this.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, MultiParamTypeClasses #-}
import Yesod
import Control.Applicative
import Data.Text (Text)

data MFormExample = MFormExample

mkYesod "MFormExample" [parseRoutes|
/ RootR GET
|]

instance Yesod MFormExample

instance RenderMessage MFormExample FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person { personName :: Text, personAge :: Int }
    deriving Show

personForm :: Html -&gt; MForm MFormExample MFormExample (FormResult Person, Widget)
personForm extra = do
    (nameRes, nameView) &lt;- mreq textField "this is not used" Nothing
    (ageRes, ageView) &lt;- mreq intField "neither is this" Nothing
    let personRes = Person &lt;$&gt; nameRes &lt;*&gt; ageRes
    let widget = do
            toWidget [lucius|
##{fvId ageView} {
    width: 3em;
}
|]
            [whamlet|
#{extra}
&lt;p&gt;
    Hello, my name is #
    ^{fvInput nameView}
    \ and I am #
    ^{fvInput ageView}
    \ years old. #
    &lt;input type=submit value="Introduce myself"&gt;
|]
    return (personRes, widget)

getRootR :: Handler RepHtml
getRootR = do
    ((res, widget), enctype) &lt;- runFormGet personForm
    defaultLayout [whamlet|
&lt;p&gt;Result: #{show res}
&lt;form enctype=#{enctype}&gt;
    ^{widget}
|]

main :: IO ()
main = warpDebug 3000 MFormExample</programlisting>
    <para>Similar to the applicative <literal>areq</literal>, we use <literal>mreq</literal> for monadic forms. (And yes, there's also
                <literal>mopt</literal> for optional fields.) But there's a big difference:
                <literal>mreq</literal> gives us back a pair of values. Instead of hiding away the
                <function>FieldView</function> value and
            automatically inserting it into a widget, we get the control to insert it as we see
            fit.</para>
    <para>
     <literal>FieldView</literal> has a number of pieces of information. The most
            important is <literal>fvInput</literal>, which is the actual form field. In this example,
            we also use <literal>fvId</literal>, which gives us back the HTML <literal>id</literal>
            attribute of the input tag. In our example, we use that to specify the width of the
            field.</para>
    <para>You might be wondering what the story is with the "this is not used" and
            "neither is this" values. <literal>mreq</literal> takes a <literal>FieldSettings</literal> as its second argument. Since <literal>FieldSettings</literal>
            provides an <literal>IsString</literal> instance, the strings are essentially expanded by
            the compiler
            to:<programlisting language="haskell">fromString "this is not used" == FieldSettings
    { fsLabel = "this is not used"
    , fsTooltip = Nothing
    , fsId = Nothing
    , fsName = Nothing
    , fsClass = []
    }</programlisting>In
            the case of applicative forms, the <literal>fsLabel</literal> and
                <literal>fsTooltip</literal> values are used when constructing your HTML. In the case
            of monadic forms, Yesod does not generate any of the "wrapper" HTML for you, and
            therefore these values are ignored. However, we still keep the
                <literal>FieldSettings</literal> parameter to allow you to override the
                <literal>id</literal> and <literal>name</literal> attributes of your fields if
            desired.</para>
    <para>The other interesting bit is the <literal>extra</literal> value.
                <literal>GET</literal> forms include an extra field to indicate that they
            have been submitted, and <literal>POST</literal> forms include a security tokens
            to prevent CSRF attacks. If you don't include this extra hidden field in your form,
            Yesod will not accept it.</para>
    <para>Other than that, things are pretty straight-forward. We create our
                <literal>personRes</literal> value by combining together the <literal>nameRes</literal>
            and <literal>ageRes</literal> values, and then return a tuple of the person and the
            widget. And in the <literal>getRootR</literal> function, everything looks just like an
            applicative form. In fact, you could swap out our monadic form with an applicative one
            and the code would still work.</para>
   </section>
   <section>
    <title>Input forms</title>
    <para/>
    <para>Applicative and monadic forms handle both the generation of your HTML code and the parsing of
   user input. Sometimes, you only want to do the latter, such as when there's an already-existing
   form in HTML somewhere, or if you want to generate a form dynamically using Javascript. In such a
   case, you'll want input forms.</para>
    <para>These work mostly the same as applicative and monadic forms, with some differences:</para>
    <itemizedlist>
     <listitem>
      <para>You use <literal>runInputPost</literal> and <literal>runInputGet</literal>.</para>
     </listitem>
     <listitem>
      <para>You use <literal>ireq</literal> and <literal>iopt</literal>. These functions now only
    take two arguments: the field type and the name (i.e., HTML <literal>name</literal> attribute) of
    the field in question.</para>
     </listitem>
     <listitem>
      <para>After running a form, it returns the value. It doesn't return a widget or an
                encoding type.</para>
     </listitem>
     <listitem>
      <para>If there are any validation errors, the page returns an "invalid arguments" error page.</para>
     </listitem>
    </itemizedlist>
    <para>You can use input forms to recreate the previous example. Note, however, that the
   input version is less user friendly. If you make a mistake in an applicative or monadic form, you
   will be brought back to the same page, with your previously entered values in the form, and an
   error message explaning what you need to correct. With input forms, the user simply gets an error
   message.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, MultiParamTypeClasses #-}
import Yesod
import Control.Applicative
import Data.Text (Text)

data Input = Input

mkYesod "Input" [parseRoutes|
/ RootR GET
/input InputR GET
|]

instance Yesod Input

instance RenderMessage Input FormMessage where
    renderMessage _ _ = defaultFormMessage

data Person = Person { personName :: Text, personAge :: Int }
    deriving Show

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;form action=@{InputR}&gt;
    &lt;p&gt;
        My name is #
        &lt;input type=text name=name&gt;
        \ and I am #
        &lt;input type=text name=age&gt;
        \ years old. #
        &lt;input type=submit value="Introduce myself"&gt;
|]

getInputR :: Handler RepHtml
getInputR = do
    person &lt;- runInputGet $ Person
                &lt;$&gt; ireq textField "name"
                &lt;*&gt; ireq intField "age"
    defaultLayout [whamlet|&lt;p&gt;#{show person}|]

main :: IO ()
main = warpDebug 3000 Input</programlisting>
   </section>
   <section>
    <title>Custom fields</title>
    <para/>
    <para>The fields that come built-in with Yesod will likely cover the vast majority of your
   form needs. But occassionally, you'll need something more specialized. Fortunately, you can
   create new forms in Yesod yourself. The <literal>Field</literal> datatype has two records:
    <literal>fieldParse</literal> takes a list of values submitted by the user and returns one of
   three results:</para>
    <itemizedlist>
     <listitem>
      <para>An error message saying validation failed.</para>
     </listitem>
     <listitem>
      <para>The parsed value.</para>
     </listitem>
     <listitem>
      <para>Nothing, indicating that no data was supplied.</para>
     </listitem>
    </itemizedlist>
    <para>That last case might sound surprising: shouldn't Yesod automatically know that no information
   is supplied when the input list is empty? Well, no actually. Checkboxes, for instance, indicate
   an unchecked state by sending in an empty list.</para>
    <para>Also, what's up with the list? Shouldn't it be a <literal>Maybe</literal>? Well, that's
   also not the case. With grouped checkboxes and multi-select lists, you'll have multiple widgets
   with the same name. We also use this trick in our example below.</para>
    <para>The second record is <literal>fieldView</literal>, and it renders a widget to display to
   the user. This function has four arguments: the <literal>id</literal> attribute, the
    <literal>name</literal> attribute, the result and a <literal>Bool</literal> indicating if the field
   is required.</para>
    <para>What did I mean by result? It's actually an <literal>Either</literal>, giving either
   the unparsed input (when parsing failed) or the successfully parsed value.
    <literal>intField</literal> is a great example of how this works. If you type in <userinput>42</userinput>, the value of result will be <literal>Right 42</literal>. But
   if you type in <userinput>turtle</userinput>, the result will be <literal>Left
    "turtle"</literal>. This lets you put in a value attribute on your input tag that will give the
   user a consistent experience.</para>
    <para>As a small example, we'll create a new field type that is a password confirm field.
            This field has two text inputs- both with the same name attribute- and returns an error
            message if the values don't match. Note that, unlike most fields, it does <emphasis>not</emphasis> provide a value attribute on the input tags, as you don't want to send back
            a user-entered password in your HTML <emphasis role="bold">ever</emphasis>.</para>
    <programlisting language="haskell">passwordConfirmField :: Field sub master Text
passwordConfirmField = Field
    { fieldParse = \rawVals -&gt;
        case rawVals of
            [a, b]
                | a == b -&gt; return $ Right $ Just a
                | otherwise -&gt; return $ Left "Passwords don't match"
            [] -&gt; return $ Right Nothing
            _ -&gt; return $ Left "You must enter two values"
    , fieldView = \idAttr nameAttr _ eResult isReq -&gt; [whamlet|
&lt;input id=#{idAttr} name=#{nameAttr} type=password&gt;
&lt;div&gt;Confirm:
&lt;input id=#{idAttr}-confirm name=#{nameAttr} type=password&gt;
|]
    }

getRootR :: Handler RepHtml
getRootR = do
    ((res, widget), enctype) &lt;- runFormGet $ renderDivs
        $ areq passwordConfirmField "Password" Nothing
    defaultLayout [whamlet|
&lt;p&gt;Result: #{show res}
&lt;form enctype=#{enctype}&gt;
    ^{widget}
    &lt;input type=submit value="Change password"&gt;
|]
</programlisting>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>Forms in Yesod are broken up into three groups. Applicative is the most common, as it provides
   a nice user interface with an easy-to-use API. Monadic forms give you more power, but are harder
   to use. Input forms are intended when you just want to read data from the user, not generate the
   input widgets.</para>
    <para>There are a number of different <literal>Field</literal>s provided by Yesod out-of-the-box. In
   order to use these in your forms, you need to indicate the kind of form and whether the field is
   required or optional. The result is six helper functions: <literal>areq</literal>,
    <literal>aopt</literal>, <literal>mreq</literal>, <literal>mopt</literal>, <literal>ireq</literal>, and
    <literal>iopt</literal>.</para>
    <para>Forms have significant power available. They can automatically insert Javascript to help you
   leverage nicer UI controls, such as a jQuery UI date picker. Forms are also fully i18n-ready, so
   you can support a global community of users. And when you have more specific needs, you can slap
   on some validation functions to an existing field, or write a new one from scratch.</para>
   </section>
  </chapter>
  <chapter>
   <title>Sessions</title>
   <para/>
   <para/>
   <para>HTTP is a stateless protocol. While some view this as a disadvantage, advocates of
            RESTful web development laud this as an plus. When state is removed from the picture, it
            is easier to scale applications, caching can happen automatically, and many other nice
            side effects occur. You can draw many parallels with the non-mutable nature of Haskell
            in general.</para>
   <para>As much as possible, RESTful applications should avoid storing state about an interaction
            with a client. However, it is sometimes unavoidable. Features like shopping carts are
            the classic example, but other more mundane interactions like proper login handling can
            be greatly enhanced by proper usage of sessions.</para>
   <para>This chapter will describe how Yesod stores session data,
            how you can access this data, and some special functions to help
            you make the most of sessions.</para>
   <section>
    <title>Clientsession</title>
    <para/>
    <para>One of the earliest packages spun off from Yesod was <function>clientsession</function>. This package uses encryption and signatures to store data
            in a client-side cookie. The encryption prevents the user from inspecting the data, and
            the signature ensures that the session can be neither hijacked nor tampered with.</para>
    <para>It might sound like a bad idea from an efficiency
            standpoint to store data in a cookie: after all, this means that
            the data must be sent on every request. However, in practice,
            clientsession can be a great boon for performance.</para>
    <itemizedlist>
     <listitem>
      <para>No server side database lookup is required to service a request.</para>
     </listitem>
     <listitem>
      <para>We can easily scale horizontally: each request contains all the information we need to send a response.</para>
     </listitem>
     <listitem>
      <para>To avoid undue bandwidth overhead, production sites can serve their static content from
                a separate domain name to avoid the overhead of transmitting the session cookie for
                each request.</para>
     </listitem>
    </itemizedlist>
    <para>Storing megabytes of information in the session will be a bad idea. But for that matter,
            most session implementations recommend against such practices. If you really need
            massive storage for a user, it is best to store a lookup key in the session, and put the
            actual data in a database.</para>
    <para>All of the interaction with clientsession is handled by Yesod internally, but there are a
            few spots where you can tweak the behavior just a bit.</para>
   </section>
   <section>
    <title>Controlling sessions</title>
    <para/>
    <para>There are three functions in the Yesod typeclass that control how sessions work.
                <function>encryptKey</function> returns the encryption key used.
            By default, it will take this from a local file, so that sessions can persist between
            database shutdowns. This file will be automatically created and filled with random data
            if it does not exist. And if you override this function to return <literal>Nothing</literal>, sessions will be disabled.</para>
    <note>
     <para>Why disable sessions? They <emphasis role="bold">do</emphasis> introduce a
                performance overhead. Under normal circumstances, this overhead
                is minimal, especially compared to database access. However,
                when dealing with very basic tasks, the overhead can become
                noticeable. But be careful about disabling sessions: this will
                also disable such features as 
                    CSRF (Cross-Site Request Forgery) protection.</para>
    </note>
    <para>The next function is <function>clientSessionDuration</function>. This function gives the
            number of minutes that a session should be active. The default is 120 (2 hours).</para>
    <para>This value ends up affecting the session cookie in two ways:
            firstly, it determines the expiration date for the cookie itself.
            More importantly, however, the session expiration timestamp is
            encoded inside the session signature. When Yesod decodes the
            signature, it checks if the date is in the past; if so, it ignores
            the session values.</para>
    <note>
     <para>Every time Yesod sends a response to the client, it
                sends an updated session cookie with a new expire date. This
                way, even if you do not change the session values themselves, a
                session will not time out if the user continues to browse your
                site.</para>
    </note>
    <para>And this leads very nicely to the last function: <function>sessionIpAddress</function>. By default, Yesod also encodes
            the client's IP address inside the cookie to prevent session hijacking. In general, this
            is a good thing. However, some ISPs are known for putting their users behind proxies
            that rewrite their IP addresses, sometimes changing the source IP in the middle of the
            session. If this happens, and you have <literal>sessionIpAddress</literal> enabled, the
            user's session will be reset. Turning this setting to <literal>False</literal> will allow
            a session to continue under such circumstances, at the cost of exposing a user to
            session hijacking.</para>
   </section>
   <section>
    <title>Session Operations</title>
    <para/>
    <para>Like most frameworks, a session in Yesod is a key-value store. The base session API boils
            down to four functions: <literal>lookupSession</literal> gets a value for a key
            (if available), <literal>getSession</literal> returns all of the key/value pairs, <literal>setSession</literal> sets a value for a key, and <literal>deleteSession</literal> clears a value for a key.</para>
    <programlisting language="haskell">{-# LANGUAGE TypeFamilies, QuasiQuotes, TemplateHaskell, MultiParamTypeClasses, OverloadedStrings #-}
import Yesod
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import qualified Web.ClientSession as CS

data SessionExample = SessionExample

mkYesod "SessionExample" [parseRoutes|
/ Root GET POST
|]

getRoot :: Handler RepHtml
getRoot = do
    sess &lt;- getSession
    hamletToRepHtml [hamlet|
&lt;form method=post&gt;
    &lt;input type=text name=key&gt;
    &lt;input type=text name=val&gt;
    &lt;input type=submit&gt;
&lt;h1&gt;#{show sess}
|]

postRoot :: Handler ()
postRoot = do
    (key, mval) &lt;- runInputPost $ (,) &lt;$&gt; ireq textField "key" &lt;*&gt; iopt textField "val"
    case mval of
        Nothing -&gt; deleteSession key
        Just val -&gt; setSession key val
    liftIO $ print (key, mval)
    redirect Root

instance Yesod SessionExample where
    -- Make the session timeout 1 minute so that it's easier to play with
    makeSessionBackend _ = do
        key &lt;- CS.getKey CS.defaultKeyFile
        return $ Just $ clientSessionBackend key 1

instance RenderMessage SessionExample FormMessage where
    renderMessage _ _ = defaultFormMessage

main :: IO ()
main = warpDebug 3000 SessionExample</programlisting>
   </section>
   <section>
    <title>Messages</title>
    <para/>
    <para>One usage of sessions previously alluded to is messages. They come to solve a common
            problem in web development: the user performs a <literal>POST</literal> request, the web
            app makes a change, and then the web app wants to <emphasis>simultaneously</emphasis> redirect
            the user to a new page and send the user a success message. (This is known as
            Post/Redirect/Get.)</para>
    <para>Yesod provides a pair of functions to make this very easy:
            <literal>setMessage</literal> stores a value in the session, and
            <literal>getMessage</literal> both reads the value most recently put into
            the session, and clears the old value so it does not accidently get
            displayed twice.</para>
    <para>It is recommended to have a call to <literal>getMessage</literal> in <literal>defaultLayout</literal> so that any available message is shown to a user
            immediately, without having to remember to add <literal>getMessage</literal> calls to
            every handler.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, MultiParamTypeClasses #-}
import Yesod

data Messages = Messages

mkYesod "Messages" [parseRoutes|
/ RootR GET
/set-message SetMessageR POST
|]

instance Yesod Messages where
    defaultLayout widget = do
        pc &lt;- widgetToPageContent widget
        mmsg &lt;- getMessage
        hamletToRepHtml [hamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        ^{pageHead pc}
    &lt;body&gt;
        $maybe msg &lt;- mmsg
            &lt;p&gt;Your message was: #{msg}
        ^{pageBody pc}
|]

instance RenderMessage Messages FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;form method=post action=@{SetMessageR}&gt;
    My message is: #
    &lt;input type=text name=message&gt;
    &lt;input type=submit&gt;
|]

postSetMessageR :: Handler ()
postSetMessageR = do
    msg &lt;- runInputPost $ ireq textField "message"
    setMessage $ toHtml msg
    redirect RootR

main :: IO ()
main = warpDebug 3000 Messages</programlisting>
    <figure xml:id="messages-x-4">
     <title>Initial page load, no message</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/sessions/messages-1.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <figure xml:id="messages-x-6">
     <title>New message entered in text box</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/sessions/messages-2.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <figure xml:id="messages-x-8">
     <title>After form submit, message appears at top of page</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/sessions/messages-3.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <figure xml:id="messages-x-10">
     <title>After refresh, the message is cleared</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/sessions/messages-4.png"/>
      </imageobject>
     </mediaobject>
    </figure>
   </section>
   <section>
    <title>Ultimate Destination</title>
    <para/>
    <para>Not to be confused with a horror film, this concept is used internally in <function>yesod-auth</function>. Suppose a user requests a page that requires
            authentication. If the user is not yet logged in, you need to send him/her to the login
            page. A well-designed web app will then <emphasis>send them back to the first page they
                requested</emphasis>. That's what we call the ultimate destination.</para>
    <para>
     <literal>redirectUltDest</literal> sends the user to the ultimate destination set
            in his/her session, clearing that value from the session. It takes a default destination
            as well, in case there is no destination set. For setting the session, there are three
                options:<itemizedlist>
      <listitem>
       <para>
        <literal>setUltDest</literal> sets the destination to the given URL</para>
      </listitem>
      <listitem>
       <para>
        <literal>setUltDestCurrent</literal> sets the destination to the currently
                    requested URL.</para>
      </listitem>
      <listitem>
       <para>
        <literal>setUltDestReferer</literal> sets the destination based on the
                        <literal>Referer</literal> header (the page that led the user to the current
                    page).</para>
      </listitem>
     </itemizedlist>
    </para>
    <para>Let's look at a small sample app. It will allow the user to set his/her name in the
            session, and then tell the user his/her name from another route. If the name hasn't been
            set yet, the user will be redirected to the set name page, with an ultimate destination
            set to come back to the current page.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, MultiParamTypeClasses #-}
import Yesod

data UltDest = UltDest

mkYesod "UltDest" [parseRoutes|
/ RootR GET
/setname SetNameR GET POST
/sayhello SayHelloR GET
|]

instance Yesod UltDest

instance RenderMessage UltDest FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR = defaultLayout [whamlet|
&lt;p&gt;
    &lt;a href=@{SetNameR}&gt;Set your name
&lt;p&gt;
    &lt;a href=@{SayHelloR}&gt;Say hello
|]

-- Display the set name form
getSetNameR = defaultLayout [whamlet|
&lt;form method=post&gt;
    My name is #
    &lt;input type=text name=name&gt;
    . #
    &lt;input type=submit value="Set name"&gt;
|]

-- Retreive the submitted name from the user
postSetNameR :: Handler ()
postSetNameR = do
    -- Get the submitted name and set it in the session
    name &lt;- runInputPost $ ireq textField "name"
    setSession "name" name

    -- After we get a name, redirect to the ultimate destination.
    -- If no destination is set, default to the homepage
    redirectUltDest RootR

getSayHelloR = do
    -- Lookup the name value set in the session
    mname &lt;- lookupSession "name"
    case mname of
        Nothing -&gt; do
            -- No name in the session, set the current page as
            -- the ultimate destination and redirect to the
            -- SetName page
            setUltDestCurrent
            setMessage "Please tell me your name"
            redirect SetNameR
        Just name -&gt; defaultLayout [whamlet|
&lt;p&gt;Welcome #{name}
|]

main :: IO ()
main = warpDebug 3000 UltDest</programlisting>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>Sessions are the number one way we bypass the statelessness imposed by HTTP. We
            shouldn't consider this an escape hatch to perform whatever actions we want:
            statelessness in web applications is a virtue, and we should respect it whenever
            possible. However, there are specific cases where it is vital to retain some state.</para>
    <para>The session API in Yesod is very simple. It provides a key-value store, and a few
            convenience functions built on top for common use cases. If used properly, with small
            payloads, sessions should be an unobtrusive part of your web development.</para>
   </section>
  </chapter>
  <chapter>
   <title>Persistent</title>
   <para/>
   <para/>
   <para>Forms deal with the boundary between the user and the application. Another boundary we
            need to deal with is between the application and the storage layer. Whether it be a SQL
            database, a YAML file, or a binary blob, odds are you have to work to get your storage
            layer to accept your application datatypes. Persistent is Yesod's answer to data
            storage- a type-safe, universal data store interface for Haskell. </para>
   <para>Haskell has many different database bindings available. However, most of these have
            little knowledge of a schema and therefore do not provide useful static guarantees. They
            also force database-dependent APIs and data types on the programmer. Haskellers have
            attempted a more revolutionary route of creating Haskell specific data stores to get
            around these flaws that allow one to easily store any Haskell type. These options are
            great for certain use cases, but they constrain one to the storage techniques provided
            by the library, do not interface well with other languages, and the flexibility can also
            mean one must write reams of code for querying data. In contrast, Persistent allows us
            to choose among existing databases that are highly tuned for different data storage use
            cases, interoperate with other programming languages, and to use a safe and productive
            query interface. </para>
   <para>Persistent follows the guiding principles of type safety and concise, declarative syntax. Some other nice features are:</para>
   <itemizedlist>
    <listitem>
     <para>Database-agnostic. There is first class support for PostgreSQL, SQLite and MongoDB, with
                experimental CouchDB and MySQL support in the works.</para>
    </listitem>
    <listitem>
     <para>By being non-relational in nature, we simultaneously are able to support a wider number of storage layers and are not constrained by some of the performance bottlenecks incurred through joins.</para>
    </listitem>
    <listitem>
     <para>A major source of frustration in dealing with SQL databases is changes to the schema. Persistent can automatically perform database migrations.</para>
    </listitem>
   </itemizedlist>
<!-- still want to cover:
        
        Advanced: select enumerator interface (maybe)
        Join modules
    -->
   <section>
    <title>Synopsis</title>
    <para/>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TemplateHaskell, TypeFamilies, OverloadedStrings #-}
{-# LANGUAGE GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    deriving Show
BlogPost
    title String
    authorId PersonId
    deriving Show
|]

main :: IO ()
main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll

    johnId &lt;- insert $ Person "John Doe" $ Just 35
    janeId &lt;- insert $ Person "Jane Doe" Nothing

    insert $ BlogPost "My fr1st p0st" johnId
    insert $ BlogPost "One more for good measure" johnId

    oneJohnPost &lt;- selectList [BlogPostAuthorId ==. johnId] [LimitTo 1]
    liftIO $ print (oneJohnPost :: [Entity BlogPost])

    john &lt;- get johnId
    liftIO $ print (john :: Maybe Person)

    delete janeId
    deleteWhere [BlogPostAuthorId ==. johnId]</programlisting>
   </section>
   <section>
    <title>Solving the boundary issue</title>
    <para/>
    <para>Suppose you are storing information on people in a SQL database. Your table might look
            something like:</para>
    <programlisting>CREATE TABLE Person(id SERIAL PRIMARY KEY, name VARCHAR NOT NULL, age INTEGER)</programlisting>
    <para>And if you are using a database like PostgreSQL, you can be guaranteed that the database will never store some arbitrary text in your age field. (The same cannot be said of SQLite, but let's forget about that for now.) To mirror this database table, you would likely create a Haskell datatype that looks something like:</para>
    <programlisting language="haskell">data Person = Person
    { personName :: Text
    , personAge :: Int
    }</programlisting>
    <para>It looks like everything is type safe: the database schema matches our Haskell datatypes, the database ensures that invalid data can never make it into our data store, and everything is generally awesome. Well, until:</para>
    <itemizedlist>
     <listitem>
      <para>You want to pull data from the database, and the database layer gives you the data in an untyped format.</para>
     </listitem>
     <listitem>
      <para>You want to find everyone older than 32, and you accidently write "thirtytwo" in your SQL statement. Guess what: that will compile just fine, and you won't find out you have a problem until runtime.</para>
     </listitem>
     <listitem>
      <para>You decide you want to find the first 10 people alphabetically. No problem... until you
                make a typo in your SQL. Once again, you don't find out until runtime.</para>
     </listitem>
    </itemizedlist>
    <para>In dynamic languages, the answers to these issues is unit testing. For everything that <emphasis>can</emphasis> go wrong, make sure you write a test case. But as I am sure you are aware by now, that doesn't jive well with the Yesod approach to things. We like to take advantage of Haskell's strong typing to save us wherever possible, and data storage is no exception.</para>
    <para>So the question remains: how can we use Haskell's type system to save the day?</para>
    <section>
     <title>Types</title>
     <para/>
     <para>Like routing, there is nothing intrinsically difficult about type-safe data access. It
            just requires a lot of monotonous, error prone, boiler plate code. As usual, this means
            we can use the type system to keep us honest. And to avoid some of the drudgery, we'll
            use a sprinkling of Template Haskell.</para>
     <note>
      <para>Earlier versions of Persistent made much heavier usage of Template Haskell. Starting
            with 0.6, there is a new architecture inspired by the <function>groundhog</function>
            package. This approach uses phantom types to carry a lot of the burden.</para>
     </note>
     <para>
      <literal>PersistValue</literal> is the basic building block of Persistent. It is a
            sum type that can represent data that gets sent to and from a database. Its definition
            is:</para>
     <programlisting language="haskell">data PersistValue = PersistText Text
                  | PersistByteString ByteString
                  | PersistInt64 Int64
                  | PersistDouble Double
                  | PersistBool Bool
                  | PersistDay Day
                  | PersistTimeOfDay TimeOfDay
                  | PersistUTCTime UTCTime
                  | PersistNull
                  | PersistList [PersistValue]
                  | PersistMap [(T.Text, PersistValue)]
                  | PersistForeignKey ByteString -- ^ intended especially for MongoDB backend</programlisting>
     <para>Each Persistent backend needs to know how to translate the relevant values into
            something the database can understand. However, it would be awkward do have to express
            all of our data simply in terms of these basic types. The next layer is the <literal>PersistField</literal> typeclass, which defines how an arbitrary Haskell
            datatype can be marshaled to and from a <literal>PersistValue</literal>. A
                <literal>PersistField</literal> correlates to a column in a SQL database. In our
            person example above, name and age would be our <literal>PersistField</literal>s.</para>
     <para>To tie up the user side of the code, our last typeclass is <literal>PersistEntity</literal>. An instance of PersistEntity correlates with a table in a
            SQL database. This typeclass defines a number of functions and some associated types. To
            review, we have the following correspondence between Persistent and SQL:</para>
     <table>
      <title/>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>SQL</entry>
         <entry>Persistent</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>Datatypes (VARCHAR, INTEGER, etc)</entry>
         <entry>PersistValue</entry>
        </row>
        <row>
         <entry>Column</entry>
         <entry>PersistField</entry>
        </row>
        <row>
         <entry>Table</entry>
         <entry>PersistEntity</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
    </section>
    <section>
     <title>Code Generation</title>
     <para/>
     <para>In order to ensure that the PersistEntity instances match up properly with your Haskell datatypes, Persistent takes responsibility for both. This is also good from a DRY (Don't Repeat Yourslef) perspective: you only need to define your entities once. Let's see a quick example:</para>
     <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

mkPersist sqlSettings [persist|
Person
    name String
    age Int
    deriving Show
|]
</programlisting>
     <para>We use a combination of Template Haskell and Quasi-Quotation (like when defining
            routes): <function>persist</function> is a
            quasi-quoter which converts a whitespace-sensitive syntax into a list of entity
            definitions. (You can also declare your entities in a separate file using
                <function>persistFile</function>.)
                <function>mkPersist</function> takes that list
            of entities and declares:</para>
     <itemizedlist>
      <listitem>
       <para>One Haskell datatype for each entity.</para>
      </listitem>
      <listitem>
       <para>A <literal>PersistEntity</literal> instance for each datatype defined.</para>
      </listitem>
     </itemizedlist>
     <para>The example above generates code that looks like the following:</para>
     <programlisting language="haskell">{-# LANGUAGE TypeFamilies, GeneralizedNewtypeDeriving, OverloadedStrings, GADTs #-}
import Database.Persist
import Database.Persist.Store
import Database.Persist.Sqlite
import Database.Persist.EntityDef
import Control.Monad.IO.Class (liftIO)
import Control.Applicative

data Person = Person
    { personName :: String
    , personAge :: Int
    }
  deriving (Show, Read, Eq)

type PersonId = Key SqlPersist Person

instance PersistEntity Person where
    -- A Generalized Algebraic Datatype (GADT).
    -- This gives us a type-safe approach to matching fields with
    -- their datatypes.
    data EntityField Person typ where
        PersonId   :: EntityField Person PersonId
        PersonName :: EntityField Person String
        PersonAge  :: EntityField Person Int

    type PersistEntityBackend Person = SqlPersist

    toPersistFields (Person name age) =
        [ SomePersistField name
        , SomePersistField age
        ]

    fromPersistValues [nameValue, ageValue] = Person
        &lt;$&gt; fromPersistValue nameValue
        &lt;*&gt; fromPersistValue ageValue
    fromPersistValues _ = Left "Invalid fromPersistValues input"

    -- Information on each field, used internally to generate SQL statements
    persistFieldDef PersonId = FieldDef
        (HaskellName "Id")
        (DBName "id")
        (FTTypeCon Nothing "PersonId")
        []
    persistFieldDef PersonName = FieldDef
        (HaskellName "name")
        (DBName "name")
        (FTTypeCon Nothing "String")
        []
    persistFieldDef PersonAge = FieldDef
        (HaskellName "age")
        (DBName "age")
        (FTTypeCon Nothing "Int")
        []
</programlisting>
     <para>As you might expect, our <literal>Person</literal> datatype closely matches the definition
            we gave in the original Template Haskell version. We also have a Generalized Algebraic
            Datatype (GADT) which gives a separate constructor for each field. This GADT encodes
            both the type of the entity and the type of the field. We use its constructors
            throughout Persistent, such as to ensure that when we apply a filter, the types of the
            filtering value match the field.</para>
     <para>We can use the generated <literal>Person</literal> type like any other Haskell type, and
            then pass it off to other Persistent functions.</para>
     <programlisting language="haskell">main = withSqliteConn ":memory:" $ runSqlConn $ do
    michaelId &lt;- insert $ Person "Michael" 26
    michael &lt;- get michaelId
    liftIO $ print michael
</programlisting>
     <para>We start off with some standard database connection code. In this case, we used the single-connection functions. Persistent also comes built in with connection pool functions, which we will generally want to use in production.</para>
     <para>In this example, we have seen two functions: <literal>insert</literal> creates a new
            record in the database and returns its ID. Like everything else in Persistent, IDs are
            type safe. We'll get into more details of how these IDs work later. So when you call
                <literal>insert $ Person "Michael" 25</literal>, it gives you a value back of
            type <literal>PersonId</literal>.</para>
     <para>The next function we see is <literal>get</literal>, which attempts to load a value from
            the database using an <literal>Id</literal>. In Persistent, you never need to
            worry that you are using the key from the wrong table: trying to load up a different
            entity (like <literal>House</literal>) using a <literal>PersonId</literal> will
            never compile.</para>
    </section>
    <section>
     <title>PersistStore</title>
     <para/>
     <para>One last detail is left unexplained from the previous example: what are those
                <literal>withSqliteConn</literal> and <literal>runSqlConn</literal> functions doing, and
            what is that monad that our database actions are running in?</para>
     <para>All database actions need to occur within an instance of <literal>PersistStore</literal>. As its name implies, every data store (PostgreSQL, SQLite,
            MongoDB) has an instance of <literal>PersistStore</literal>. This is where all the
            translations from <literal>PersistValue</literal> to database-specific values
            occur, where SQL query generation happens, and so on.</para>
     <note>
      <para>As you can imagine, even though <literal>PersistStore</literal> provides a safe,
                well-typed interface to the outside world, there are a lot of database interactions
                that could go wrong. However, by testing this code automatically and thoroughly in a
                single location, we can centralize our error-prone code and make sure it is as
                bug-free as possible.</para>
     </note>
     <para>
      <literal>withSqliteConn</literal> creates a single connection to a database using its
            supplied connection string. For our test cases, we will use <literal>:memory:</literal>,
            which uses an in-memory database. <literal>runSqlConn</literal> uses that connection to
            run the inner action. Both SQLite and PostgreSQL share the same instance of
                <literal>PersistStore</literal>: <literal>SqlPersist</literal>.</para>
     <note>
      <para>There are actually a few other typeclasses: <literal>PersistUpdate</literal> and
                <literal>PersistQuery</literal>. Different typeclasses provide different
            functionality, which allows us to write backends that use simpler data stores (e.g.,
            Redis) even though they can't provide us all the high-level functionality available in
            Persistent.</para>
     </note>
     <para>One important thing to note is that everything which occurs inside a single call to
                <literal>runSqlConn</literal> runs in a single transaction. This has two important
            implications:</para>
     <itemizedlist>
      <listitem>
       <para>For many databases, committing a transaction can be a costly activity. By putting multiple steps into a single transaction, you can speed up code dramatically.</para>
      </listitem>
      <listitem>
       <para>If an exception is thrown anywhere inside a single call to <literal>runSqlConn</literal>,
                all actions will be rolled back (assuming your backend has rollback support).</para>
      </listitem>
     </itemizedlist>
    </section>
   </section>
   <section>
    <title>Migrations</title>
    <para/>
    <para>I'm sorry to tell you, but so far I have lied to you a bit: the example from the previous section does not actually work. If you try to run it, you will get an error message about a missing table.</para>
    <para>For SQL databases, one of the major pains can be managing schema changes. Instead of leaving this to the user, Persistent steps in to help, but you have to <emphasis>ask</emphasis> it to help. Let's see what this looks like:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.TH
import Database.Persist.Sqlite
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkSave "entityDefs"] [persist|
Person
    name String
    age Int
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration $ migrate entityDefs (undefined :: Person) -- this line added: that's it!
    michaelId &lt;- insert $ Person "Michael" 26
    michael &lt;- get michaelId
    liftIO $ print michael
</programlisting>
    <para>With this one little code change, Persistent will automatically create your
                <literal>Person</literal> table for you. This split between
                <literal>runMigration</literal> and <literal>migrate</literal> allows you to migrate
            multiple tables simultaneously.</para>
    <para>This works when dealing with just a few entities, but can quickly get tiresome once we
            are dealing with a dozen entities. Instead of repeating yourself, Persistent provides a
            helper function, <literal>mkMigrate</literal>:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int
    deriving Show
Car
    color String
    make String
    model String
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
</programlisting>
    <para>
     <literal>mkMigrate</literal> is a Template Haskell function which creates a new function
            that will automatically call <literal>migrate</literal> on all entities defined in the
                <literal>persist</literal> block. The <literal>share</literal> function is just a little
            helper that passes the information from the persist block to each Template Haskell
            function and concatenates the results.</para>
    <para>Persistent has very conservative rules about what it will do during a migration. It
            starts by loading up table information from the database, complete with all defined SQL
            datatypes. It then compares that against the entity definition given in the code. For
            the following cases, it will automatically alter the schema:</para>
    <itemizedlist>
     <listitem>
      <para>The datatype of a field changed. However, the database may object to this modification if the data cannot be translated.</para>
     </listitem>
     <listitem>
      <para>A field was added. However, if the field is not null, no default value is supplied (we'll discuss defaults later) and there is already data in the database, the database will not allow this to happen.</para>
     </listitem>
     <listitem>
      <para>A field is converted from not null to null. In the opposite case, Persistent will attempt the conversion, contingent upon the database's approval.</para>
     </listitem>
     <listitem>
      <para>A brand new entity is added.</para>
     </listitem>
    </itemizedlist>
    <para>However, there are some cases that Persistent will not handle:</para>
    <itemizedlist>
     <listitem>
      <para>Field or entity renames: Persistent has no way of knowing that "name" has now been renamed to "fullName": all it sees is an old field called name and a new field called fullName.</para>
     </listitem>
     <listitem>
      <para>Field removals: since this can result in data loss, Persistent by default will refuse
                to perform the action (you can force the issue by using
                    <literal>runMigrationUnsafe</literal> instead of <literal>runMigration</literal>,
                though it is <emphasis role="bold">not</emphasis> recommended).</para>
     </listitem>
    </itemizedlist>
    <para>
     <literal>runMigration</literal> will print out the migrations it is running on
                <literal>stderr</literal> (you can bypass this by using
                <literal>runMigrationSilent</literal>). Whenever possible, it uses <literal>ALTER
                TABLE</literal> calls. However, in SQLite, <literal>ALTER TABLE</literal> has very
            limited abilities, and therefore Persistent must resort to copying the data from one
            table to another.</para>
    <para>Finally, if instead of <emphasis>performing</emphasis> a migration, you want Persistent to
            give you hints about what migrations are necessary, use the
                <literal>printMigration</literal> function. This function will print out the
            migrations which <literal>runMigration</literal> would perform for you. This may be useful
            for performing migrations that Persistent is not capable of, for adding arbitrary SQL to
            a migration, or just to log what migrations occurred.</para>
   </section>
   <section>
    <title>Uniqueness</title>
    <para/>
    <para>In addition to declaring fields within an entity, you can also declare uniqueness
            constraints. A typical example would be requiring that a username be unique.</para>
    <figure xml:id="uniqueness-x1">
     <title>Unique Username</title>
     <programlisting>User
    username Text
    UniqueUsername username</programlisting>
    </figure>
    <para>While each field name must begin with a lowercase letter, the uniqueness constraints must
            begin with an uppercase letter.</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class (liftIO)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    firstName String
    lastName String
    age Int
    PersonName firstName lastName
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    insert $ Person "Michael" "Snoyman" 26
    michael &lt;- getBy $ PersonName "Michael" "Snoyman"
    liftIO $ print michael
</programlisting>
    <para>To declare a unique combination of fields, we add an extra line to our declaration. Persistent knows that it is defining a unique constructor, since the line begins with a capital letter. Each following word must be a field in this entity.</para>
    <para>The main restriction on uniqueness is that it can only be applied non-null fields. The
            reason for this is that the SQL standard is ambiguous on how uniqueness should be
            applied to <literal>NULL</literal> (e.g., is <literal>NULL=NULL</literal> true or false?).
            Besides that ambiguity, most SQL engines in fact implement rules which would be <emphasis>contrary</emphasis> to what the Haskell datatypes anticipate (e.g., PostgreSQL says
            that <literal>NULL=NULL</literal> is false, whereas Haskell says <literal>Nothing ==
                Nothing</literal> is <literal>True</literal>).</para>
    <para>In addition to providing nice guarantees at the database level about consistency
            of your data, uniqueness constraints can also be used to perform some specific queries
            within your Haskell code, like the <literal>getBy</literal> demonstrated above.
            This happens via the <literal>Unique</literal> associated type. In the example
            above, we end up with a new constructor:</para>
    <programlisting language="haskell">PersonName :: String -&gt; String -&gt; Unique Person</programlisting>
   </section>
   <section>
    <title>Queries</title>
    <para/>
    <para>Depending on what your goal is, there are different approaches to querying the database.
            Some commands query based on a numeric ID, while others will filter. Queries also differ
            in the number of results they return: some lookups should return no more than one result
            (if the lookup key is unique) while others can return many results.</para>
    <para>Persistent therefore provides a few different query functions. As usual, we try to encode
            as many invariants in the types as possible. For example, a query that can return only 0
            or 1 results will use a <literal>Maybe</literal> wrapper, whereas a query returning many
            results will return a list.</para>
    <section>
     <title>Fetching by ID</title>
     <para/>
     <para>The simplest query you can perform in Persistent is getting based on an ID. Since this
   value may or may not exist, its return type is wrapped in a <literal>Maybe</literal>.</para>
     <figure xml:id="fetching-by-id-x2">
      <title>Using get</title>
      <programlisting language="haskell">    personId &lt;- insert $ Person "Michael" "Snoyman" 26
    maybePerson &lt;- get personId
    case maybePerson of
        Nothing -&gt; liftIO $ putStrLn "Just kidding, not really there"
        Just person -&gt; liftIO $ print person
</programlisting>
     </figure>
     <para>This can be very useful for sites that provide URLs like <filename>/person/5</filename>. However, in such a case, we don't usually care about the
    <literal>Maybe</literal> wrapper, and just want the value, returning a 404 message if it is not
   found. Fortunately, the <function>get404</function> function
   helps us out here. We'll go into more details when we see integration with Yesod.</para>
    </section>
    <section>
     <title>Fetching by unique constraint</title>
     <para/>
     <para>
      <literal>getBy</literal> is almost identical to <literal>get</literal>, except it takes a
            uniqueness constraint instead of an ID it takes a Unique value.</para>
     <figure xml:id="fetching-by-unique-constraint-x2">
      <title>Using getBy</title>
      <programlisting language="haskell">    personId &lt;- insert $ Person "Michael" "Snoyman" 26
    maybePerson &lt;- getBy $ UniqueName "Michael" "Snoyman"
    case maybePerson of
        Nothing -&gt; liftIO $ putStrLn "Just kidding, not really there"
        Just person -&gt; liftIO $ print person
</programlisting>
     </figure>
     <para>Like <literal>get404</literal>, there is also a <literal>getBy404</literal> function.</para>
    </section>
    <section>
     <title>Select functions</title>
     <para/>
     <para>Most likely, you're going to want more powerful queries. You'll want to find everyone
   over a certain age; all cars available in blue; all users without a registered email address. For
   this, you need one of the select functions.</para>
     <para>All the select functions use a similar interface, with slightly different outputs:</para>
     <table>
      <title/>
      <tgroup cols="2">
       <thead>
        <row>
         <entry>Function</entry>
         <entry>Returns</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry>selectSource</entry>
         <entry>A <literal>Source</literal> containing all the IDs and values from the database.
     This allows you to write streaming code.<note>
           <para>We cover <literal>Source</literal>s in detail in
      the conduits appendix.
      Additionally, there's another function called <literal>selectSourceConn</literal> which allows
      you more control of connection allocation. We use this in the Sphinx case
       study.</para>
          </note>
         </entry>
        </row>
        <row>
         <entry>selectList</entry>
         <entry>A list containing all the IDs and values from the database. All records will
     be loaded into memory.</entry>
        </row>
        <row>
         <entry>selectFirst</entry>
         <entry>Takes just the first ID and value from the database, if available</entry>
        </row>
        <row>
         <entry>selectKeys</entry>
         <entry>Returns only the keys, without the values, as a
     <literal>Source</literal>.</entry>
        </row>
       </tbody>
      </tgroup>
     </table>
     <para>
      <literal>selectList</literal> is the most commonly used, so we will cover it
   specifically. Understanding the others should be trivial after that.</para>
     <para>
      <literal>selectList</literal> takes two arguments: a list of <literal>Filter</literal>s,
   and a list of <literal>SelectOpt</literal>s. The former is what limits your results based on
   characteristics; it allows for equals, less than, is member of, and such.
    <literal>SelectOpt</literal>s provides for three different features: sorting, limiting output to a
   certain number of rows, and offsetting results by a certain number of rows.</para>
     <note>
      <para>The combination of limits and offsets is very important; it allows for efficient
   pagination in your webapps.</para>
     </note>
     <para>Let's jump straight into an example of filtering, and then analyze it.</para>
     <programlisting language="haskell">    people &lt;- selectList [PersonAge &gt;. 25, PersonAge &lt;=. 30] []
    liftIO $ print people
</programlisting>
     <para>As simple as that example is, we really need to cover three points:</para>
     <orderedlist>
      <listitem>
       <para>
        <literal>PersonAge</literal> is a constructor for an associated phantom type. That
    might sound scary, but what's important is that it uniquely identifies the "age" column of the
    "person" table, and that it knows that the age field is an <literal>Int</literal>. (That's the
    phantom part.)</para>
      </listitem>
      <listitem>
       <para>We have a bunch of Persistent filtering operators. They're all pretty straight-forward: just
    tack a period to the end of what you'd expect. There are three gotchas here, I'll explain
    below.</para>
      </listitem>
      <listitem>
       <para>The list of filters is ANDed together, so that our constraint means "age is greater than 25
    AND age is less than or equal to 30". We'll describe ORing later.</para>
      </listitem>
     </orderedlist>
     <para>The one operator that's surprisingly named is "not equals." We use
    <literal>!=.</literal>, since <literal>/=.</literal> is used for updates (for "divide-and-set",
   described later). Don't worry: if you use the wrong one, the compiler will catch you. The other
   two surprising operators are the "is member" and "is not member". They are, respectively, <literal>&lt;-.</literal> and <literal>/&lt;-.</literal> (both end with a period).</para>
     <para>And regarding ORs, we use the <literal>||.</literal> operator. For example:</para>
     <programlisting language="haskell">    people &lt;- selectList
        (       [PersonAge &gt;. 25, PersonAge &lt;=. 30]
            ||. [PersonFirstName /&lt;-. ["Adam", "Bonny"]]
            ||. ([PersonAge ==. 50] ||. [PersonAge ==. 60])
        )
        []
    liftIO $ print people
</programlisting>
     <para>This (completely nonsensical) example means: find people who are 26-30, inclusive, OR whose
   names are neither Adam or Bonny, OR whose age is either 50 or 60.</para>
     <section>
      <title>SelectOpt</title>
      <para/>
      <para>All of our <literal>selectList</literal> calls have included an empty list as the second
   parameter. That specifies no options, meaning: sort however the database wants, return all
   results, and don't skip any results. A <literal>SelectOpt</literal> has four constructors that can
   be used to change all that.</para>
      <variablelist>
       <varlistentry>
        <term>Asc</term>
        <listitem>
         <para>Sort by the given column in ascending order. This uses the same phantom type as
     filtering, such as <literal>PersonAge</literal>.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>Desc</term>
        <listitem>
         <para>Same as <literal>Asc</literal>, in descending order.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>LimitTo</term>
        <listitem>
         <para>Takes an <literal>Int</literal> argument. Only return up to the specified number of
     results.</para>
        </listitem>
       </varlistentry>
       <varlistentry>
        <term>OffsetBy</term>
        <listitem>
         <para>Takes an <literal>Int</literal> argument. Skip the specified number of results.</para>
        </listitem>
       </varlistentry>
      </variablelist>
      <para>The following code defines a function that will break down results into pages. It returns all
   people aged 18 and over, and then sorts them by age (oldest person first). For people with the
   same age, they are sorted alphabetically by last name, then first name.</para>
      <programlisting language="haskell">resultsForPage pageNumber = do
    let resultsPerPage = 10
    selectList
        [ PersonAge &gt;=. 18
        ]
        [ Desc PersonAge
        , Asc PersonLastName
        , Asc PersonFirstName
        , LimitTo resultsPerPage
        , OffsetBy $ (pageNumber - 1) * resultsPerPage
        ]
</programlisting>
     </section>
    </section>
   </section>
   <section>
    <title>Manipulation</title>
    <para/>
    <para>Querying is only half the battle. We also need to be able to add data to and modify
            existing data in the database.</para>
    <section>
     <title>Insert</title>
     <para/>
     <para>It's all well and good to be able to play with data in the database, but how does it
   get there in the first place? The answer is the <literal>insert</literal> function. You just give
   it a value, and it gives back an ID.</para>
     <para>At this point, it makes sense to explain a bit of the philosophy behind Persistent. In
   many other ORM solutions, the datatypes used to hold data are opaque: you need to go through
   their defined interfaces to get at and modify the data. That's not the case with Persistent:
   we're using plain old Algebraic Data Types for the whole thing. This means you still get all the
   great benefits of pattern matching, currying and everything else you're used to.</para>
     <para>However, there are a few things we <emphasis>can't</emphasis> do. For one, there's no way to automatically
   update values in the database every time the record is updated in Haskell. Of course, with
   Haskell's normal stance of purity and immutability, this wouldn't make much sense anyway, so I
   don't shed any tears over it.</para>
     <para>However, there is one issue that newcomers are often bothered by: why are IDs and values
   completely separate? It seems like it would be very logical to embed the ID inside the value. In
   other words, instead of
   having:<programlisting language="haskell">data Person = Person { name :: String }</programlisting>have<programlisting language="haskell">data Person = Person { personId :: PersonId, name :: String }</programlisting>
     </para>
     <para>Well, there's one problem with this right off the bat: how do we do an
    <literal>insert</literal>? If a Person needs to have an ID, and we get the ID by inserting, and an
   insert needs a Person, we have an impossible loop. We could solve this with
    <literal>undefined</literal>, but that's just asking for trouble.</para>
     <para>OK, you say, let's try something a bit
   safer:<programlisting language="haskell">data Person = Person { personId :: Maybe PersonId, name :: String }</programlisting>I
   definitely prefer <literal>insert $ Person Nothing "Michael"</literal> to <literal>insert $ Person undefined "Michael"</literal>. And now our types will be much simpler, right?
   For example, <literal>selectList</literal> could return a simple <literal>[Person]</literal>
   instead of that ugly <literal>[Entity SqlPersist Person]</literal>.</para>
     <note>
      <para>
       <literal>Entity</literal> is a datatype that ties together both the ID and value of an entity.
   Since IDs can be different based on backend, we also need to provide the Persistent backend we're
   using. The datatype <literal>Entity SqlPersist Person</literal> can be read as "the ID and value of
   a person stored in a SQL database."</para>
     </note>
     <para>The problem is that the "ugliness" is incredibly useful. Having <literal>Entity SqlPersist Person</literal> makes it obvious, at the type level, that we're dealing with
   a value that exists in the database. Let's say we want to create a link to another page that
   requires the <literal>PersonId</literal> (not an uncommon occurrence as we'll discuss
   later). The <literal>Entity SqlPersist Person</literal> form gives us unambiguous access to that
   information; embedding <literal>PersonId</literal> within <literal>Person</literal> with a
    <literal>Maybe</literal> wrapper means an extra runtime check for <literal>Just</literal>, instead
   of a more error-proof compile time check.</para>
     <para>Finally, there's a semantic mismatch with embedding the ID within the value. The
    <literal>Person</literal> is the value. Two people are identical (in the context of a
   database) if all their fields are the same. By embedding the ID in the value, we're no longer
   talking about a person, but about a row in the database. Equality is no longer really equality,
   it's identity: is this the <emphasis>same person</emphasis>, as opposed to an equivalent person.</para>
     <para>In other words, there are some annoyances with having the ID separated out, but overall, it's
   the <emphasis>right</emphasis> approach, which in the grand scheme of things leads to better, less buggy
   code.</para>
    </section>
    <section>
     <title>Update</title>
     <para/>
     <para>Now, in the context of that discussion, let's think about updating. The simplest way to
            update
            is:<programlisting language="haskell">let michael = Person "Michael" 26
    michaelAfterBirthday = michael { personAge = 27 }</programlisting>But
            that's not actually updating anything, it's just creating a new <literal>Person</literal>
            value based on the old one. When we say update, we're <emphasis>not</emphasis> talking about
            modifications to the values in Haskell. (We better not be of course, since Haskell data
            types are immutable.)</para>
     <para>Instead, we're looking at ways of modifying rows in a table. And the simplest way to do
            that is with the <literal>update</literal> function.</para>
     <programlisting language="haskell">    personId &lt;- insert $ Person "Michael" "Snoyman" 26
    update personId [PersonAge =. 27]
</programlisting>
     <para>
      <literal>update</literal> takes two arguments: an ID, and a list of <literal>Update</literal>s. The simplest update is assignment, but it's not always
            the best. What if you want to increase someone's age by 1, but you don't have their
            current age? Persistent has you covered:</para>
     <programlisting language="haskell">haveBirthday personId = update personId [PersonAge +=. 1]
</programlisting>
     <para>And as you might expect, we have all the basic mathematical operators:
                <literal>+=.</literal>, <literal>-=.</literal>, <literal>*=.</literal>, and
                <literal>/=.</literal> (full stop). These can be convenient for updating a single
            record, but they are also essential for proper ACID guarantees. Imagine the alternative:
            pull out a <literal>Person</literal>, increment the age, and update the new value. If you
            have two threads/processes working on this database at the same time, you're in for a
            world of hurt (hint: race conditions).</para>
     <para>Sometimes you'll want to update many fields at once (give all your employees a 5% pay
            increase, for example). <literal>updateWhere</literal> takes two parameters: a list of
            filters, and a list of updates to apply.</para>
     <programlisting language="haskell">    updateWhere [PersonFirstName ==. "Michael"] [PersonAge *=. 2] -- it's been a long day
</programlisting>
     <para>Occassionally, you'll just want to completely replace the value in a database with a
            different value. For that, you use (surprise) the <literal>replace</literal> function.</para>
     <programlisting language="haskell">    personId &lt;- insert $ Person "Michael" "Snoyman" 26
    replace personId $ Person "John" "Doe" 20
</programlisting>
    </section>
    <section>
     <title>Delete</title>
     <para/>
     <para>As much as it pains us, sometimes we must part with our data. To do so, we have three
   functions:</para>
     <variablelist>
      <varlistentry>
       <term>delete</term>
       <listitem>
        <para>Delete based on an ID</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>deleteBy</term>
       <listitem>
        <para>Delete based on a unique constraint</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>deleteWhere</term>
       <listitem>
        <para>Delete based on a set of filters</para>
       </listitem>
      </varlistentry>
     </variablelist>
     <programlisting language="haskell">    personId &lt;- insert $ Person "Michael" "Snoyman" 26
    delete personId
    deleteBy $ UniqueName "Michael" "Snoyman"
    deleteWhere [PersonFirstName ==. "Michael"]
</programlisting>
     <para>We can even use deleteWhere to wipe out all the records in a table, we just need to give some
   hints to GHC as to what table we're interested in:</para>
     <programlisting language="haskell">    deleteWhere ([] :: [Filter Person])
</programlisting>
    </section>
   </section>
   <section>
    <title>Attributes</title>
    <para/>
    <para>So far, we have seen a basic syntax for our <literal>persist</literal> blocks: a line
            for the name of our entities, and then an indented line for each field with two words:
            the name of the field and the datatype of the field. Persistent handles more than this:
            you can assign an arbitrary list of attributes after the first two words on a line.</para>
    <para>Suppose we want to have a <literal>Person</literal> entity with an (optional) age and
            the timestamp of when he/she was added to the system. For entities already in the
            database, we want to just use the current date-time for that timestamp.</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time
import Control.Monad.IO.Class

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    created UTCTime default=now()
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    time &lt;- liftIO getCurrentTime
    runMigration migrateAll
    insert $ Person "Michael" (Just 26) time
    insert $ Person "Greg" Nothing time
</programlisting>
    <para>
     <literal>Maybe</literal> is a built in, single word attribute. It makes the
            field optional. In Haskell, this means it is wrapped in a <literal>Maybe</literal>. In
            SQL, it makes the column nullable.</para>
    <para>The <literal>default</literal> attribute is backend specific, and uses
            whatever syntax is understood by the database. In this case, it uses the database's
            built-in <literal>now()</literal> function. Suppose that we now want to add a
            field for a person's favorite programming language:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    created UTCTime default=now()
    language String default='Haskell'
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
</programlisting>
    <note>
     <para>The <literal>default</literal> attribute has absolutely no impact on the Haskell code itself; you still need to fill in all values. This will only affect the database schema and automatic migrations.</para>
    </note>
    <para>We need to surround the string with single quotes so that the database can properly
            interpret it. Finally, Persistent can use double quotes for containing white space, so
            if we want to set someone's default home country to be El Salvador:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    age Int Maybe
    created UTCTime default=now()
    language String default='Haskell'
    country String "default='El Salvador'"
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
</programlisting>
    <para>One last trick you can do with attributes is to specify the names to be used for
            the SQL tables and columns. This can be convenient when interacting with existing
            databases.</para>
    <programlisting language="haskell">share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person sql=the-person-table
    firstName String sql=first_name
    lastName String sql=fldLastName
    age Int Gt Desc "sql=The Age of the Person"
    UniqueName firstName lastName
    deriving Show
|]
</programlisting>
   </section>
   <section>
    <title>Relations</title>
    <para/>
    <para>Persistent allows references between your data types in a manner that is consistent with
            supporting non-SQL databases. We do this by embedding an ID in the related entity. So if
            a person has many cars:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Control.Monad.IO.Class (liftIO)
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    deriving Show
Car
    ownerId PersonId Eq
    name String
    deriving Show
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    bruce &lt;- insert $ Person "Bruce Wayne"
    insert $ Car bruce "Bat Mobile"
    insert $ Car bruce "Porsche"
    -- this could go on a while
    cars &lt;- selectList [CarOwnerId ==. bruce] []
    liftIO $ print cars
</programlisting>
    <para>Using this technique, you can define one-to-many relationships. To define many-to-many
            relationships, we need a join entity, which has a one-to-many relationship with each of
            the original tables. It is also a good idea to use uniqueness constraints on these. For
            example, to model a situation where we want to track which people have shopped in which
            stores:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
Store
    name String
PersonStore
    personId PersonId
    storeId StoreId
    UniquePersonStore personId storeId
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll

    bruce &lt;- insert $ Person "Bruce Wayne"
    michael &lt;- insert $ Person "Michael"

    target &lt;- insert $ Store "Target"
    gucci &lt;- insert $ Store "Gucci"
    sevenEleven &lt;- insert $ Store "7-11"

    insert $ PersonStore bruce gucci
    insert $ PersonStore bruce sevenEleven

    insert $ PersonStore michael target
    insert $ PersonStore michael sevenEleven
</programlisting>
   </section>
   <section>
    <title>Closer look at types</title>
    <para/>
    <para>So far, we've spoken about <literal>Person</literal> and <literal>PersonId</literal>
   without really explaining what they are. In the simplest sense, for a SQL-only system, the
    <literal>PersonId</literal> could just be <literal>type PersonId = Int64</literal>. However,
   that means there is nothing binding a <literal>PersonId</literal> at the type level to the
    <literal>Person</literal> entity. As a result, you could accidently use a
    <literal>PersonId</literal> and get a <literal>Car</literal>. In order to model this relationship,
   we use phantom types. So, our next naive step would be:</para>
    <programlisting language="haskell">newtype Key entity = Key Int64
type PersonId = Key Person</programlisting>
    <note>
     <para>Prior to Persistent 0.6, we used associated types instead of phantom types. You could solve
   the problem in that direction as well, but phantoms worked out better.</para>
    </note>
    <para>And that works out really well, until you get to a backend that doesn't use Int64 for
   its IDs. And that's not just a theoretical question; MongoDB uses <literal>ByteString</literal>s
   instead. So what we need is a key value that can contain an <literal>Int</literal> and a
    <literal>ByteString</literal>. Seems like a great time for a sum type:</para>
    <programlisting language="haskell">data Key entity = KeyInt Int64 | KeyByteString ByteString</programlisting>
    <para>But that's just asking for trouble. Next we'll have a backend that uses timestamps, so
   we'll need to add another constructor to <literal>Key</literal>. This could go on for a while.
   Fortunately, we already have a sum type intended for representing arbitrary data:
    <literal>PersistValue</literal>:</para>
    <programlisting language="haskell">newtype Key entity = Key PersistValue</programlisting>
    <para>But this has another problem. Let's say we have a web application that takes an ID as a
   parameter from the user. It will need to receive that parameter as <literal>Text</literal> and then
   try to convert it to a <literal>Key</literal>. Well, that's simple: write a function to convert a
    <literal>Text</literal> to a <literal>PersistValue</literal>, and then wrap the result in the
    <literal>Key</literal> constructor, right?</para>
    <para>Wrong. We tried this, and there's a big problem. We end up getting
    <literal>Key</literal>s that could never be. For example, if we're dealing with SQL, a key must be
   an integer. But the approach described above would allow arbitrary textual data in. The result
   was a bunch of 500 server errors as the database choked on comparing an integer column to
   text.</para>
    <para>So what we need is a way to convert text to a <literal>Key</literal>, but have it
   dependent on the rules of the backend in question. And once phrased that way, the answer is
   simple: just add another phantom. The real, actual definition of <literal>Key</literal> in
   Persistent is:</para>
    <programlisting language="haskell">newtype Key backend entity = Key { unKey :: PersistValue }</programlisting>
    <para>This works great: we can have a <literal>Text -&gt; Key MongoDB entity</literal> function and a
    <literal>Text -&gt; Key SqlPersist entity</literal> function, and everything runs smoothly. But now
   we have a new problem: relations. Let's say we want to represent blogs and blog posts. We would
   use the entity definition:</para>
    <programlisting>Blog
    title Text
Post
    title Text
    blogId BlogId</programlisting>
    <para>But what would that look like in terms of our <literal>Key</literal> datatype?</para>
    <programlisting language="haskell">data Blog = Blog { blogTitle :: Text }
data Post = Post { postTitle :: Text, postBlogId :: Key &lt;what goes here?&gt; Blog }</programlisting>
    <para>We need something to fill in as the backend. In theory, we could hardcode this to
    <literal>SqlPersist</literal>, or <literal>Mongo</literal>, but then our datatypes will only work
   for a single backend. For an individual application, that might be acceptable, but what about
   libraries defining datatypes to be used by multiple applications, using multiple backends?</para>
    <para>So things got a little more complicated. Our types are actually:</para>
    <programlisting language="haskell">data BlogGeneric backend = Blog { blogTitle :: Text }
data PostGeneric backend = Post { postTitle :: Text, postBlogId :: Key backend (BlogGeneric backend) }</programlisting>
    <para>Notice that we still keep the short names for the constructors and the records. Finally, to
   give a simple interface for normal code, we define some type synonyms:</para>
    <programlisting language="haskell">type Blog = BlogGeneric SqlPersist
type BlogId = Key SqlPersist Blog
type Post = PostGeneric SqlPersist
type PostId = Key SqlPersist Post</programlisting>
    <para>And no, <literal>SqlPersist</literal> isn't hard-coded into Persistent anywhere. That
    <literal>sqlSettings</literal> parameter you've been passing to <literal>mkPersist</literal> is what
   tells us to use <literal>SqlPersist</literal>. Mongo code will use <literal>mongoSettings</literal>
   instead.</para>
    <para>This might be quite complicated under the surface, but user code hardly ever touches
   this. Look back through this whole chapter: not once did we need to deal with the
    <literal>Key</literal> or <literal>Generic</literal> stuff directly. The most common place for it to
   pop up is in compiler error messages. So it's important to be aware that this exists, but it
   shouldn't affect you on a day-to-day basis.</para>
   </section>
   <section>
    <title>Custom Fields</title>
    <para/>
    <para>Occassionally, you will want to define a custom field to be used in your datastore. The most common case is an enumeration, such as employment status. For this, Persistent provides a helper Template Haskell function:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, TemplateHaskell,
             OverloadedStrings, GADTs, FlexibleContexts #-}
import Database.Persist
import Database.Persist.Sqlite
import Database.Persist.TH

data Employment = Employed | Unemployed | Retired
    deriving (Show, Read, Eq)
derivePersistField "Employment"

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name String
    employment Employment
|]

main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll

    insert $ Person "Bruce Wayne" Retired
    insert $ Person "Peter Parker" Unemployed
    insert $ Person "Michael" Employed
</programlisting>
    <para>
     <literal>derivePersistField</literal> stores the data in the database using a string
            field, and performs marshaling using the <literal>Show</literal> and <literal>Read</literal>
            instances of the datatype. This may not be as efficient as storing via an integer, but
            it is much more future proof: even if you add extra constructors in the future, your
            data will still be valid.</para>
   </section>
   <section>
    <title>Persistent: Raw SQL</title>
    <para/>
    <para>The Persistent package provides a type safe interface to data stores. It tries to be
            backend-agnostic, such as not relying on relational features of SQL. My experience has
            been you can easily perform 95% of what you need to do with the high-level interface.
            (In fact, most of my web apps use the high level interface exclusively.)</para>
    <para>But occassionally you'll want to use a feature that's specific to a backend. One feature I've
   used in the past is full text search. In this case, we'll use the SQL "LIKE" operator, which is
   not modeled in Persistent. We'll get all people with the last name "Snoyman" and print the
   records out.</para>
    <note>
     <para>Actually, you <emphasis>can</emphasis> express a LIKE operator directly in the
            normal syntax due to a feature added in Persistent 0.6, which allows backend-specific
            operators. But this is still a good example, so let's roll with it.</para>
    </note>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TemplateHaskell, QuasiQuotes, TypeFamilies #-}
{-# LANGUAGE GeneralizedNewtypeDeriving, GADTs, FlexibleContexts #-}
import Database.Persist.Sqlite (withSqliteConn)
import Database.Persist.TH (mkPersist, persist, share, mkMigrate, sqlSettings)
import Database.Persist.GenericSql (runSqlConn, runMigration, SqlPersist)
import Database.Persist.GenericSql.Raw (withStmt)
import Data.Text (Text)
import Database.Persist
import Database.Persist.Store (PersistValue)
import Control.Monad.IO.Class (liftIO)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    name Text
|]

main :: IO ()
main = withSqliteConn ":memory:" $ runSqlConn $ do
    runMigration migrateAll
    insert $ Person "Michael Snoyman"
    insert $ Person "Miriam Snoyman"
    insert $ Person "Eliezer Snoyman"
    insert $ Person "Gavriella Snoyman"
    insert $ Person "Greg Weber"
    insert $ Person "Rick Richardson"

    -- Persistent does not provide the LIKE keyword, but we'd like to get the
    -- whole Snoyman family...
    let sql = "SELECT name FROM Person WHERE name LIKE '%Snoyman'"
    C.runResourceT $ withStmt sql []
                C.$$ CL.mapM_ $ liftIO . print</programlisting>
    <para>There is also higher-level support that allows for automated data marshaling. Please see
            the Haddock API docs for more details.</para>
   </section>
   <section>
    <title>Integration with Yesod</title>
    <para/>
    <para>So you've been convinced of the power of Persistent. How do you integrate it with your
            Yesod application? If you use the scaffolding, most of the work is done for you already.
            But as we normally do, we'll build up everything manually here to point out how it works
            under the surface.</para>
    <para>The <function>yesod-persistent</function> package provides the meeting point
            between Persistent and Yesod. It provides the <literal>YesodPersist</literal>
            typeclass, which standardizes access to the database via the <literal>runDB</literal> method. Let's see this in action.</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, GeneralizedNewtypeDeriving, FlexibleContexts #-}
{-# LANGUAGE TemplateHaskell, OverloadedStrings, GADTs, MultiParamTypeClasses #-}
import Yesod
import Database.Persist.Sqlite

-- Define our entities as usual
share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Person
    firstName String
    lastName String
    age Int Gt Desc
    deriving Show
|]

-- We keep our connection pool in the foundation. At program initialization, we
-- create our initial pool, and each time we need to perform an action we check
-- out a single connection from the pool.
data PersistTest = PersistTest ConnectionPool

-- We'll create a single route, to access a person. It's a very common
-- occurrence to use an Id type in routes.
mkYesod "PersistTest" [parseRoutes|
/person/#PersonId PersonR GET
|]

-- Nothing special here
instance Yesod PersistTest

-- Now we need to define a YesodPersist instance, which will keep track of
-- which backend we're using and how to run an action.
instance YesodPersist PersistTest where
    type YesodPersistBackend PersistTest = SqlPersist

    runDB action = do
        PersistTest pool &lt;- getYesod
        runSqlPool action pool

-- We'll just return the show value of a person, or a 404 if the Person doesn't
-- exist.
getPersonR :: PersonId -&gt; Handler RepPlain
getPersonR personId = do
    person &lt;- runDB $ get404 personId
    return $ RepPlain $ toContent $ show person

openConnectionCount :: Int
openConnectionCount = 10

main :: IO ()
main = withSqlitePool "test.db3" openConnectionCount $ \pool -&gt; do
    runSqlPool (runMigration migrateAll) pool
    runSqlPool (insert $ Person "Michael" "Snoyman" 26) pool
    warpDebug 3000 $ PersistTest pool</programlisting>
    <para>There are two important pieces here for general use. <literal>runDB</literal> is used to
            run a DB action from within a <literal>Handler</literal>. Within the
                <literal>runDB</literal>, you can use any of the functions we've spoken about so far,
            such as <literal>insert</literal> and <literal>selectList</literal>.</para>
    <note>
     <para>The type of <literal>runDB</literal> is <literal>runDB :: YesodDB sub master a -&gt; GHandler
                sub master a</literal>. <literal>YesodDB</literal> is defined
            as:<programlisting language="haskell">type YesodDB sub master = YesodPersistBackend master (GHandler sub master)</programlisting>Since
            it is built on top of the <literal>YesodPersistBackend</literal> associated type, it uses
            the appropriate database backend based on the current site.</para>
    </note>
    <para>The other new feature is <literal>get404</literal>. It works just like
                <literal>get</literal>, but instead of returning a <literal>Nothing</literal> when a
            result can't be found, it returns a 404 message page. The <literal>getPersonR</literal>
            function is a very common approach used in real-world Yesod applications:
                <literal>get404</literal> a value and then return a response based on it.</para>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>Persistent brings the type safety of Haskell to your data access layer. Instead of writing
   error-prone, untyped data access, or manually writing boilerplate marshal code, you can rely on
   Persistent to automate the process for you.</para>
    <para>The goal is to provide everything you need, <emphasis>most</emphasis> of the time. For the times when you
   need something a bit more powerful, Persistent gives you direct access to the underlying data
   store, so you can write whatever 5-way joins you want.</para>
    <para>Persistent integrates directly into the general Yesod workflow. Not only do helper packages
   like <literal>yesod-persistent</literal> provide a nice layer, but packages like
    <literal>yesod-form</literal> and <literal>yesod-auth</literal> also leverage Persistent's features
   as well.</para>
   </section>
  </chapter>
  <chapter>
   <title>Deploying your Webapp</title>
   <para/>
   <para/>
   <para>I can't speak for others, but I personally prefer programming to system administration. But the fact is that, eventually, you need to serve your app somehow, and odds are that you'll need to be the one to set it up.</para>
   <para>There are some promising initiatives in the Haskell web community towards making deployment easier. In the future, we may even have a service that allows you to deploy your app with a single command.</para>
   <para>But we're not there yet. And even if we were, such a solution will never work for everyone. This chapter covers the different options you have for deployment, and gives some general recommendations on what you should choose in different situations.</para>
   <section>
    <title>Compiling</title>
    <para/>
    <para>First things first: how do you build your production application? If you're using the
   scaffolded site, it's as simple as <literal>cabal build</literal>. I also recommend cleaning
   beforehand to make sure there is no cached information, so a simple combination to build your
   executable is:</para>
    <programlisting>cabal clean &amp;&amp; cabal configure &amp;&amp; cabal build</programlisting>
   </section>
   <section>
    <title>Warp</title>
    <para/>
    <para>As we have mentioned before, Yesod is built on the Web Application Interface (WAI), allowing it to run on any WAI backend. At the time of writing, the following backends are available:</para>
    <itemizedlist>
     <listitem>
      <para>Warp</para>
     </listitem>
     <listitem>
      <para>FastCGI</para>
     </listitem>
     <listitem>
      <para>SCGI</para>
     </listitem>
     <listitem>
      <para>CGI</para>
     </listitem>
     <listitem>
      <para>Webkit</para>
     </listitem>
     <listitem>
      <para>Development server</para>
     </listitem>
    </itemizedlist>
    <para>The last two are not intended for production deployments. Of the remaining four, all
            can be used for production deployment in theory. In practice, a CGI backend will likely
            be horribly inefficient, since a new process must be spawned for each connection. And
            SCGI is not nearly as well supported by frontend web servers as Warp (via reverse
            proxying) or FastCGI.</para>
    <para>So between the two remaining choices, Warp gets a very strong recommendation because:</para>
    <itemizedlist>
     <listitem>
      <para>It is significantly faster.</para>
     </listitem>
     <listitem>
      <para>Like FastCGI, it can run behind a frontend server like Nginx, using reverse HTTP proxy.</para>
     </listitem>
     <listitem>
      <para>In addition, it is a fully capable server of its own accord, and can therefore be used without any frontend server.</para>
     </listitem>
    </itemizedlist>
    <para>So that leaves one last question: should Warp run on its own, or via reverse proxy behind
            a frontend server? For most use cases, I recommend the latter, because:</para>
    <itemizedlist>
     <listitem>
      <para>As fast as Warp is, it is still optimized as an application server, not a static
                file server.</para>
     </listitem>
     <listitem>
      <para>Using Nginx, you can set up virtual hosting to serve your static contents from a
                separate domain. (It's possible to do this with Warp, but a bit more involved).</para>
     </listitem>
     <listitem>
      <para>You can use Nginx as either a load balancer or a SSL proxy. (Though with
                    <function>warp-tls</function> it's entirely possible to run an https site on Warp
                alone.)</para>
     </listitem>
    </itemizedlist>
    <para>So my final recommendation is: set up Nginx to reverse proxy to Warp.</para>
    <note>
     <para>A number of people in the Yesod community disagree with me here, and believe that the
            increased performance and decreased complexity of skipping the Nginx step make
            standalone Warp a better choice. Feel free to follow either approach, they are both
            perfectly valid.</para>
    </note>
    <section>
     <title>Configuration</title>
     <para/>
     <para>In general, Nginx will listen on port 80 and your Yesod/Warp app will listen on some unprivileged port (lets say 4321). You will then need to provide a nginx.conf file, such as:</para>
     <programlisting>daemon off; # Don't run nginx in the background, good for monitoring apps
events {
    worker_connections 4096;
}

http {
    server {
        listen 80; # Incoming port for Nginx
        server_name www.myserver.com;
        location / {
            proxy_pass http://127.0.0.1:4321; # Reverse proxy to your Yesod app
        }
    }
}</programlisting>
     <para>You can add as many server blocks as you like. A common addition is to ensure users always access your pages with the www prefix on the domain name, ensuring the RESTful principle of canonical URLs. (You could just as easily do the opposite and always strip the www, just make sure that your choice is reflected in both the nginx config and the approot of your site.) In this case, we would add the block:</para>
     <programlisting>server {
    listen 80;
    server_name myserver.com;
    rewrite ^/(.*) http://www.myserver.com/$1 permanent;
}</programlisting>
     <para>A highly recommended optimization is to serve static files from a separate domain
            name, therefore bypassing the cookie transfer overhead. Assuming that our static files
            are stored in the <literal>static</literal> folder within our site folder, and the
            site folder is located at <literal>/home/michael/sites/mysite</literal>, this
            would look like:</para>
     <programlisting>server {
    listen 80;
    server_name static.myserver.com;
    root /home/michael/sites/mysite/static;
    # Since yesod-static appends a content hash in the query string,
    # we are free to set expiration dates far in the future without
    # concerns of stale content.
    expires max;
}</programlisting>
     <para>In order for this to work, your site must properly rewrite static URLs to this
            alternate domain name. The scaffolded site is set up to make this fairly simple via the
                <literal>Settings.staticRoot</literal> function and the definition of
                <literal>urlRenderOverride</literal>. However, if you just want to get the benefit of
            nginx's faster static file serving without dealing with separate domain names, you can
            instead modify your original server block like so:</para>
     <programlisting>server {
    listen 80; # Incoming port for Nginx
    server_name www.myserver.com;
    location / {
        proxy_pass http://127.0.0.1:4321; # Reverse proxy to your Yesod app
    }
    location /static {
        root /home/michael/sites/mysite; # Notice that we do *not* include /static
        expires max;
    }
}</programlisting>
    </section>
    <section>
     <title>Server Process</title>
     <para/>
     <para>Many people are familiar with an Apache/mod_php or Lighttpd/FastCGI kind of setup,
            where the web server automatically spawns the web application. With nginx, either for
            reverse proxying or FastCGI, this is not the case: you are responsible to run your own
            process. I strongly recommend a monitoring utility which will automatically restart your
            application in case it crashes. There are many great options out there, such as
                <function>angel</function> or daemontools.</para>
     <para>To give a concrete example, here is an Upstart config file. The file must be placed in <literal>/etc/init/mysite.conf</literal>:</para>
     <programlisting>description "My awesome Yesod application"
start on runlevel [2345];
stop on runlevel [!2345];
respawn
chdir /home/michael/sites/mysite
exec /home/michael/sites/mysite/dist/build/mysite/mysite</programlisting>
     <para>Once this is in place, bringing up your application is as simple as <literal>sudo start mysite</literal>.</para>
    </section>
   </section>
   <section>
    <title>FastCGI</title>
    <para/>
    <para>Some people may prefer using FastCGI for deployment. In this case, you'll need to add an extra tool to the mix. FastCGI works by receiving new connection from a file descriptor. The C library assumes that this file descriptor will be 0 (standard input), so you need to use the spawn-fcgi program to bind your application's standard input to the correct socket.</para>
    <para>It can be very convenient to use Unix named sockets for this instead of binding to a port, especially when hosting multiple applications on a single host. A possible script to load up your app could be:</para>
    <programlisting>spawn-fcgi \
    -d /home/michael/sites/mysite \
    -s /tmp/mysite.socket \
    -n \
    -M 511 \
    -u michael \
    -- /home/michael/sites/mysite/dist/build/mysite-fastcgi/mysite-fastcgi</programlisting>
    <para>You will also need to configure your frontend server to speak to your app over FastCGI. This is relatively painless in Nginx:</para>
    <programlisting>server {
    listen 80;
    server_name www.myserver.com;
    location / {
        fastcgi_pass unix:/tmp/mysite.socket;
    }
}</programlisting>
    <para>That should look pretty familiar from above. The only last trick is that, with Nginx, you need to manually specify all of the FastCGI variables. It is recommended to store these in a separate file (say, fastcgi.conf) and then add <literal>include fastcgi.conf;</literal> to the end of your http block. The contents of the file, to work with WAI, should be:</para>
    <programlisting>fastcgi_param  QUERY_STRING       $query_string;
fastcgi_param  REQUEST_METHOD     $request_method;
fastcgi_param  CONTENT_TYPE       $content_type;
fastcgi_param  CONTENT_LENGTH     $content_length;
fastcgi_param  PATH_INFO          $fastcgi_script_name;
fastcgi_param  SERVER_PROTOCOL    $server_protocol;
fastcgi_param  GATEWAY_INTERFACE  CGI/1.1;
fastcgi_param  SERVER_SOFTWARE    nginx/$nginx_version;
fastcgi_param  REMOTE_ADDR        $remote_addr;
fastcgi_param  SERVER_ADDR        $server_addr;
fastcgi_param  SERVER_PORT        $server_port;
fastcgi_param  SERVER_NAME        $server_name;
</programlisting>
   </section>
   <section>
    <title>Desktop</title>
    <para/>
    <para>Another nifty backend is <function>wai-handler-webkit</function>. This backend combines Warp and QtWebkit to create an executable that a user simply double-clicks. This can be a convenient way to provide an offline version of your application.</para>
    <para>One of the very nice conveniences of Yesod for this is that your templates are all compiled into the executable, and thus do not need to be distributed with your application. Static files do, however.</para>
    <note>
     <para>There's actually support for embedding your static files directly in the executable as
            well, see the <function>yesod-static</function> docs for more details.</para>
    </note>
    <para>A similar approach, without requiring the QtWebkit library, is
                <function>wai-handler-launch</function>, which launches a Warp server and then opens
            up the user's default web browser. There's a little trickery involved here: in order to
            know that the user is still using the site, <literal>wai-handler-launch</literal>  inserts
            a "ping" Javascript snippet to every HTML page it serves. It
                <literal>wai-handler-launch</literal> doesn't receive a ping for two minutes, it shuts
            down.</para>
   </section>
   <section>
    <title>CGI on Apache</title>
    <para/>
    <para>CGI and FastCGI work almost identically on Apache, so it should be fairly straight-forward to port this configuration. You essentially need to accomplish two goals:</para>
    <orderedlist>
     <listitem>
      <para>Get the server to serve your file as (Fast)CGI.</para>
     </listitem>
     <listitem>
      <para>Rewrite all requests to your site to go through the (Fast)CGI executable.</para>
     </listitem>
    </orderedlist>
    <para>Here is a configuration file for serving a blog application, with an executable named "bloggy.cgi", living in a subfolder named "blog" of the document root. This example was taken from an application living in the path <literal>/f5/snoyman/public/blog</literal>.</para>
    <programlisting>Options +ExecCGI
AddHandler cgi-script .cgi
Options +FollowSymlinks

RewriteEngine On
RewriteRule ^/f5/snoyman/public/blog$ /blog/ [R=301,S=1]
RewriteCond $1 !^bloggy.cgi
RewriteCond $1 !^static/
RewriteRule ^(.*) bloggy.cgi/$1 [L]</programlisting>
    <para>The first RewriteRule is to deal with subfolders. In particular, it redirects a request for <literal>/blog</literal> to <literal>/blog/</literal>. The first RewriteCond prevents directly requesting the executable, the second allows Apache to serve the static files, and the last line does the actual rewriting.</para>
   </section>
   <section>
    <title>FastCGI on lighttpd</title>
    <para/>
    <para>For this example, I've left off some of the basic FastCGI settings like mime-types. I also have a more complex file in production that prepends "www." when absent and serves static files from a separate domain. However, this should serve to show the basics.</para>
    <para>Here, "/home/michael/fastcgi" is the fastcgi application. The idea is to rewrite all requests to start with "/app", and then serve everything beginning with "/app" via the FastCGI executable.</para>
    <programlisting>server.port = 3000
server.document-root = "/home/michael"
server.modules = ("mod_fastcgi", "mod_rewrite")

url.rewrite-once = (
  "(.*)" =&gt; "/app/$1"
)

fastcgi.server = (
    "/app" =&gt; ((
        "socket" =&gt; "/tmp/test.fastcgi.socket",
        "check-local" =&gt; "disable",
        "bin-path" =&gt; "/home/michael/fastcgi", # full path to executable
        "min-procs" =&gt; 1,
        "max-procs" =&gt; 30,
        "idle-timeout" =&gt; 30
    ))
)</programlisting>
   </section>
   <section>
    <title>CGI on lighttpd</title>
    <para/>
    <para>This is basically the same as the FastCGI version, but tells lighttpd to run a file ending in ".cgi" as a CGI executable. In this case, the file lives at "/home/michael/myapp.cgi".</para>
    <programlisting>server.port = 3000
server.document-root = "/home/michael"
server.modules = ("mod_cgi", "mod_rewrite")

url.rewrite-once = (
    "(.*)" =&gt; "/myapp.cgi/$1"
)

cgi.assign = (".cgi" =&gt; "")</programlisting>
   </section>
  </chapter>
 </part>
 <part>
  <title>Advanced</title>
  <chapter>
   <title>RESTful Content</title>
   <para/>
   <para/>
   <para>One of the stories from the early days of the web is how search engines wiped out entire
            websites. When dynamic web sites were still a new concept, developers didn't appreciate
            the difference between a <literal>GET</literal> and <literal>POST</literal> request. As a
            result, they created pages- accessed with the <literal>GET</literal> method- that would
            delete pages. When search engines started crawling these sites, they could wipe out all
            the content.</para>
   <para>If these web developers had followed the HTTP spec properly, this would not have
            happened. A <literal>GET</literal> request is supposed to cause no side effects
            (you know, like wiping out a site). Recently, there has been a move in web development
            to properly embrace Representational State Transfer, also known as REST. This chapter
            describes the RESTful features in Yesod and how you can use them to create more robust
            web applications.</para>
   <section>
    <title>Request methods</title>
    <para/>
    <para>In many web frameworks, you write one handler function per resource. In Yesod, the default is to have a separate handler function for each <glossterm>request method</glossterm>. The two most common request methods you will deal with in creating web sites are GET and POST. These are the most well-supported methods in HTML, since they are the only ones supported by web forms. However, when creating RESTful APIs, the other methods are very useful.</para>
    <para>Technically speaking, you can create whichever request methods you like, but it is strongly recommended to stick to the ones spelled out in the HTTP spec. The most common of these are:</para>
    <variablelist>
     <varlistentry>
      <term>GET</term>
      <listitem>
       <para>Read-only requests. Assuming no other changes occur on the server, calling a
                        <literal>GET</literal> request multiple times should result in the same
                    response, barring such things as "current time" or randomly assigned
                    results.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>POST</term>
      <listitem>
       <para>A general mutating request. A <literal>POST</literal> request should never be submitted
                    twice by the user. A common example of this would be to transfer funds from one
                    bank account to another.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>PUT</term>
      <listitem>
       <para>Create a new resource on the server, or replace an existing one. This method <emphasis>is</emphasis> safe to be called multiple times.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>DELETE</term>
      <listitem>
       <para>Just like it sounds: wipe out a resource on the server. Calling multiple times should be OK.</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>To a certain extent, this fits in very well with Haskell philosophy: a
                <literal>GET</literal> request is similar to a pure function, which cannot have side
            effects. In practice, your <literal>GET</literal> functions will probably perform
                <literal>IO</literal>, such as reading information from a database, logging user
            actions, and so on.</para>
    <para>See the routing and handlers chapter chapter for more information on the syntax of defining handler functions for each request method.</para>
   </section>
   <section>
    <title>Representations</title>
    <para/>
    <para>Suppose we have a Haskell datatype and value:</para>
    <programlisting language="haskell">data Person = Person { name :: String, age :: Int }
michael = Person "Michael" 25</programlisting>
    <para>We could represent that data as HTML:</para>
    <programlisting>&lt;table&gt;
    &lt;tr&gt;
        &lt;th&gt;Name&lt;/th&gt;
        &lt;td&gt;Michael&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;th&gt;Age&lt;/th&gt;
        &lt;td&gt;25&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;</programlisting>
    <para>or we could represent it as JSON:</para>
    <programlisting>{"name":"Michael","age":25}</programlisting>
    <para>or as XML:</para>
    <programlisting>&lt;person&gt;
    &lt;name&gt;Michael&lt;/name&gt;
    &lt;age&gt;25&lt;/age&gt;
&lt;/person&gt;</programlisting>
    <para>Often times, web applications will use a different URL to get each of these
            representations; perhaps <literal>/person/michael.html</literal>,
                <literal>/person/michael.json</literal>, etc. Yesod follows the RESTful principle of a
            single URL for each <glossterm>resource</glossterm>. So in Yesod, all of these would be
            accessed from <literal>/person/michael</literal>.</para>
    <para>Then the question becomes how do we determine <emphasis>which</emphasis> representation to
            serve. The answer is the HTTP <literal>Accept</literal> header: it gives a prioritized
            list of content types the client is expecting. Yesod will automatically determine which
            representation to serve based upon this header.</para>
    <para>Let's make that last sentence a bit more concrete with some code:</para>
    <programlisting language="haskell">type ChooseRep = [ContentType] -&gt; IO (ContentType, Content)
class HasReps a where
    chooseRep :: a -&gt; ChooseRep</programlisting>
    <para>The <literal>chooseRep</literal> function takes two arguments: the value we are getting
            representations for, and a list of content types that the client will accept. We
            determine this by reading the <literal>Accept</literal> request header.
                <literal>chooseRep</literal> returns a tuple containing the content type of our
            response and the actual content.</para>
    <para>This typeclass is the core of Yesod's RESTful approach to representations. Every
            handler function must return an instance of <literal>HasReps</literal>. When
            Yesod generates the dispatch function, it automatically applies
                <literal>chooseRep</literal> to each handler, essentially giving all functions the
            type <literal>Handler ChooseRep</literal>. After running the <literal>Handler</literal> and
            obtaining the <literal>ChooseRep</literal> result, it is applied to the list of content
            types parsed from the <literal>Accept</literal> header.</para>
    <para>Yesod provides a number of instances of <literal>HasReps</literal> out of the
            box. When we use <literal>defaultLayout</literal>, for example, the return type
            is <literal>RepHtml</literal>, which looks like:</para>
    <programlisting language="haskell">newtype RepHtml = RepHtml Content
instance HasReps RepHtml where
    chooseRep (RepHtml content) _ = return ("text/html", content)</programlisting>
    <para>Notice that we ignore entirely the list of expected content types. A number of the
            built in representations (<literal>RepHtml</literal>, <literal>RepPlain</literal>,
                <literal>RepJson</literal>, <literal>RepXml</literal>) in fact only support a single
            representation, and therefore what the client requests in the <literal>Accept</literal>
            header is irrelevant.</para>
    <section>
     <title>RepHtmlJson</title>
     <para/>
     <para>An example to the contrary is <literal>RepHtmlJson</literal>, which provides either an
            HTML or JSON representation. This instance helps greatly in programming AJAX
            applications that degrade nicely. Here is an example that returns either HTML or JSON
            data, depending on what the client wants.</para>
     <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, OverloadedStrings #-}
{-# LANGUAGE MultiParamTypeClasses, TemplateHaskell #-}
import Yesod
data R = R
mkYesod "R" [parseRoutes|
/ RootR GET
/#String NameR GET
|]
instance Yesod R

getRootR = defaultLayout $ do
    setTitle "Homepage"
    addScriptRemote "http://ajax.googleapis.com/ajax/libs/jquery/1.4/jquery.min.js"
    toWidget [julius|
$(function(){
    $("#ajax a").click(function(){
        jQuery.getJSON($(this).attr("href"), function(o){
            $("div").text(o.name);
        });
        return false;
    });
});
|]
    let names = words "Larry Moe Curly"
    [whamlet|
&lt;h2&gt;AJAX Version
&lt;div #results&gt;
    AJAX results will be placed here when you click #
    the names below.
&lt;ul #ajax&gt;
    $forall name &lt;- names
        &lt;li&gt;
            &lt;a href=@{NameR name}&gt;#{name}

&lt;h2&gt;HTML Version
&lt;p&gt;
    Clicking the names below will redirect the page #
    to an HTML version.
&lt;ul #html&gt;
    $forall name &lt;- names
        &lt;li&gt;
            &lt;a href=@{NameR name}&gt;#{name}

|]

getNameR name = do
    let widget = do
            setTitle $ toHtml name
            [whamlet|Looks like you have Javascript off. Name: #{name}|]
    let json = object ["name" .= name]
    defaultLayoutJson widget json

main = warpDebug 4000 R</programlisting>
     <para>Our <literal>getRootR</literal> handler creates a page with three links and some
            Javascript which intercept clicks on the links and performs asynchronous requests. If
            the user has Javascript enabled, clicking on the link will cause a request to be sent
            with an <literal>Accept</literal> header of <literal>application/json</literal>. In that case, <literal>getNameR</literal> will
            return the JSON representation instead.</para>
     <para>If the user disables Javascript, clicking on the link will send the user to the
            appropriate URL. A web browser places priority on an HTML representation of the data,
            and therefore the page defined by the widget will be returned.</para>
     <para>We can of course extend this to work with XML, Atom feeds, or even binary
            representations of the data. A fun exercise could be writing a web application that
            serves data simply using the default <literal>Show</literal> instances of datatypes, and
            then writing a web client that parses the results using the default
                <literal>Read</literal> instances.</para>
     <note>
      <para>You might be concerned about efficiency here. Doesn't this approach mean we have to
            generate both an HTML and JSON response for each request? Thanks to laziness, that's not
            the case. In <literal>getNameR</literal>, neither <literal>widget</literal> nor
                <literal>json</literal> will be evaluated until the appropriate response type has been
            selected, and therefore only one of them will ever be run.</para>
     </note>
    </section>
    <section>
     <title>News Feeds</title>
     <para/>
     <para>A great, practical example of multiple representations if the <function>yesod-newsfeed</function> package. There are two major formats for news feeds on the web: RSS and Atom. They contain almost exactly the same information, but are just packaged up differently.</para>
     <para>The <literal>yesod-newsfeed</literal> package defines a <literal>Feed</literal>
            datatype which contains information like title, description, and last updated time. It
            then provides two separate sets of functions for displaying this data: one for RSS, one
            for Atom. They each define their own representation datatypes:</para>
     <programlisting language="haskell">newtype RepAtom = RepAtom Content
instance HasReps RepAtom where
    chooseRep (RepAtom c) _ = return (typeAtom, c)
newtype RepRss = RepRss Content
instance HasReps RepRss where
    chooseRep (RepRss c) _ = return (typeRss, c)</programlisting>
     <para>But there's a third module which defines another datatype:</para>
     <programlisting language="haskell">data RepAtomRss = RepAtomRss RepAtom RepRss
instance HasReps RepAtomRss where
    chooseRep (RepAtomRss (RepAtom a) (RepRss r)) = chooseRep
        [ (typeAtom, a)
        , (typeRss, r)
        ]</programlisting>
     <para>This datatype will automatically serve whichever representation the client prefers, defaulting to Atom. If a client connects that only understands RSS, assuming it provides the correct HTTP headers, Yesod will provide RSS output.</para>
    </section>
   </section>
   <section>
    <title>Other request headers</title>
    <para/>
    <para>There are a great deal of other request headers available. Some of them only affect the
            transfer of data between the server and client, and should not affect the application at
            all. For example, <literal>Accept-Encoding</literal> informs the server which compression
            schemes the client understands, and <literal>Host</literal> informs the server which
            virtual host to serve up.</para>
    <para>Other headers <emphasis>do</emphasis> affect the application, but are automatically read by
            Yesod. For example, the <literal>Accept-Language</literal> header specifies which human
            language (English, Spanish, German, Swiss-German) the client prefers. See the i18n chapter
            for details on how this header is used.</para>
   </section>
   <section>
    <title>Stateless</title>
    <para/>
    <para>I've saved this section for the last, not because it is less important, but rather because there are no specific features in Yesod to enforce this.</para>
    <para>HTTP is a stateless protocol: each request is to be seen as the beginning of a conversation. This means, for instance, it doesn't matter to the server if you requested five pages previously, it will treat your sixth request as if it's your first one.</para>
    <para>On the other hand, some features on websites won't work without some kind of state. For example, how can you implement a shopping cart without saving information about items in between requests?</para>
    <para>The solution to this is cookies, and built on top of this, sessions. We have a whole section addressing the sessions features in Yesod. However, I cannot stress enough that this should be used sparingly.</para>
    <para>Let me give you an example. There's a popular bug tracking system that I deal with on a daily basis which horribly abuses sessions. There's a little drop-down on every page to select the current project. Seems harmless, right? What that dropdown does is set the current project in your session.</para>
    <para>The result of all this is that clicking on the "view issues" link is entirely dependent on the last project you selected. There's no way to create a bookmark to your "Yesod" issues and a separate link for your "Hamlet" issues.</para>
    <para>The proper RESTful approach to this is to have one resource for all of the Yesod issues and a separate one for all the Hamlet issues. In Yesod, this is easily done with a route definition like:</para>
    <programlisting>/ ProjectsR GET
/projects/#ProjectID ProjectIssuesR GET
/issues/#IssueID IssueR GET</programlisting>
    <para>Be nice to your users: proper stateless architecture means that basic features like bookmarks, permalinks and the back/forward button will always work.</para>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>Yesod adheres to the following tenets of REST:</para>
    <itemizedlist>
     <listitem>
      <para>Use the correct request method.</para>
     </listitem>
     <listitem>
      <para>Each resource should have precisely one URL.</para>
     </listitem>
     <listitem>
      <para>Allow multiple representations of data on the same URL.</para>
     </listitem>
     <listitem>
      <para>Inspect request headers to determine extra information about what the client wants.</para>
     </listitem>
    </itemizedlist>
    <para>This makes it easy to use Yesod not just for building websites, but for building APIs. In fact, using techniques such as RepHtmlJson, you can serve both a user-friendly, HTML page and a machine-friendly, JSON page from the same URL.</para>
   </section>
  </chapter>
  <chapter>
   <title>Yesod's Monads</title>
   <para/>
   <para/>
   <para>As you've read through this book, there have been a number of monads which have
   appeared: <literal>Handler</literal>, <literal>Widget</literal> and
    <literal>YesodDB</literal> (for Persistent). As with most monads, each one provides some specific
   functionality: <literal>Handler</literal> gives access to the request and allows you to
   send responses, a <literal>Widget</literal> contains HTML, CSS, and Javascript, and
    <literal>YesodDB</literal> let's you make database queries. In Model-View-Controller
   (MVC) terms, we could consider <literal>YesodDB</literal> to be the model, <literal>Widget</literal>
   to be the view, and <literal>Handler</literal> to be the controller.</para>
   <para>So far, we've presented some very straight-forward ways to use these monads: your main
   handler will run in <literal>Handler</literal>, using <literal>runDB</literal> to execute a
    <literal>YesodDB</literal> query, and <literal>defaultLayout</literal> to return a
   <literal>Widget</literal>, which in turn was created by calls to <literal>toWidget</literal>.</para>
   <para>However, if we have a deeper understanding of these types, we can achieve some fancier
   results.</para>
   <section>
    <title>Monad Transformers</title>
    <para/>
    <blockquote>
     <para>Monads are like onions. Monads are <emphasis>not</emphasis> like cakes.<citation>Shrek, more or less</citation>
     </para>
    </blockquote>
    <para>Before we get into the heart of Yesod's monads, we need to understand a bit about
   monad transformers. (If you already know all about monad transformers, you can likely skip this
   section.) Different monads provide different functionality: <literal>Reader</literal> allows
   read-only access to some piece of data throughout a computation, <literal>Error</literal> allows
   you to short-circuit computations, and so on.</para>
    <para>Often times, however, you would like to be able to combine a few of these features
   together. After all, why not have a computation with read-only access to some settings variable,
   that could error out at any time? One approach to this would be to write a new monad like
    <literal>ReaderError</literal>, but this has the obvious downside of exponential complexity:
   you'll need to write a new monad for every single possible combination.</para>
    <para>Instead, we have monad transformers. In addition to <literal>Reader</literal>, we have
    <literal>ReaderT</literal>, which adds reader functionality to any other monad. So we could
   represent our <literal>ReaderError</literal> as (conceptually):</para>
    <programlisting language="haskell">type ReaderError = ReaderT Error</programlisting>
    <para>In order to access our settings variable, we can use the <literal>ask</literal> function. But what about short-circuiting a computation? We'd like to use
    <literal>throwError</literal>, but that won't exactly work. Instead, we need to <literal>lift</literal> our call into the next monad up. In other words:</para>
    <programlisting language="haskell">throwError :: errValue -&gt; Error
lift . throwError :: errValue -&gt; ReaderT Error</programlisting>
    <para>There are a few things you should pick up here:</para>
    <itemizedlist>
     <listitem>
      <para>A transformer can be used to add functionality to an existing monad.</para>
     </listitem>
     <listitem>
      <para>A transformer must always wrap around an existing monad.</para>
     </listitem>
     <listitem>
      <para>The functionality available in a wrapped monad will be dependent not only on the
    monad transformer, but also on the inner monad that is being wrapped.</para>
     </listitem>
    </itemizedlist>
    <para>A great example of that last point is the <literal>IO</literal> monad. No matter how
   many layers of transformers you have around an <literal>IO</literal>, there's still an
    <literal>IO</literal> at the core, meaning you can perform I/O in any of these <glossterm>monad transformer stacks</glossterm>. You'll often see code that looks like <literal>liftIO
    $ putStrLn "Hello There!"</literal>.</para>
   </section>
   <section>
    <title>The Three Transformers</title>
    <para/>
    <para>We've already discussed two of our transformers previously: <literal>Handler</literal> and
    <literal>Widget</literal>. Just to recap, there are two special things about these
   transformers:</para>
    <orderedlist>
     <listitem>
      <para>In order to simplify error messages, they are not actual transformers. Instead, they are
    newtypes that hard-code their inner monads.<note>
        <para>Remember, this is why Yesod provides a
     specialized <literal>lift</literal> function, which works for <literal>Handler</literal> and
      <literal>Widget</literal>.</para>
       </note>
      </para>
     </listitem>
     <listitem>
      <para>In reality they have extra type parameters for the sub and master site. As a result, the
    Yesod libraries provide <literal>GHandler sub master a</literal> and <literal>GWidget sub master
     a</literal>, and each site gets a pair of type synonyms <literal>type Handler = GHandler MyApp
     MyApp</literal> and <literal>type Widget = GWidget MyApp My App ()</literal>.</para>
     </listitem>
    </orderedlist>
    <para>In <function>persistent</function>, we have a typeclass called
    <literal>PersistStore</literal>. This typeclass defines all of the primitive operations you can
   perform on a database, like <literal>get</literal>. This typeclass essentially looks like
    <literal>class (Monad (b m)) =&gt; PersistStore b m</literal>. <literal>b</literal> is the backend itself, and is in fact a monad transformer, while <literal>m</literal> is the inner monad that <literal>b</literal> wraps around. Both SQL and
   MongoDB have their own instances; in the case of SQL, it looks like:</para>
    <programlisting language="haskell">instance MonadBaseControl IO m =&gt; PersistBackend SqlPersist m</programlisting>
    <para>This means that you can run a SQL database with any underlying monad, so long as that
   underlying monad supports <literal>MonadBaseControl IO</literal>, which allows you to
   properly deal with exceptions in a monad stack. That basically means any transformer stack built
   around <literal>IO</literal> (besides exceptional cases like <literal>ContT</literal>).
   Fortunately for us, that includes both <literal>Handler</literal> and <literal>Widget</literal>. The
   takeaway here is that we can layer our Persistent transformer on top of <literal>Handler</literal>
   or <literal>Widget</literal>.</para>
    <note>
     <para>This wasn't always the case. Before Yesod 0.10, Yesod was built on top of enumerators, which
   do not support <literal>MonadBaseControl</literal>. In Yesod 0.10, we moved over to
    <function>conduit</function>, which greatly simplified everything we're discussing here.</para>
    </note>
    <para>In order to make it simpler to refer to the relevant Persistent transformer, the
    <function>yesod-persistent</function> package defines the <literal>YesodPersistBackend</literal>
   associated type. For example, if I have a site called <literal>MyApp</literal> and it uses SQL, I
   would define something like <literal>type instance YesodPersistBackend MyApp =
   SqlPersist</literal>.</para>
    <para>When we want to run our database actions, we'll have a <literal>SqlPersist</literal>
   wrapped around a <literal>Handler</literal> or <literal>Widget</literal>. We can then use the
   standard Persistent unwrap functions (like <literal>runSqlPool</literal>) to run the action and get
   back a normal <literal>Handler</literal>/<literal>Widget</literal>. To automate this, we provide the
    <literal>runDB</literal> function. Putting it all together, we can now run database actions inside
   our handlers and widgets.</para>
    <para>Most of the time in Yesod code, and especially thus far in this book, widgets have
   been treated as actionless containers that simply combine together HTML, CSS and Javascript. But
   if you look at that last paragraph again, you'll realize that's not the way things have to be.
   Since a widget is a transformer on top of a handler, anything you do in a handler can be done in
   a widget, including database actions. All you have to do is <literal>lift</literal>.</para>
   </section>
   <section>
    <title>Example: Database-driven navbar</title>
    <para/>
    <para>Let's put some of this new knowledge into action. We want to create a
                <literal>Widget</literal> that generates its output based on the contents of the
            database. Previously, our approach would have been to load up the data in a
                <literal>Handler</literal>, and then pass that data into a <literal>Widget</literal>.
            Now, we'll do the loading of data in the <literal>Widget</literal> itself. This is a boon
            for modularity, as this <literal>Widget</literal> can be used in any
                <literal>Handler</literal> we want, without any need to pass in the database
            contents.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell, FlexibleContexts,
             QuasiQuotes, TypeFamilies, MultiParamTypeClasses, GADTs #-}
import Yesod
import Database.Persist.Sqlite
import Data.Text (Text)
import Data.Time

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Link
    title Text
    url Text
    added UTCTime
|]

data LinksExample = LinksExample ConnectionPool

mkYesod "LinksExample" [parseRoutes|
/ RootR GET
/add-link AddLinkR POST
|]

instance Yesod LinksExample

instance RenderMessage LinksExample FormMessage where
    renderMessage _ _ = defaultFormMessage

instance YesodPersist LinksExample where
    type YesodPersistBackend LinksExample = SqlPersist
    runDB db = do
        LinksExample pool &lt;- getYesod
        runSqlPool db pool

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;form method=post action=@{AddLinkR}&gt;
    &lt;p&gt;
        Add a new link to #
        &lt;input type=url name=url value=http://&gt;
        \ titled #
        &lt;input type=text name=title&gt;
        \ #
        &lt;input type=submit value="Add link"&gt;
&lt;h2&gt;Existing links
^{existingLinks}
|]

existingLinks :: Widget
existingLinks = do
    links &lt;- lift $ runDB $ selectList [] [LimitTo 5, Desc LinkAdded]
    [whamlet|
&lt;ul&gt;
    $forall Entity _ link &lt;- links
        &lt;li&gt;
            &lt;a href=#{linkUrl link}&gt;#{linkTitle link}
|]

postAddLinkR :: Handler ()
postAddLinkR = do
    url &lt;- runInputPost $ ireq urlField "url"
    title &lt;- runInputPost $ ireq textField "title"
    now &lt;- liftIO getCurrentTime
    runDB $ insert $ Link title url now
    setMessage "Link added"
    redirect RootR

main :: IO ()
main = withSqlitePool "links.db3" 10 $ \pool -&gt; do
    runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ LinksExample pool</programlisting>
    <para>Pay attention in particular to the <literal>existingLinks</literal> function.
            Notice how all we needed to do was apply <literal>lift</literal> to a normal
            database action. And from within <literal>getRootR</literal>, we treated <literal>existingLinks</literal> like any ordinary <literal>Widget</literal>,
            no special parameters at all. See the figure for the output of this app.</para>
    <figure xml:id="navbar-x-14">
     <title>Screenshot of the navbar</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/yesods-monads/navbar.png"/>
      </imageobject>
     </mediaobject>
    </figure>
   </section>
   <section>
    <title>Example: Request information</title>
    <para/>
    <para>Likewise, you can get request information inside a <literal>Widget</literal>. Here we
            can determine the sort order of a list based on a GET parameter.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
             QuasiQuotes, TypeFamilies, MultiParamTypeClasses, GADTs #-}
import Yesod
import Data.Text (Text)
import Data.List (sortBy)
import Data.Ord (comparing)

data Person = Person
    { personName :: Text
    , personAge :: Int
    }

people :: [Person]
people =
    [ Person "Miriam" 25
    , Person "Eliezer" 3
    , Person "Michael" 26
    , Person "Gavriella" 1
    ]

data People = People

mkYesod "People" [parseRoutes|
/ RootR GET
|]

instance Yesod People

instance RenderMessage People FormMessage where
    renderMessage _ _ = defaultFormMessage


getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;p&gt;
    &lt;a href="?sort=name"&gt;Sort by name
    \ | #
    &lt;a href="?sort=age"&gt;Sort by age
    \ | #
    &lt;a href="?"&gt;No sort
^{showPeople}
|]

showPeople :: Widget
showPeople = do
    msort &lt;- lift $ runInputGet $ iopt textField "sort"
    let people' =
            case msort of
                Just "name" -&gt; sortBy (comparing personName) people
                Just "age"  -&gt; sortBy (comparing personAge)  people
                _           -&gt; people
    [whamlet|
&lt;dl&gt;
    $forall person &lt;- people'
        &lt;dt&gt;#{personName person}
        &lt;dd&gt;#{show $ personAge person}
|]

main :: IO ()
main = warpDebug 3000 People</programlisting>
    <para>Once again, all we need to do is <literal>lift</literal> our normal
                <literal>Handler</literal> code (in this case, <literal>runInputGet</literal>) to have
            it run in our <literal>Widget</literal>.</para>
   </section>
   <section>
    <title>Summary</title>
    <para/>
    <para>If you completely ignore this chapter, you'll still be able to use Yesod to great benefit. The
   advantage of understanding how Yesod's monads interact is to be able to produce cleaner, more
   modular code. Being able to perform arbitrary actions in a <literal>Widget</literal> can be a
   powerful tool, and understanding how Persistent and your <literal>Handler</literal> code interact
   can help you make more informed design decisions in your app.</para>
   </section>
  </chapter>
  <chapter>
   <title>Authentication and Authorization</title>
   <para/>
   <para/>
   <para>Authentication and authorization are two very related, and yet separate, concepts. While
            the former deals with identifying a user, the latter determines what a user is allowed
            to do. Unfortunately, since both terms are often abbreviated as "auth," the concepts are
            often conflated.</para>
   <para>Yesod provides built-in support for a number of third-party authentication systems, such
            as OpenID, BrowserID and OAuth. These are systems where your application trusts some
            external system for validating a user's credentials. Additionally, there is support for
            more commonly used username/password and email/password systems. The former route
            ensures simplicity for users (no new passwords to remember) and implementors (no need to
            deal with an entire security architecture), while the latter gives the developer more
            control.</para>
   <para>On the authorization side, we are able to take advantage of REST and type-safe
            URLs to create simple, declarative systems. Additionally, since all authorization code
            is written in Haskell, you have the full flexibility of the language at your
            disposal.</para>
   <para>This chapter will cover how to set up an "auth" solution in Yesod and discuss some
            trade-offs in the different authentication options.</para>
   <section>
    <title>Overview</title>
    <para/>
    <para>The <function>yesod-auth</function> package provides a unified interface for a
   number of different authentication plugins. The only real requirement for these backends is that
   they identify a user based on some unique string. In OpenID, for instance, this would be the
   actual OpenID value. In BrowserID, it's the email address. For HashDB (which uses a database of
   hashed passwords), it's the username.</para>
    <para>Each authentication plugin provides its own system for logging in, whether it be via
   passing tokens with an external site or a email/password form. After a successful login, the
   plugin sets a value in the user's session to indicate his/her <literal>AuthId</literal>. This
    <literal>AuthId</literal> is usually a Persistent ID from a table used for keeping track of
   users.</para>
    <para>There are a few functions available for querying a user's <literal>AuthId</literal>,
   most commonly <literal>maybeAuthId</literal>, <literal>requireAuthId</literal>,
    <literal>maybeAuth</literal> and <literal>requireAuth</literal>. The require
   versions will redirect to a login page if the user is not logged in, while the second set of
   functions (the ones <emphasis role="bold">not</emphasis> ending in <literal>Id</literal>) give both the table ID <emphasis>and</emphasis> entity value.</para>
    <para>Since all of the storage of <literal>AuthId</literal> is built on top of sessions, all
   of the rules from there apply. In particular, the data is stored in an encrypted, HMACed client
   cookie, which automatically times out after a certain configurable period of inactivity.
   Additionally, since there is no server-side component to sessions, logging out simply deletes the
   data from the session cookie; if a user reuses an older cookie value, the session will still be
   valid.</para>
    <note>
     <para>There are plans to add in a server-side component to sessions which would allow forced
   logout. This will almost certainly be implemented before a 1.0 release of Yesod.</para>
    </note>
    <para>On the flip side, authorization is handled by a few methods inside the
    <literal>Yesod</literal> typeclass. For every request, these methods are run to determine if
   access should be allowed, denied, or if the user needs to be authenticated. By default, these
   methods allow access for every request. Alternatively, you can implement authorization in a more
   ad-hoc way by adding calls to <literal>requireAuth</literal> and the like within individual handler
   functions, though this undermines many of the benefits of a declarative authorization system.</para>
   </section>
   <section>
    <title>Authenticate Me</title>
    <para/>
    <para>Let's jump right in with an example of authentication.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.BrowserId
import Yesod.Auth.GoogleEmail
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    -- Note: In order to log in with BrowserID, you must correctly
    -- set your hostname here.
    approot = ApprootStatic "http://localhost:3000"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ =
        [ authBrowserId
        , authGoogleEmail
        ]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid &lt;- maybeAuthId
    defaultLayout [whamlet|
&lt;p&gt;Your current auth ID: #{show maid}
$maybe _ &lt;- maid
    &lt;p&gt;
        &lt;a href=@{AuthR LogoutR}&gt;Logout
$nothing
    &lt;p&gt;
        &lt;a href=@{AuthR LoginR}&gt;Go to the login page
|]

main :: IO ()
main = do
    man &lt;- newManager def
    warpDebug 3000 $ MyAuthSite man</programlisting>
    <para>We'll start with the route declarations. First we declare our standard <literal>RootR</literal>
   route, and then we set up the authentication subsite. Remember that a subsite needs four
   parameters: the path to the subsite, the route name, the subsite name, and a function to get the
   subsite value. In other words, based on the line:</para>
    <programlisting>/auth AuthR Auth getAuth</programlisting>
    <para>We need to have <literal>getAuth :: MyAuthSite -&gt; Auth</literal>. While we haven't written that
   function ourselves, <function>yesod-auth</function> provides it automatically. With other subsites
   (like static files), we provide configuration settings in the subsite value, and therefore need
   to specify the get function. In the auth subsite, we specify these settings in a separate
   typeclass, <literal>YesodAuth</literal>.</para>
    <note>
     <para>Why not use the subsite value? There are a number of settings we would like to give for an
   auth subsite, and doing so from a record type would be inconvenient. Also, since we want to have
   an <literal>AuthId</literal> associated type, a typeclass is more natural.On the flip side, why
    not use a typeclass for all subsites? It comes with a downside: you can then only have a single
    instance per site, disallowing serving different sets of static files from different routes.
    Also, the subsite value works better when we want to load data at app initialization.</para>
    </note>
    <para>So what exactly goes in this YesodAuth instance? There are six required
   declarations:</para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>AuthId</literal> is an associated type. This is the value
     <literal>yesod-auth</literal> will give you when you ask if a user is logged in (via
     <literal>maybeAuthId</literal> or <literal>requireAuthId</literal>). In our case, we're simply
    using <literal>Text</literal>, to store the raw identifier- email address in our case, as we'll
    soon see.</para>
     </listitem>
     <listitem>
      <para>
       <literal>getAuthId</literal> gets the actual <literal>AuthId</literal> from the <literal>Creds</literal> (credentials) data type. This type has three pieces of information:
    the authentication backend used (browserid or googleemail in our case), the actual identifier,
    and an associated list of arbitrary extra information. Each backend provides different extra
    information; see their docs for more information.</para>
     </listitem>
     <listitem>
      <para>
       <literal>loginDest</literal> gives the route to redirect to after a successful
    login.</para>
     </listitem>
     <listitem>
      <para>Likewise, <literal>logoutDest</literal> gives the route to redirect to after a
    logout.</para>
     </listitem>
     <listitem>
      <para>
       <literal>authPlugins</literal> is a list of individual authentication backends to
    use. In our example, we're using BrowserID, which logs in via Mozilla's BrowserID system, and
    Google Email, which authenticates a user's email address using their Google account. The nice
    thing about these two backends is:<itemizedlist>
        <listitem>
         <para>They require no set up, as opposed to Facebook or OAuth, which require setting up
      credentials.</para>
        </listitem>
        <listitem>
         <para>They use email addresses as identifiers, which people are comfortable with, as
      opposed to OpenID, which uses a URL.</para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>authHttpManager</literal> gets an HTTP connection manager from the foundation type.
    This allow authentication backends which use HTTP connections (i.e., almost all third-party
    login systems) to share connections, avoiding the cost of restarting a TCP connection for each
    request.</para>
     </listitem>
    </itemizedlist>
    <para>In our <literal>RootR</literal> handler, we have some simple links to the login and
   logout pages, depending on whether or not the user is logged in. Notice how we construct these
   subsite links: first we give the subsite route name (<literal>AuthR</literal>), followed by the
   route within the subsite (<literal>LoginR</literal> and <literal>LogoutR</literal>).</para>
    <para>The figures below show what the login process looks like from a user perspective.</para>
    <figure xml:id="concept_d1y_t2f_p2-x-26">
     <title>Initial page load</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/authentication-and-authorization/initial-screen.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <figure xml:id="concept_d1y_t2f_p2-x-28">
     <title>BrowserID login screen</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/authentication-and-authorization/login-with-browserid.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <figure xml:id="concept_d1y_t2f_p2-x-30">
     <title>Homepage after logging in</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/authentication-and-authorization/after-login.png"/>
      </imageobject>
     </mediaobject>
    </figure>
   </section>
   <section>
    <title>Email</title>
    <para/>
    <para>For many use cases, third-party authentication of email will be sufficient. Occassionally,
   you'll want users to actual create passwords on your site. The scaffolded site does not include
   this setup, because:</para>
    <itemizedlist>
     <listitem>
      <para>In order to securely accept passwords, you need to be running over SSL. Many users are not
    serving their sites over SSL.</para>
     </listitem>
     <listitem>
      <para>While the email backend properly salts and hashes passwords, a compromised database could
    still be problematic. Again, we make no assumptions that Yesod users are following secure
    deployment practices.</para>
     </listitem>
     <listitem>
      <para>You need to have a working system for sending email. Many web servers these days are
                not equipped to deal with all of the spam protection measures used by mail
                    servers.<note>
        <para>The example below will use the system's built-in <command>sendmail</command> executable. If you would like to avoid the
                    hassle of dealing with an email server yourself, you can use Amazon SES. There
                    is a package called <function>mime-mail-ses</function> which provides a
                    drop-in replacement for the sendmail code used below. This is the approach we
                    use on the Haskellers.com site.</para>
       </note>
      </para>
     </listitem>
    </itemizedlist>
    <para>But assuming you are able to meet these demands, and you want to have a separate password login
   specifically for your site, Yesod offers a built-in backend. It requires quite a bit of code to
   set up, since it needs to store passwords securely in the database and send a number of different
   emails to users (verify account, password retrieval, etc.).</para>
    <para>Let's have a look at a site that provides email authentication, storing passwords in a
   Persistent SQLite database.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes, GADTs,
             TemplateHaskell, MultiParamTypeClasses, FlexibleContexts #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Email
import Database.Persist.Sqlite
import Database.Persist.TH
import Data.Text (Text)
import Network.Mail.Mime
import qualified Data.Text.Lazy.Encoding
import Text.Shakespeare.Text (stext)
import Text.Blaze.Renderer.Utf8 (renderHtml)
import Text.Hamlet (shamlet)
import Data.Maybe (isJust)
import Control.Monad (join)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
User
    email Text
    password Text Maybe -- Password may not be set yet
    verkey Text Maybe -- Used for resetting passwords
    verified Bool
    UniqueUser email
|]

data MyEmailApp = MyEmailApp Connection

mkYesod "MyEmailApp" [parseRoutes|
/ RootR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyEmailApp where
    -- Emails will include links, so be sure to include an approot so that
    -- the links are valid!
    approot = ApprootStatic "http://localhost:3000"

instance RenderMessage MyEmailApp FormMessage where
    renderMessage _ _ = defaultFormMessage

-- Set up Persistent
instance YesodPersist MyEmailApp where
    type YesodPersistBackend MyEmailApp = SqlPersist
    runDB f = do
        MyEmailApp conn &lt;- getYesod
        runSqlConn f conn

instance YesodAuth MyEmailApp where
    type AuthId MyEmailApp = UserId

    loginDest _ = RootR
    logoutDest _ = RootR
    authPlugins _ = [authEmail]

    -- Need to find the UserId for the given email address.
    getAuthId creds = runDB $ do
        x &lt;- insertBy $ User (credsIdent creds) Nothing Nothing False
        return $ Just $
            case x of
                Left (Entity userid _) -&gt; userid -- newly added user
                Right userid -&gt; userid -- existing user

    authHttpManager = error "Email doesn't need an HTTP manager"

-- Here's all of the email-specific code
instance YesodAuthEmail MyEmailApp where
    type AuthEmailId MyEmailApp = UserId

    addUnverified email verkey =
        runDB $ insert $ User email Nothing (Just verkey) False

    sendVerifyEmail email _ verurl =
        liftIO $ renderSendMail (emptyMail $ Address Nothing "noreply")
            { mailTo = [Address Nothing email]
            , mailHeaders =
                [ ("Subject", "Verify your email address")
                ]
            , mailParts = [[textPart, htmlPart]]
            }
      where
        textPart = Part
            { partType = "text/plain; charset=utf-8"
            , partEncoding = None
            , partFilename = Nothing
            , partContent = Data.Text.Lazy.Encoding.encodeUtf8 [stext|
Please confirm your email address by clicking on the link below.

\#{verurl}

Thank you
|]
            , partHeaders = []
            }
        htmlPart = Part
            { partType = "text/html; charset=utf-8"
            , partEncoding = None
            , partFilename = Nothing
            , partContent = renderHtml [shamlet|
&lt;p&gt;Please confirm your email address by clicking on the link below.
&lt;p&gt;
    &lt;a href=#{verurl}&gt;#{verurl}
&lt;p&gt;Thank you
|]
            , partHeaders = []
            }
    getVerifyKey = runDB . fmap (join . fmap userVerkey) . get
    setVerifyKey uid key = runDB $ update uid [UserVerkey =. Just key]
    verifyAccount uid = runDB $ do
        mu &lt;- get uid
        case mu of
            Nothing -&gt; return Nothing
            Just u -&gt; do
                update uid [UserVerified =. True]
                return $ Just uid
    getPassword = runDB . fmap (join . fmap userPassword) . get
    setPassword uid pass = runDB $ update uid [UserPassword =. Just pass]
    getEmailCreds email = runDB $ do
        mu &lt;- getBy $ UniqueUser email
        case mu of
            Nothing -&gt; return Nothing
            Just (Entity uid u) -&gt; return $ Just EmailCreds
                { emailCredsId = uid
                , emailCredsAuthId = Just uid
                , emailCredsStatus = isJust $ userPassword u
                , emailCredsVerkey = userVerkey u
                }
    getEmail = runDB . fmap (fmap userEmail) . get

getRootR :: Handler RepHtml
getRootR = do
    maid &lt;- maybeAuthId
    defaultLayout [whamlet|
&lt;p&gt;Your current auth ID: #{show maid}
$maybe _ &lt;- maid
    &lt;p&gt;
        &lt;a href=@{AuthR LogoutR}&gt;Logout
$nothing
    &lt;p&gt;
        &lt;a href=@{AuthR LoginR}&gt;Go to the login page
|]

main :: IO ()
main = withSqliteConn "email.db3" $ \conn -&gt; do
    runSqlConn (runMigration migrateAll) conn
    warpDebug 3000 $ MyEmailApp conn</programlisting>
   </section>
   <section>
    <title>Authorization</title>
    <para/>
    <para>Once you can authenticate your users, you can use their credentials to <emphasis>authorize</emphasis> requests. Authorization in Yesod is simple and declarative: most of
            the time, you just need to add the <literal>authRoute</literal> and
                <literal>isAuthorized</literal> methods to your Yesod typeclass instance. Let's see an
            example.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TemplateHaskell, TypeFamilies,
             MultiParamTypeClasses, QuasiQuotes #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Dummy -- just for testing, don't use in real life!!!
import Data.Text (Text)
import Network.HTTP.Conduit (Manager, newManager, def)

data MyAuthSite = MyAuthSite
    { httpManager :: Manager
    }

mkYesod "MyAuthSite" [parseRoutes|
/ RootR GET POST
/admin AdminR GET
/auth AuthR Auth getAuth
|]

instance Yesod MyAuthSite where
    authRoute _ = Just $ AuthR LoginR

    -- route name, then a boolean indicating if it's a write request
    isAuthorized RootR True = isAdmin
    isAuthorized AdminR _ = isAdmin

    -- anyone can access other pages
    isAuthorized _ _ = return Authorized

isAdmin = do
    mu &lt;- maybeAuthId
    return $ case mu of
        Nothing -&gt; AuthenticationRequired
        Just "admin" -&gt; Authorized
        Just _ -&gt; Unauthorized "You must be an admin"

instance YesodAuth MyAuthSite where
    type AuthId MyAuthSite = Text
    getAuthId = return . Just . credsIdent

    loginDest _ = RootR
    logoutDest _ = RootR

    authPlugins _ = [authDummy]

    authHttpManager = httpManager

instance RenderMessage MyAuthSite FormMessage where
    renderMessage _ _ = defaultFormMessage

getRootR :: Handler RepHtml
getRootR = do
    maid &lt;- maybeAuthId
    defaultLayout [whamlet|
&lt;p&gt;Note: Log in as "admin" to be an administrator.
&lt;p&gt;Your current auth ID: #{show maid}
$maybe _ &lt;- maid
    &lt;p&gt;
        &lt;a href=@{AuthR LogoutR}&gt;Logout
&lt;p&gt;
    &lt;a href=@{AdminR}&gt;Go to admin page
&lt;form method=post&gt;
    Make a change (admins only)
    \ #
    &lt;input type=submit&gt;
|]

postRootR :: Handler ()
postRootR = do
    setMessage "You made some change to the page"
    redirect RootR

getAdminR :: Handler RepHtml
getAdminR = defaultLayout [whamlet|
&lt;p&gt;I guess you're an admin!
&lt;p&gt;
    &lt;a href=@{RootR}&gt;Return to homepage
|]

main :: IO ()
main = do
    manager &lt;- newManager def
    warpDebug 3000 $ MyAuthSite manager</programlisting>
    <para>
     <literal>authRoute</literal> should be your login page, almost always
                <literal>AuthR</literal>
     <literal>LoginR</literal>. <literal>isAuthorized</literal> is a function that takes two
            parameters: the requested route, and whether or not the request was a "write" request.
            You can actually change the meaning of what a write request is using the
                <literal>isWriteRequest</literal> method, but the out-of-the-box version follows
            RESTful principles: anything but a <literal>GET</literal>, <literal>HEAD</literal>,
                <literal>OPTIONS</literal> or <literal>TRACE</literal> request is a write request.</para>
    <para>What's convenient about the body of <literal>isAuthorized</literal> is that you can run
            any <literal>Handler</literal> code you want. This means you can:</para>
    <itemizedlist>
     <listitem>
      <para>Access the filesystem (normal IO)</para>
     </listitem>
     <listitem>
      <para>Lookup values in the database</para>
     </listitem>
     <listitem>
      <para>Pull any session or request values you want</para>
     </listitem>
    </itemizedlist>
    <para>Using these techniques, you can develop as sophisticated an authorization system as you like,
   or even tie into existing systems used by your organization.</para>
   </section>
   <section>
    <title>Conclusion</title>
    <para/>
    <para>This chapter covered the basics of setting up user authentication, as well as how the built-in
   authorization functions provide a simple, declarative approach for users. While these are
   complicated concepts, with many approaches, Yesod should provide you with the building blocks you
   need to create your own customized auth solution.</para>
   </section>
  </chapter>
  <chapter>
   <title>Scaffolding and the Site Template</title>
   <para/>
   <para/>
   <para>So you're tired of running small examples, and ready to write a real site? Then you're at
            the right chapter. Even with the entire Yesod library at your fingertips, there are
            still a lot of steps you need to go through to get a production-quality site setup:</para>
   <itemizedlist>
    <listitem>
     <para>Config file parsing</para>
    </listitem>
    <listitem>
     <para>Signal handling (*nix)</para>
    </listitem>
    <listitem>
     <para>More efficient static file serving</para>
    </listitem>
    <listitem>
     <para>A good file layout</para>
    </listitem>
   </itemizedlist>
   <para>The scaffolded site is a combination of many Yesoders' best practices combined together
            into a ready-to-use skeleton for your sites. It is highly recommended for all sites.
            This chapter will explain the overall structure of the scaffolding, how to use it, and
            some of its less-than-obvious features.</para>
   <para>For the most part, this chapter will not contain code samples. It is recommended that you
            follow along with an actual scaffolded site.</para>
   <note>
    <para>Due to the nature of the scaffolded site, it is the most fluid component of Yesod, and
            can change from version to version. It is possible that the information in this chapter
            is slightly outdated.</para>
   </note>
   <section>
    <title>How to Scaffold</title>
    <para/>
    <para>The <function>yesod</function> package installs both a library and an
   executable (conveniently named <command>yesod</command> as well). This executable
   provides a few commands (run <command>yesod</command> by itself to get a list). In order to
   generate a scaffolding, the command is <command>yesod init</command>. This will start a
   question-and-answer process where you get to provide basic details (your name, the project name,
   etc). After answering the questions, you will have a site template in a subfolder with the name
   of your project.</para>
    <para>The most important of these questions is the database backend. You get four choices here:
   SQLite, PostgreSQL, MongoDB, and tiny. tiny is not a database backend; instead, it is specifying
   that you do not want to use any database. This option also turns off a few extra dependencies,
   giving you a leaner overall site. The remainder of this chapter will focus on the scaffoldings
   for one of the database backends. There will be minor differences for the tiny backend.</para>
    <para>After creating your files, the scaffolder will print a message about getting started.
   It gives two sets of options for commands: one using <command>cabal</command>, and the other
   using <command>cabal-dev</command>. <command>cabal-dev</command> is basically a wrapper around
   cabal which causes all dependencies to be built in a sandbox. Using it is a good way to ensure
   that installing other packages will not break your site setup. It is strongly recommended. If you
   don't have <command>cabal-dev</command>, you can install it by running <command>cabal
    install cabal-dev</command>.</para>
    <para>Note that you really do need to use the <command>cabal install
    --only-dependencies</command> (or <command>cabal-dev install
    --only-dependencies</command>) command. Most likely, you do not yet have all the dependencies in
   place needed by your site. For example, none of the database backends, nor the Javascript
   minifier (<function>hjsmin</function>) are installed when installing the <literal>yesod</literal> package.</para>
    <para>Finally, to launch your development site, you would use <command>yesod
    devel</command> (or <command>yesod --dev devel</command>). This site will
   automatically rebuild and reload whenever you change your code.</para>
   </section>
   <section>
    <title>File Structure</title>
    <para/>
    <para>The scaffolded site is built as a fully cabalized Haskell package. In addition to
   source files, config files, templates, and static files are produced as well.</para>
    <section>
     <title>Cabal file</title>
     <para/>
     <para>Whether directly using <command>cabal</command>, or indirectly using <command>yesod devel</command>, building your code will always go through the cabal file. If
      you open the file, you'll see that there are both library and executable blocks. Only one of
      these is built at a time, depending on the value of the <literal>library-only</literal>
      flag. If <literal>library-only</literal> is turned on, then the library is built, which
      is how <command>yesod devel</command> calls your app. Otherwise, the executable is
      built.</para>
     <para>The <literal>library-only</literal> flag should only be used by
        <command>yesod devel</command>; you should never be explicitly passing it into
        <command>cabal</command>. There is an additional flag, <literal>dev</literal>, that
      allows cabal to build an executable, but turns on some of the same features as
      the library-only flag, i.e., no optimizations and reload versions of the Shakespearean
      template functions.</para>
     <para>In general, you will build as follows:</para>
     <itemizedlist>
      <listitem>
       <para>When developing, use <command>yesod devel</command> exclusively.</para>
      </listitem>
      <listitem>
       <para>When building a production build, perform <command>cabal clean
          &amp;&amp; cabal configure &amp;&amp; cabal build</command>. This will produce an
        optimized executable in your <filename>dist</filename> folder.<note>
         <para>In the past we
          had a <literal>-fproduction</literal> flag. If you produced a scaffolded site in the past,
          you may have to use this flag to get a production build.</para>
        </note>
       </para>
      </listitem>
     </itemizedlist>
     <para>You'll also notice that we specify all language extensions in the cabal file. The
      extensions are specified <emphasis>twice</emphasis>: once for the executable, and once for the
      library. If you add any extensions to the list, add it to both places.</para>
     <para>You might be surprised to see the <literal>NoImplicitPrelude</literal> extension. We turn this
      on since the site includes its own module, <literal>Import</literal>, with a few changes to the
      Prelude that make working with Yesod a little more convenient.</para>
     <para>The last thing to note is the exported-modules list. If you add any modules to your
      application, you <emphasis role="bold">must</emphasis> update this list to get yesod devel to work correctly.
      Unfortunately, neither Cabal nor GHC will give you a warning if you forgot to make this
      update, and instead you'll get a very scary-looking error message from yesod devel.<note>
       <para>One of our planned improvements to <command>yesod devel</command> is to check if
        there are any missing modules.</para>
      </note>
     </para>
    </section>
    <section>
     <title>Routes and entities</title>
     <para/>
     <para>Multiple times in this book, you've seen a comment like "We're declaring our routes/entities
   with quasiquotes for convenience. In a production site, you should use an external file." The
   scaffolding uses such an external file.</para>
     <para>Routes are defined in <filename>config/routes</filename>, and entities in
    <filename>config/models</filename>. They have the exact same syntax as the quasiquoting
   you've seen throughout the book, and <command>yesod devel</command> knows to automatically
   recompile the appropriate modules when these files change.</para>
     <para>The <filename>models</filename> files is referenced by <literal>Model.hs</literal>. You are free to declare whatever you like in this file, but here are some
   guidelines:</para>
     <itemizedlist>
      <listitem>
       <para>Any data types used in <filename>entities</filename>
        <emphasis role="bold">must</emphasis> be imported/declared in <filename>Model.hs</filename>, above the <literal>persistFile</literal> call.</para>
      </listitem>
      <listitem>
       <para>Helper utilities should either be declared in <literal>Import.hs</literal>
    or, if very model-centric, in a file within the <literal>Model</literal> folder and
    imported into <filename>Import.hs</filename>.</para>
      </listitem>
     </itemizedlist>
    </section>
    <section>
     <title>Foundation and Application modules</title>
     <para/>
     <para>The <literal>mkYesod</literal> function which we have used throughout the book declares a few
   things:</para>
     <itemizedlist>
      <listitem>
       <para>Route type</para>
      </listitem>
      <listitem>
       <para>Route render function</para>
      </listitem>
      <listitem>
       <para>Dispatch function</para>
      </listitem>
     </itemizedlist>
     <para>The dispatch function refers to all of the handler functions, and therefore all of those must
   either be defined in the same file as the dispatch function, or be imported by the dispatch
   function.</para>
     <para>Meanwhile, the handler functions will almost certainly refer to the route type. Therefore,
    <emphasis>they</emphasis> must be either in the same file where the route type is defined, or must import that
   file. If you follow the logic here, your entire application must essentially live in a single
   file!</para>
     <para>Clearly this isn't what we want. So instead of using <literal>mkYesod</literal>, the scaffolding
   site uses a decomposed version of the function. <literal>Foundation</literal> calls
    <literal>mkYesodData</literal>, which declares the route type and render function. Since it does
   not declare the dispatch function, the handler functions need not be in scope.
    <literal>Import.hs</literal> imports <literal>Foundation.hs</literal>, and all the handler modules
   import <literal>Import.hs</literal>.</para>
     <para>In <literal>Application.hs</literal>, we call <literal>mkYesodDispatch</literal>, which creates our
   dispatch function. For this to work, all handler functions must be in scope, so be sure to add an
   import statement for any new handler modules you create.</para>
     <para>Other than that, <filename>Application.hs</filename> is pretty simple. It provides
   two functions: <literal>withDevelAppPort</literal> is used by <command>yesod
    devel</command> to launch your app, and <literal>getApplication</literal> is used by the
   executable to launch.</para>
     <para>
      <filename>Foundation.hs</filename> is much more exciting. It:</para>
     <itemizedlist>
      <listitem>
       <para>Declares your foundation datatype</para>
      </listitem>
      <listitem>
       <para>Declares a number of instances, such as <literal>Yesod</literal>,
     <literal>YesodAuth</literal>, and <literal>YesodPersist</literal>
       </para>
      </listitem>
      <listitem>
       <para>Imports the messages files. If you look for the line starting with <literal>mkMessage</literal>, you will see that it specifies the folder containing the messages
     (<filename>messages</filename>) and the default language (en, for English).</para>
      </listitem>
     </itemizedlist>
     <para>This is the right file for adding extra instances for your foundation, such as
    <literal>YesodAuthEmail</literal> or <literal>YesodBreadcrumbs</literal>.</para>
     <para>We'll be referring back to this file later, as we discussed some of the special
   implementations of <literal>Yesod</literal> typeclass methods.</para>
    </section>
    <section>
     <title>Import</title>
     <para/>
     <para>The <literal>Import</literal> module was born out of a few commonly recurring
   patterns.</para>
     <itemizedlist>
      <listitem>
       <para>I want to define some helper functions (maybe the <literal>&lt;&gt; = mappend</literal> operator)
    to be used by all handlers.</para>
      </listitem>
      <listitem>
       <para>I'm always adding the same five import statements (<literal>Data.Text</literal>,
     <literal>Control.Applicative</literal>, etc) to every handler module.</para>
      </listitem>
      <listitem>
       <para>I want to make sure I never use some evil function (<literal>head</literal>,
     <literal>readFile</literal>, ...) from <literal>Prelude</literal>.<note>
         <para>Yes, evil is
     hyperbole. If you're wondering why I listed those functions as bad: <literal>head</literal> is partial, and throws exceptions on an empty list, and <literal>readFile</literal> uses lazy I/O, which doesn't close file handles quickly enough. Also,
      <literal>readFile</literal> uses <literal>String</literal> instead of
     <literal>Text</literal>.</para>
        </note>
       </para>
      </listitem>
     </itemizedlist>
     <para>The solution is to turn on the <literal>NoImplicitPrelude</literal> language extension,
   re-export the parts of <literal>Prelude</literal> we want, add in all the other stuff we want,
   define our own functions as well, and then import this file in all handlers.</para>
    </section>
    <section>
     <title>Handler modules</title>
     <para/>
     <para>Handler modules should go inside the <filename>Handler</filename> folder. The site
   template includes one module: <filename>Handler/Root.hs</filename>. How you split up your handler
   functions into individual modules is your decision, but a good rule of thumb is:</para>
     <itemizedlist>
      <listitem>
       <para>Different methods for the same route should go in the same file, e.g.
     <literal>getBlogR</literal> and <literal>postBlogR</literal>.</para>
      </listitem>
      <listitem>
       <para>Related routes can also usually go in the same file, e.g.,
     <literal>getPeopleR</literal> and <literal>getPersonR</literal>.</para>
      </listitem>
     </itemizedlist>
     <para>Of course, it's entirely up to you. When you add a new handler file, make sure you do the
   following:</para>
     <itemizedlist>
      <listitem>
       <para>Add it to version control (you <emphasis>are</emphasis> using version control, right?).</para>
      </listitem>
      <listitem>
       <para>Add it to the cabal file.</para>
      </listitem>
      <listitem>
       <para>Add it to the <filename>Application.hs</filename> file.</para>
      </listitem>
      <listitem>
       <para>Put a module statement at the top, and an <literal>import Import</literal> line below it.</para>
      </listitem>
     </itemizedlist>
     <note>
      <para>One of the planned improvements to the <command>yesod</command> executable is to automate
   these four steps.</para>
     </note>
    </section>
   </section>
   <section>
    <title>widgetFile</title>
    <para/>
    <para>It's very common to want to include CSS and Javascript specific to a page. You don't want to
   have to remember to include those Lucius and Julius files manually every time you refer to a
   Hamlet file. For this, the site template provides the <literal>widgetFile</literal> function.</para>
    <para>If you have a handler function:</para>
    <programlisting language="haskell">getRootR = defaultLayout $(widgetFile "homepage")</programlisting>
    <para>, Yesod will look for the following files:</para>
    <itemizedlist>
     <listitem>
      <para>
       <filename>templates/homepage.hamlet</filename>
      </para>
     </listitem>
     <listitem>
      <para>
       <filename>templates/homepage.lucius</filename>
      </para>
     </listitem>
     <listitem>
      <para>
       <filename>templates/homepage.cassius</filename>
      </para>
     </listitem>
     <listitem>
      <para>
       <filename>templates/homepage.julius</filename>
      </para>
     </listitem>
    </itemizedlist>
    <para>If any of those files are present, they will be automatically included in the output.</para>
    <note>
     <para>Due to the nature of how this works, if you launch your app with <command>yesod
    devel</command>, and then create a new file (e.g.,
    <filename>templates/homepage.julius</filename>), the contents will <emphasis>not</emphasis> be
   included until the file calling <literal>widgetFile</literal> is recompiled. In such a case, you
   may need to force a save of that file to get <command>yesod devel</command> to recompile.</para>
    </note>
   </section>
   <section>
    <title>defaultLayout</title>
    <para/>
    <para>One of the first things you're going to want to customize is the look of your site. The layout
   is actually broken up into two files:</para>
    <itemizedlist>
     <listitem>
      <para>
       <filename>templates/default-layout-wrapper.hamlet</filename> contains just the basic shell of
    a page. This file is interpreted as plain Hamlet, not as a Widget, and therefore cannot refer
    to other widgets, embed i18n strings, or add extra CSS/JS.</para>
     </listitem>
     <listitem>
      <para>
       <filename>templates/default-layout.hamlet</filename> is where you would put the bulk of your
    page. You <emphasis role="bold">must</emphasis> remember to include the <literal>widget</literal> value in the page, as that
    contains the per-page contents. This file is interpreted as a Widget.</para>
     </listitem>
    </itemizedlist>
    <para>Also, since default-layout is included via the <literal>widgetFile</literal> function,
   any Lucius, Cassius, or Julius files named <filename>default-layout.*</filename> will
   automatically be included as well.</para>
   </section>
   <section>
    <title>Static files</title>
    <para/>
    <para>The scaffolded site automatically includes the static file subsite, optimized for
   serving files that will not change over the lifetime of the current build. What this means is
   that:</para>
    <itemizedlist>
     <listitem>
      <para>When your static file identifiers are generated (e.g.,
     <filename>static/mylogo.png</filename> becomes <literal>mylogo_png</literal>), a query-string
    parameter is added to it with a hash of the contents of the file. All of this happens at compile
    time.</para>
     </listitem>
     <listitem>
      <para>When <literal>yesod-static</literal> serves your static files, it sets expiration
    headers far in the future, and incldues an etag based on a hash of your content.</para>
     </listitem>
     <listitem>
      <para>Whenever you embed a link to <literal>mylogo_png</literal>, the rendering includes the
    query-string parameter. If you change the logo, recompile, and launch your new app, the query
    string will have changed, causing users to ignore the cached copy and download a new
    version.</para>
     </listitem>
    </itemizedlist>
    <para>Additionally, you can set a specific static root in your
    <filename>Settings.hs</filename> file to serve from a different domain name. This has the
   advantage of not requiring transmission of cookies for static file requests, and also lets you
   offload static file hosting to a CDN or a service like Amazon S3. See the comments in the file
   for more details.</para>
    <para>Another optimization is that CSS and Javascript included in your widgets will not be included
   inside your HTML. Instead, their contents will be written to an external file, and a link given.
   This file will be named based on a hash of the contents as well, meaning:</para>
    <orderedlist>
     <listitem>
      <para>Caching works properly.</para>
     </listitem>
     <listitem>
      <para>Yesod can avoid an expensive disk write of the CSS/Javascript file contents if a file with
    the same hash already exists.</para>
     </listitem>
    </orderedlist>
    <para>Finally, all of your Javascript is automatically minified via <function>hjsmin</function>.</para>
   </section>
   <section>
    <title>Conclusion</title>
    <para/>
    <para>The purpose of this chapter was not to explain every line that exists in the scaffolded site,
   but instead to give a general overview to how it works. The best way to become more familiar with
   it is to jump right in and start writing a Yesod site with it.</para>
   </section>
  </chapter>
  <chapter>
   <title>Internationalization</title>
   <para/>
   <para/>
   <para>Users expect our software to speak their language. Unfortunately for us, there
            will likely be more than one language involved. While doing simple string replacement
            isn't too involved, correctly dealing with all the grammar issues can be tricky. After
            all, who wants to see "List 1 file(s)" from a program output?</para>
   <para>But a real i18n solution needs to do more than just provide a means of achieving the
            correct output. It needs to make this process easy for both the programmer and the
            translator and relatively error-proof. Yesod's answer to the problem gives you:</para>
   <itemizedlist>
    <listitem>
     <para>Intelligent guessing of the user's desired language based on request headers, with
                the ability to override.</para>
    </listitem>
    <listitem>
     <para>A simple syntax for giving translations which requires no Haskell knowledge. (After
                all, most translators aren't programmers.)</para>
    </listitem>
    <listitem>
     <para>The ability to bring in the full power of Haskell for tricky grammar issues as
                necessary, along with a default selection of helper functions to cover most
                needs.</para>
    </listitem>
    <listitem>
     <para>Absolutely no issues at all with word order.</para>
    </listitem>
   </itemizedlist>
   <section>
    <title>Synopsis</title>
    <para/>
    <programlisting>-- @messages/en.msg
Hello: Hello
EnterItemCount: I would like to buy: 
Purchase: Purchase
ItemCount count@Int: You have purchased #{showInt count} #{plural count "item" "items"}.
SwitchLanguage: Switch language to: 
Switch: Switch</programlisting>
    <programlisting>-- @messages/he.msg
Hello: שלום
EnterItemCount: אני רוצה לקנות: 
Purchase: קנה
ItemCount count: קנית #{showInt count} #{plural count "דבר" "דברים"}.
SwitchLanguage: החלף שפה ל:
Switch: החלף</programlisting>
    <programlisting language="haskell">-- @i18n-synopsis.hs
{-# LANGUAGE OverloadedStrings, QuasiQuotes, TemplateHaskell, TypeFamilies,
    MultiParamTypeClasses #-}
import Yesod

data I18N = I18N

mkMessage "I18N" "messages" "en"

plural :: Int -&gt; String -&gt; String -&gt; String
plural 1 x _ = x
plural _ _ y = y

showInt :: Int -&gt; String
showInt = show

instance Yesod I18N

instance RenderMessage I18N FormMessage where
    renderMessage _ _ = defaultFormMessage

mkYesod "I18N" [parseRoutes|
/ RootR GET
/buy BuyR GET
/lang LangR POST
|]

getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;h1&gt;_{MsgHello}
&lt;form action=@{BuyR}&gt;
    _{MsgEnterItemCount}
    &lt;input type=text name=count&gt;
    &lt;input type=submit value=_{MsgPurchase}&gt;
&lt;form action=@{LangR} method=post&gt;
    _{MsgSwitchLanguage}
    &lt;select name=lang&gt;
        &lt;option value=en&gt;English
        &lt;option value=he&gt;Hebrew
    &lt;input type=submit value=_{MsgSwitch}&gt;
|]

getBuyR :: Handler RepHtml
getBuyR = do
    count &lt;- runInputGet $ ireq intField "count"
    defaultLayout [whamlet|
&lt;p&gt;_{MsgItemCount count}
|]

postLangR :: Handler ()
postLangR = do
    lang &lt;- runInputPost $ ireq textField "lang"
    setLanguage lang
    redirect RootR

main :: IO ()
main = warpDebug 3000 I18N</programlisting>
   </section>
   <section>
    <title>Overview</title>
    <para/>
    <para>Most existing i18n solutions out there, like gettext or Java message bundles, work on the
   principle of string lookups. Usually some form of printf-interpolation is used to interpolate
   variables into the strings. In Yesod, as you might guess, we instead rely on types. This gives us
   all of our normal advantages, such as the compiler automatically catching mistakes.</para>
    <para>Let's take a concrete example. Suppose our application has two things it wants to say
   to a user: say hello, and state how many users are logged into the system. This can be modeled
   with a sum type:</para>
    <programlisting language="haskell">data MyMessage = MsgHello | MsgUsersLoggedIn Int</programlisting>
    <para>I can also write a function to turn this datatype into an English representation:</para>
    <programlisting language="haskell">toEnglish :: MyMessage -&gt; String
toEnglish MsgHello = "Hello there!"
toEnglish (MsgUsersLoggedIn 1) = "There is 1 user logged in."
toEnglish (MsgUsersLoggedIn i) = "There are " ++ show i ++ " users logged in."</programlisting>
    <para>We can also write similar functions for other languages. The advantage to this
   inside-Haskell approach is that we have the full power of Haskell for addressing tricky grammar
   issues, especially pluralization.</para>
    <note>
     <para>You may think pluralization isn't so complicated: you have one version for 1 item, and
   another for any other count. That might be true in English, but it's not true for every language.
   Russian, for example, has six different forms, and you need to use some modulus logic to
   determine which one to use.</para>
    </note>
    <para>The downside, however, is that you have to write all of this inside of Haskell, which won't be
   very translator-friendly. To solve this, Yesod introduces the concept of message files. We'll
   cover that in a little bit.</para>
    <para>Assuming we have this full set of translation functions, how do we go about using
   them? What we need is a new function to wrap them all up together, and then choose the
   appropriate translation function based on the user's selected language. Once we have that, Yesod
   can automatically choose the most relevant render function and call it on the values you
   provide.</para>
    <para>In order to simplify things a bit, Hamlet has a special interpolation syntax,
    <literal>_{...}</literal>, which handles all the calls to the render functions. And in order to
   associate a render function with your application, you use the <literal>YesodMessage</literal>
   typeclass.</para>
   </section>
   <section>
    <title>Message files</title>
    <para/>
    <para>The simplest approach to creating translations is via <glossterm>message
    files</glossterm>. The setup is simple: there is a single folder containing all of your translation
   files, with a single file for each language. Each file is named based on its language code, e.g.
    <filename>en.msg</filename>. And each line in a file handles one phrase, which
   correlates to a single constructor in your message data type.</para>
    <note>
     <para>The scaffolded site already includes a fully configured message folder.</para>
    </note>
    <para>So firstly, a word about language codes. There are really two choices available: using a
   two-letter language code, or a language-LOCALE code. For example, when I load up a page in my web
   browser, it sends two language codes: en-US and en. What my browser is saying is "if you have
   American English, I like that the most. If you have English, I'll take that instead."</para>
    <para>So which format should you use in your application? Most likely two-letter codes,
   unless you are actually creating separate translations by locale. This ensures that someone
   asking for Canadian English will still see your English. Behind the scenes, Yesod will add the
   two-letter codes where relevant. For example, suppose a user has the following language
   list:<programlisting>pt-BR, es, he</programlisting>What this means is "I like Brazilian Porteguese, then
   Spanish, and then Hebrew." Suppose your application provides the languages pt (general
   Porteguese) and English, with English as the default. Strictly following the user's language list
   would result in the user being served English. Instead, Yesod translates that list
   into:<programlisting>pt-BR, es, he, pt</programlisting>In other words: unless you're giving different
   translations based on locale, just stick to the two-letter language codes.</para>
    <para>Now what about these message files? The syntax should be very familiar after your work
   with Hamlet and Persistent. The line starts off with the name of the message. Since this is a
   data constructor, it must start with a capital letter. Next, you can have individual parameters,
   which must be given as lower case. These will be arguments to the data constructor.</para>
    <para>The argument list is terminated by a colon, and then followed by the translated string, which
   allows usage of our typical variable interpolation syntax <literal>#{myVar}</literal>. By referring
   to the parameters defined before the colon, and using translation helper functions to deal with
   issues like pluralization, you can create all the translated messages you need.</para>
    <section>
     <title>Specifying types</title>
     <para/>
     <para>Since we will be creating a datatype out of our message specifications, each parameter
   to a data constructor must be given a data type. We use a @-syntax for this. For example, to
   create the datatype <literal>data MyMessage = MsgHello | MsgSayAge Int</literal>, we would
   write:</para>
     <programlisting>Hello: Hi there!
SayAge age@Int: Your age is: #{show age}</programlisting>
     <para>But there are two problems with this:</para>
     <orderedlist>
      <listitem>
       <para>It's not very DRY (don't repeat yourself) to have to specify this datatype in every
    file.</para>
      </listitem>
      <listitem>
       <para>Translators will be confused having to specify these datatypes.</para>
      </listitem>
     </orderedlist>
     <para>So instead, the type specification is only required in the main language file. This is
   specified as the third argument in the <literal>mkMessage</literal> function. This also specifies
   what the backup language will be, to be used when none of the languages provided by your
   application match the user's language list.</para>
    </section>
   </section>
   <section>
    <title>RenderMessage typeclass</title>
    <para/>
    <para>Your call to <literal>mkMessage</literal> creates an instance of the
    <literal>RenderMessage</literal> typeclass, which is the core of Yesod's i18n. It is defined
   as:</para>
    <programlisting language="haskell">class RenderMessage master message where
    renderMessage :: master
                  -&gt; [Text] -- ^ languages
                  -&gt; message
                  -&gt; Text </programlisting>
    <para>Notice that there are two parameters to the <literal>RenderMessage</literal> class: the
   master site and the message type. In theory, we could skip the master type here, but that would
   mean that every site would need to have the same set of translations for each message type. When
   it comes to shared libraries like forms, that would not be a workable solution.</para>
    <para>The <literal>renderMessage</literal> function takes a parameter for each of the class's
   type parameters: master and message. The extra parameter is a list of languages the user will
   accept, in descending order of priority. The method then returns a user-ready
    <literal>Text</literal> that can be displayed.</para>
    <para>A simple instance of <literal>RenderMessage</literal> may involve no actual translation
   of strings; instead, it will just display the same value for every language. For example:</para>
    <programlisting language="haskell">data MyMessage = Hello | Greet Text
instance RenderMessage MyApp MyMessage where
    renderMessage _ _ Hello = "Hello"
    renderMessage _ _ (Greet name) = "Welcome, " &lt;&gt; name &lt;&gt; "!"</programlisting>
    <para>Notice how we ignore the first two parameters to <literal>renderMessage</literal>. We
   can now extend this to support multiple languages:</para>
    <programlisting language="haskell">renderEn Hello = "Hello"
renderEn (Greet name) = "Welcome, " &lt;&gt; name &lt;&gt; "!"
renderHe Hello = "שלום"
renderHe (Greet name) = "ברוכים הבאים, " &lt;&gt; name &lt;&gt; "!"
instance RenderMessage MyApp MyMessage where
    renderMessage _ ("en":_) = renderEn
    renderMessage _ ("he":_) = renderHe
    renderMessage master (_:langs) = renderMessage master langs
    renderMessage _ [] = renderEn</programlisting>
    <para>The idea here is fairly straight-forward: we define helper functions to support each language.
   We then add a clause to catch each of those languages in the renderMessage definition. We then
   have two final cases: if no languages matched, continue checking with the next language in the
   user's priority list. If we've exhausted all languages the user specified, then use the default
   language (in our case, English).</para>
    <para>But odds are that you will never need to worry about writing this stuff manually, as the
   message file interface does all this for you. But it's always a good idea to have an
   understanding of what's going on under the surface.</para>
   </section>
   <section>
    <title>Interpolation</title>
    <para/>
    <para>One way to use your new <literal>RenderMessage</literal> instance would be to directly
   call the <literal>renderMessage</literal> function. This would work, but it's a bit
   tedious: you need to pass in the foundation value and the language list manually. Instead, Hamlet
   provides a specialized i18n interpolation, which looks like <literal>_{...}</literal>.</para>
    <note>
     <para>Why the underscore? Underscore is already a well-established character for i18n, as it is
   used in the gettext library.</para>
    </note>
    <para>Hamlet will then automatically translate that to a call to <literal>renderMessage</literal>. Once Hamlet gets the output <literal>Text</literal> value, it uses the
    <literal>toHtml</literal> function to produce an <literal>Html</literal> value,
   meaning that any special characters (&lt;, &amp;, &gt;) will be automatically escaped.</para>
   </section>
   <section>
    <title>Phrases, not words</title>
    <para/>
    <para>As a final note, I'd just like to give some general i18n advice. Let's say you have an
   application for selling turtles. You're going to use the word "turtle" in multiple places, like
   "You have added 4 turtles to your cart." and "You have purchased 4 turtles, congratulations!" As
   a programmer, you'll immediately notice the code reuse potential: we have the phrase "4 turtles"
   twice. So you might structure your message file as:</para>
    <programlisting>AddStart: You have added
AddEnd: to your cart.
PurchaseStart: You have purchased
PurchaseEnd: , congratulations!
Turtles count@Int: #{show count} #{plural count "turtle" "turtles"}</programlisting>
    <para>STOP RIGHT THERE! This is all well and good from a programming perspective, but
   translations are <emphasis>not</emphasis> programming. There are a many things that could go wrong
   with this, such as:</para>
    <itemizedlist>
     <listitem>
      <para>Some languages might put "to your cart" before "You have added."</para>
     </listitem>
     <listitem>
      <para>Maybe "added" will be constructed differently depending whether you added 1 or more
    turtles.</para>
     </listitem>
     <listitem>
      <para>There are a bunch of whitespace issues as well.</para>
     </listitem>
    </itemizedlist>
    <para>So the general rule is: translate entire phrases, not just words.</para>
   </section>
  </chapter>
  <chapter>
   <title>Creating a Subsite</title>
   <para/>
   <para/>
   <para>How many sites provide authentication systems? Or need to provide CRUD (CRUD) management of some objects? Or a blog? Or a wiki?</para>
   <para>The theme here is that many websites include common components that can be reused throughout multiple sites. However, it is often quite difficult to get code to be modular enough to be truly plug-and-play: a component will require hooks into the routing system, usually for multiple routes, and will need some way of sharing styling information with the master site.</para>
   <para>In Yesod, the solution is subsites. A subsite is a collection of routes and their handlers that can be easily inserted into a master site. By using type classes, it is easy to ensure that the master site provides certain capabilities, and to access the default site layout. And with type-safe URLs, it's easy to link from the master site to subsites.</para>
   <section>
    <title>Hello World</title>
    <para/>
    <para>Writing subsites is a little bit tricky, involving a number of different types. Let's start off with a simple Hello World subsite:</para>
    <programlisting language="haskell">{-# LANGUAGE QuasiQuotes, TypeFamilies, MultiParamTypeClasses #-}
{-# LANGUAGE TemplateHaskell, FlexibleInstances, OverloadedStrings #-}
import Yesod

-- Subsites have foundations just like master sites.
data HelloSub = HelloSub

-- We have a familiar analogue from mkYesod, with just one extra parameter.
-- We'll discuss that later.
mkYesodSub "HelloSub" [] [parseRoutes|
/ SubRootR GET
|]

-- And we'll spell out the handler type signature.
getSubRootR :: Yesod master =&gt; GHandler HelloSub master RepHtml
getSubRootR = defaultLayout [whamlet|Welcome to the subsite!|]

-- And let's create a master site that calls it.
data Master = Master
    { getHelloSub :: HelloSub
    }

mkYesod "Master" [parseRoutes|
/ RootR GET
/subsite SubsiteR HelloSub getHelloSub
|]

instance Yesod Master

-- Spelling out type signature again.
getRootR :: GHandler sub Master RepHtml -- could also replace sub with Master
getRootR = defaultLayout [whamlet|
&lt;h1&gt;Welcome to the homepage
&lt;p&gt;
    Feel free to visit the #
    &lt;a href=@{SubsiteR SubRootR}&gt;subsite
    \ as well.
|]

main = warpDebug 3000 $ Master HelloSub
</programlisting>
    <para>This very simple example actually shows most of the complications involved in creating a subsite. Like a normal Yesod application, everything in a subsite is centered around a foundation datatype, <literal>HelloSub</literal> in our case. We then use <literal>mkYesodSub</literal>, in much the same way that we use <literal>mkYesod</literal>, to create the route datatype and the dispatch/render functions. (We'll come back to that extra parameter in a second.)</para>
    <para>What's interesting is the type signature of <literal>getSubRootR</literal>. Up until now, we have tried to ignore the <literal>GHandler</literal> datatype, or <emphasis>if</emphasis> we need to acknowledge its existence, pretend like the first two type arguments are always the same. Now we get to finally acknowledge the truth about this funny datatype.</para>
    <para>A handler function always has two foundation types associated with it: the subsite and the master site. When you write a normal application, <emphasis role="bold">those two datatypes are the same</emphasis>. However, when you are working in a subsite, they will necessarily be different. So the type signature for <literal>getSubRootR</literal> uses <literal>HelloSub</literal> for the first argument and <literal>master</literal> for the second.</para>
    <para>The <literal>defaultLayout</literal> function is part of the Yesod typeclass. Therefore, in order to call it, the <literal>master</literal> type argument must be an instance of <literal>Yesod</literal>. The advantage of this approach is that any modifications to the master site's <literal>defaultLayout</literal> method will automatically be reflected in subsites.</para>
    <para>When we embed a subsite in our master site route definition, we need to specify four pieces of information: the route to use as the base of the subsite (in this case, <literal>/subsite</literal>), the constructor for the subsite routes (<literal>SubsiteR</literal>), the subsite foundation data type (<literal>HelloSub</literal>) and a function that takes a master foundation value and returns a subsite foundation value (<literal>getHelloSub</literal>).</para>
    <para>In the definition of getRootR, we can see how the route constructor gets used. In a sense, <literal>SubsiteR</literal> promotes any subsite route to a master site route, making it possible to safely link to it from any master site template.</para>
   </section>
  </chapter>
 </part>
 <part>
  <title>Examples</title>
  <chapter>
   <title>Blog: i18n, authentication, authorization, and database</title>
   <para/>
   <para/>
   <programlisting>This is a simple blog app. It allows an admin to add blog posts via a rich text
editor (nicedit), allows logged-in users to comment, and has full i18n support.
It is also a good example of using a Persistent database, leveraging Yesod's
authorization system, and templates.

While in general we recommend placing templates, Persist entity definitions,
and routing in separate files, we'll keep it all in one file here for
convenience. The one exception you'll see below will be i18n messages.

We'll start off with our language extensions. In scaffolded code, the language
extensions are specified in the cabal file, so you won't need to put this in
your individual Haskell files.

&gt; {-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
&gt;              TemplateHaskell, GADTs, FlexibleContexts,
&gt;              MultiParamTypeClasses #-}

Now our imports.

&gt; import Yesod
&gt; import Yesod.Auth
&gt; import Yesod.Form.Nic (YesodNic, nicHtmlField)
&gt; import Yesod.Auth.BrowserId (authBrowserId)
&gt; import Data.Text (Text)
&gt; import Network.HTTP.Conduit (Manager, newManager, def)
&gt; import Database.Persist.Sqlite
&gt;     ( ConnectionPool, SqlPersist, runSqlPool, runMigration
&gt;     , createSqlitePool
&gt;     )
&gt; import Data.Time (UTCTime, getCurrentTime)
&gt; import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;), pure)

First we'll set up our Persistent entities. We're going to both create our data
types (via mkPersist) and create a migration function, which will automatically
create and update our SQL schema. If you were using the MongoDB backend,
migration would not be needed.

&gt; share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|

Keeps track of users. In a more robust application, we would also keep account
creation date, display name, etc.

&gt; User
&gt;    email Text
&gt;    UniqueUser email

An individual blog entry (I've avoided using the word "post" due to the
confusion with the request method POST).

&gt; Entry
&gt;    title Text
&gt;    posted UTCTime
&gt;    content Html

We need to tack on this "deriving" line since Html doesn't specify instances
for Read, Show or Eq. If you get an error message about "cannot derive" in your
    own code, try adding the deriving statement.

&gt;    deriving

And a comment on the blog post.

&gt; Comment
&gt;    entry EntryId
&gt;    posted UTCTime
&gt;    user UserId
&gt;    name Text
&gt;    text Textarea
&gt; |]

Every site has a foundation datatype. This value is initialized before
launching your application, and is available throughout. We'll store a database
connection pool and HTTP connection manager in ours. See the very end of this
file for how those are initialized.

&gt; data Blog = Blog
&gt;    { connPool :: ConnectionPool
&gt;    , httpManager :: Manager
&gt;    }

To make i18n easy and translator friendly, we have a special file format for
translated messages. There is a single file for each language, and each file is
named based on the language code (e.g., en, es, de-DE) and placed in that
folder. We also specify the main language file (here, "en") as a default
language.

&gt; mkMessage "Blog" "../messages-blog" "en"

Our en message file contains the following content:

    NotAnAdmin: You must be an administrator to access this page.

    WelcomeHomepage: Welcome to the homepage
    SeeArchive: See the archive

    NoEntries: There are no entries in the blog
    LoginToPost: Admins can login to post
    NewEntry: Post to blog
    NewEntryTitle: Title
    NewEntryContent: Content

    PleaseCorrectEntry: Your submitted entry had some errors, please correct and try again.
    EntryCreated title@Text: Your new blog post, #{title}, has been created

    EntryTitle title@Text: Blog post: #{title}
    CommentsHeading: Comments
    NoComments: There are no comments
    AddCommentHeading: Add a Comment
    LoginToComment: You must be logged in to comment
    AddCommentButton: Add comment

    CommentName: Your display name
    CommentText: Comment
    CommentAdded: Your comment has been added
    PleaseCorrectComment: Your submitted comment had some errors, please correct and try again.

    HomepageTitle: Yesod Blog Demo
    BlogArchiveTitle: Blog Archive

Now we're going to set up our routing table. We have four entries: a homepage,
an entry list page (BlogR), an individual entry page (EntryR) and our
authentication subsite. Note that BlogR and EntryR both accept GET and POST
methods. The POST methods are for adding a new blog post and adding a new
comment, respectively.

&gt; mkYesod "Blog" [parseRoutes|
&gt; / RootR GET
&gt; /blog BlogR GET POST
&gt; /blog/#EntryId EntryR GET POST
&gt; /auth AuthR Auth getAuth
&gt; |]

Every foundation needs to be an instance of the Yesod typeclass. This is where
we configure various settings.

&gt; instance Yesod Blog where

The base of our application. Note that in order to make BrowserID work
properly, this must be a valid URL.

&gt;     approot = ApprootStatic "http://localhost:3000"

Our authorization scheme. We want to have the following rules:

* Only admins can add a new entry.
* Only logged in users can add a new comment.
* All other pages can be accessed by anyone.

We set up our routes in a RESTful way, where the actions that could make
changes are always using a POST method. As a result, we can simply check for
whether or not a request is a write request, given by the True in the second
field.

First, we'll authorize requests to add a new entry.

&gt;     isAuthorized BlogR True = do
&gt;         mauth &lt;- maybeAuth
&gt;         case mauth of
&gt;             Nothing -&gt; return AuthenticationRequired
&gt;             Just (Entity _ user)
&gt;                 | isAdmin user -&gt; return Authorized
&gt;                 | otherwise    -&gt; unauthorizedI MsgNotAnAdmin

Now we'll authorize requests to add a new comment.

&gt;     isAuthorized (EntryR _) True = do
&gt;         mauth &lt;- maybeAuth
&gt;         case mauth of
&gt;             Nothing -&gt; return AuthenticationRequired
&gt;             Just _  -&gt; return Authorized

And for all other requests, the result is always authorized.

&gt;     isAuthorized _ _ = return Authorized

Where a user should be redirected to if they get an AuthenticationRequired.

&gt;     authRoute _ = Just (AuthR LoginR)

This is where we define our site look-and-feel. The function is given the
content for the individual page, and wraps it up with a standard template.

&gt;     defaultLayout inside = do

Yesod encourages the get-following-post pattern, where after a POST, the user
is redirected to another page. In order to allow the POST page to give the user
some kind of feedback, we have the getMessage and setMessage functions. It's a
good idea to always check for pending messages in your defaultLayout function.

&gt;         mmsg &lt;- getMessage

We use widgets to compose together HTML, CSS and Javascript. At the end of the
day, we need to unwrap all of that into simple HTML. That's what the
widgetToPageContent function is for. We're going to give it a widget consisting
of the content we received from the individual page (inside), plus a standard
CSS for all pages. We'll use the Lucius template language to create the latter.

&gt;         pc &lt;- widgetToPageContent $ do
&gt;             toWidget [lucius|
&gt; body {
&gt;     width: 760px;
&gt;     margin: 1em auto;
&gt;     font-family: sans-serif;
&gt; }
&gt; textarea {
&gt;     width: 400px;
&gt;     height: 200px;
&gt; }
&gt; #message {
&gt;   color: #900;
&gt; }
&gt; |]
&gt;             inside

And finally we'll use a new Hamlet template to wrap up the individual
components (title, head data and body data) into the final output.

&gt;         hamletToRepHtml [hamlet|
&gt; $doctype 5
&gt; &lt;html&gt;
&gt;     &lt;head&gt;
&gt;         &lt;title&gt;#{pageTitle pc}
&gt;         ^{pageHead pc}
&gt;     &lt;body&gt;
&gt;         $maybe msg &lt;- mmsg
&gt;             &lt;div #message&gt;#{msg}
&gt;         ^{pageBody pc}
&gt; |]

This is a simple function to check if a user is the admin. In a real
application, we would likely store the admin bit in the database itself, or
check with some external system. For now, I've just hard-coded my own email
address.

&gt; isAdmin :: User -&gt; Bool
&gt; isAdmin user = userEmail user == "michael@snoyman.com"

In order to access the database, we need to create a YesodPersist instance,
which says which backend we're using and how to run an action.

&gt; instance YesodPersist Blog where
&gt;    type YesodPersistBackend Blog = SqlPersist
&gt;    runDB f = do 
&gt;        master &lt;- getYesod
&gt;        let pool = connPool master
&gt;        runSqlPool f pool

This is a convenience synonym. It is defined automatically for you in the
scaffolding.

&gt; type Form x = Html -&gt; MForm Blog Blog (FormResult x, Widget)

In order to use yesod-form and yesod-auth, we need an instance of RenderMessage
for FormMessage. This allows us to control the i18n of individual form
messages.

&gt; instance RenderMessage Blog FormMessage where
&gt;     renderMessage _ _ = defaultFormMessage

In order to use the built-in nic HTML editor, we need this instance. We just
take the default values, which use a CDN-hosted version of Nic.

&gt; instance YesodNic Blog

In order to use yesod-auth, we need a YesodAuth instance.

&gt; instance YesodAuth Blog where
&gt;     type AuthId Blog = UserId
&gt;     loginDest _ = RootR
&gt;     logoutDest _ = RootR
&gt;     authHttpManager = httpManager

We'll use [BrowserID](https://browserid.org/), which is a third-party system
using email addresses as your identifier. This makes it easy to switch to other
systems in the future, locally authenticated email addresses (also included
with yesod-auth).

&gt;     authPlugins _ = [authBrowserId]

This function takes someone's login credentials (i.e., his/her email address)
and gives back a UserId.

&gt;     getAuthId creds = do
&gt;         let email = credsIdent creds
&gt;             user = User email
&gt;         res &lt;- runDB $ insertBy user
&gt;         return $ Just $ either entityKey id res

Homepage handler. The one important detail here is our usage of `setTitleI`,
which allows us to use i18n messages for the title. We also use this message
with a `_{Msg...}` interpolation in Hamlet.

&gt; getRootR :: Handler RepHtml
&gt; getRootR = defaultLayout $ do
&gt;     setTitleI MsgHomepageTitle
&gt;     [whamlet|
&gt; &lt;p&gt;_{MsgWelcomeHomepage}
&gt; &lt;p&gt;
&gt;    &lt;a href=@{BlogR}&gt;_{MsgSeeArchive}
&gt; |]

Define a form for adding new entries. We want the user to provide the title and
content, and then fill in the post date automatically via `getCurrentTime`.

&gt; entryForm :: Form Entry
&gt; entryForm = renderDivs $ Entry
&gt;     &lt;$&gt; areq textField (fieldSettingsLabel MsgNewEntryTitle) Nothing
&gt;     &lt;*&gt; aformM (liftIO getCurrentTime)
&gt;     &lt;*&gt; areq nicHtmlField (fieldSettingsLabel MsgNewEntryContent) Nothing

Get the list of all blog entries, and present an admin with a form to create a
new entry.

&gt; getBlogR :: Handler RepHtml
&gt; getBlogR = do
&gt;     muser &lt;- maybeAuth
&gt;     entries &lt;- runDB $ selectList [] [Desc EntryPosted]
&gt;     (entryWidget, enctype) &lt;- generateFormPost entryForm
&gt;     defaultLayout $ do
&gt;         setTitleI MsgBlogArchiveTitle
&gt;         [whamlet|
&gt; $if null entries
&gt;     &lt;p&gt;_{MsgNoEntries}
&gt; $else
&gt;     &lt;ul&gt;
&gt;         $forall Entity entryId entry &lt;- entries
&gt;             &lt;li&gt;
&gt;                 &lt;a href=@{EntryR entryId}&gt;#{entryTitle entry}

We have three possibilities: the user is logged in as an admin, the user is
logged in and is not an admin, and the user is not logged in. In the first
case, we should display the entry form. In the second, we'll do nothing. In the
third, we'll provide a login link.

&gt; $maybe Entity _ user &lt;- muser
&gt;     $if isAdmin user
&gt;         &lt;form method=post enctype=#{enctype}&gt;
&gt;             ^{entryWidget}
&gt;             &lt;div&gt;
&gt;                 &lt;input type=submit value=_{MsgNewEntry}&gt;
&gt; $nothing
&gt;     &lt;p&gt;
&gt;         &lt;a href=@{AuthR LoginR}&gt;_{MsgLoginToPost}
&gt; |]

Process an incoming entry addition. We don't do any permissions checking, since
isAuthorized handles it for us. If the form submission was valid, we add the
entry to the database and redirect to the new entry. Otherwise, we ask the user
to try again.

&gt; postBlogR :: Handler RepHtml
&gt; postBlogR = do
&gt;     ((res, entryWidget), enctype) &lt;- runFormPost entryForm
&gt;     case res of
&gt;         FormSuccess entry -&gt; do
&gt;             entryId &lt;- runDB $ insert entry
&gt;             setMessageI $ MsgEntryCreated $ entryTitle entry
&gt;             redirect $ EntryR entryId
&gt;         _ -&gt; defaultLayout $ do
&gt;             setTitleI MsgPleaseCorrectEntry
&gt;             [whamlet|
&gt; &lt;form method=post enctype=#{enctype}&gt;
&gt;     ^{entryWidget}
&gt;     &lt;div&gt;
&gt;         &lt;input type=submit value=_{MsgNewEntry}&gt;
&gt; |]

A form for comments, very similar to our entryForm above. It takes the
EntryId of the entry the comment is attached to. By using pure, we embed
this value in the resulting Comment output, without having it appear in the
generated HTML.

&gt; commentForm :: EntryId -&gt; Form Comment
&gt; commentForm entryId = renderDivs $ Comment
&gt;     &lt;$&gt; pure entryId
&gt;     &lt;*&gt; aformM (liftIO getCurrentTime)
&gt;     &lt;*&gt; aformM requireAuthId
&gt;     &lt;*&gt; areq textField (fieldSettingsLabel MsgCommentName) Nothing
&gt;     &lt;*&gt; areq textareaField (fieldSettingsLabel MsgCommentText) Nothing

Show an individual entry, comments, and an add comment form if the user is
logged in.

&gt; getEntryR :: EntryId -&gt; Handler RepHtml
&gt; getEntryR entryId = do
&gt;     (entry, comments) &lt;- runDB $ do
&gt;         entry &lt;- get404 entryId
&gt;         comments &lt;- selectList [] [Asc CommentPosted]
&gt;         return (entry, map entityVal comments)
&gt;     muser &lt;- maybeAuth
&gt;     (commentWidget, enctype) &lt;-
&gt;         generateFormPost (commentForm entryId)
&gt;     defaultLayout $ do
&gt;         setTitleI $ MsgEntryTitle $ entryTitle entry
&gt;         [whamlet|
&gt; &lt;h1&gt;#{entryTitle entry}
&gt; &lt;article&gt;#{entryContent entry}
&gt;     &lt;section .comments&gt;
&gt;         &lt;h1&gt;_{MsgCommentsHeading}
&gt;         $if null comments
&gt;             &lt;p&gt;_{MsgNoComments}
&gt;         $else
&gt;             $forall Comment _entry posted _user name text &lt;- comments
&gt;                 &lt;div .comment&gt;
&gt;                     &lt;span .by&gt;#{name}
&gt;                     &lt;span .at&gt;#{show posted}
&gt;                     &lt;div .content&gt;#{text}
&gt;         &lt;section&gt;
&gt;             &lt;h1&gt;_{MsgAddCommentHeading}
&gt;             $maybe _ &lt;- muser
&gt;                 &lt;form method=post enctype=#{enctype}&gt;
&gt;                     ^{commentWidget}
&gt;                     &lt;div&gt;
&gt;                         &lt;input type=submit value=_{MsgAddCommentButton}&gt;
&gt;             $nothing
&gt;                 &lt;p&gt;
&gt;                     &lt;a href=@{AuthR LoginR}&gt;_{MsgLoginToComment}
&gt; |]

Receive an incoming comment submission.

&gt; postEntryR :: EntryId -&gt; Handler RepHtml
&gt; postEntryR entryId = do
&gt;     ((res, commentWidget), enctype) &lt;-
&gt;         runFormPost (commentForm entryId)
&gt;     case res of
&gt;         FormSuccess comment -&gt; do
&gt;             _ &lt;- runDB $ insert comment
&gt;             setMessageI MsgCommentAdded
&gt;             redirect $ EntryR entryId
&gt;         _ -&gt; defaultLayout $ do
&gt;             setTitleI MsgPleaseCorrectComment
&gt;             [whamlet|
&gt; &lt;form method=post enctype=#{enctype}&gt;
&gt;     ^{commentWidget}
&gt;     &lt;div&gt;
&gt;         &lt;input type=submit value=_{MsgAddCommentButton}&gt;
&gt; |]

Finally our main function.

&gt; main :: IO ()
&gt; main = do
&gt;     pool &lt;- createSqlitePool "blog.db3" 10 -- create a new pool
&gt;     -- perform any necessary migration
&gt;     runSqlPool (runMigration migrateAll) pool
&gt;     manager &lt;- newManager def -- create a new HTTP manager
&gt;     warpDebug 3000 $ Blog pool manager -- start our server</programlisting>
  </chapter>
  <chapter>
   <title>Wiki: markdown, chat subsite, event source</title>
   <para/>
   <para/>
   <para>This example will tie together a few different ideas. We'll start with a chat subsite, which
   allows us to embed a chat widget on any page. We'll use the HTML 5 event source API to handle
   sending events from the server to the client.</para>
   <programlisting language="haskell">-- @Chat.hs
{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
             FlexibleContexts
  #-}
-- | This modules defines a subsite that allows you to insert a chat box on
-- any page of your site. It uses eventsource for sending the messages from
-- the server to the browser.
module Chat where

import Yesod
import Control.Concurrent.Chan (Chan, dupChan, writeChan)
import Data.Text (Text)
import Network.Wai.EventSource (ServerEvent (..), eventSourceAppChan)
import Language.Haskell.TH.Syntax (Type (VarT), Pred (ClassP), mkName)
import Blaze.ByteString.Builder.Char.Utf8 (fromText)
import Data.Monoid (mappend)

-- | Our subsite foundation. We keep a channel of events that all connections
-- will share.
data Chat = Chat (Chan ServerEvent)

-- | We need to know how to check if a user is logged in and how to get
-- his/her username (for printing messages).
class (Yesod master, RenderMessage master FormMessage)
        =&gt; YesodChat master where
    getUserName :: GHandler sub master Text
    isLoggedIn :: GHandler sub master Bool

-- Now we set up our subsite. The first argument is the subsite, very similar
-- to how we've used mkYesod in the past. The second argument is specific to
-- subsites. What it means here is "the master site must be an instance of
-- YesodChat".
--
-- We define two routes: a route for sending messages from the client to the
-- server, and one for opening up the event stream to receive messages from
-- the server.
mkYesodSub "Chat"
    [ ClassP ''YesodChat [VarT $ mkName "master"]
    ] [parseRoutes|
/send SendR POST
/recv ReceiveR GET
|]

-- | Get a message from the user and send it to all listeners.
postSendR :: YesodChat master =&gt; GHandler Chat master ()
postSendR = do
    from &lt;- getUserName

    -- Note that we're using GET parameters for simplicity of the Ajax code.
    -- This could easily be switched to POST. Nonetheless, our overall
    -- approach is still RESTful since this route can only be accessed via a
    -- POST request.
    body &lt;- runInputGet $ ireq textField "message"

    -- Get the channel
    Chat chan &lt;- getYesodSub

    -- Send an event to all listeners with the user's name and message.
    liftIO $ writeChan chan $ ServerEvent Nothing Nothing $ return $
        fromText from `mappend` fromText ": " `mappend` fromText body

-- | Send an eventstream response with all messages streamed in.
getReceiveR :: GHandler Chat master ()
getReceiveR = do
    -- First we get the main channel
    Chat chan0 &lt;- getYesodSub

    -- We duplicated the channel, which allows us to create broadcast
    -- channels.
    chan &lt;- liftIO $ dupChan chan0

    -- Now we use the event source API. eventSourceAppChan takes two parameters:
    -- the channel of events to read from, and the WAI request. It returns a
    -- WAI response, which we can return with sendWaiResponse.
    req &lt;- waiRequest
    res &lt;- lift $ eventSourceAppChan chan req
    sendWaiResponse res

-- | Provide a widget that the master site can embed on any page.
chatWidget :: YesodChat master
           =&gt; (Route Chat -&gt; Route master)
           -&gt; GWidget sub master ()
-- This toMaster argument tells us how to convert a Route Chat into a master
-- route. You might think this is redundant information, but taking this
-- approach means we can have multiple chat subsites in a single site.
chatWidget toMaster = do
    -- Get some unique identifiers to help in creating our HTML/CSS. Remember,
    -- we have no idea what the master site's HTML will look like, so we
    -- should not assume we can make up identifiers that won't be reused.
    -- Also, it's possible that multiple chatWidgets could be embedded in the
    -- same page.
    chat &lt;- lift newIdent   -- the containing div
    output &lt;- lift newIdent -- the box containing the messages
    input &lt;- lift newIdent  -- input field from the user

    ili &lt;- lift isLoggedIn  -- check if we're already logged in
    if ili
        then do
            -- Logged in: show the widget
            [whamlet|
&lt;div ##{chat}&gt;
    &lt;h2&gt;Chat
    &lt;div ##{output}&gt;
    &lt;input ##{input} type=text placeholder="Enter Message"&gt;
|]
            -- Just some CSS
            toWidget [lucius|
##{chat} {
    position: absolute;
    top: 2em;
    right: 2em;
}
##{output} {
    width: 200px;
    height: 300px;
    border: 1px solid #999;
    overflow: auto;
}
|]
            -- And now that Javascript
            toWidgetBody [julius|
// Set up the receiving end
var output = document.getElementById("#{output}");
var src = new EventSource("@{toMaster ReceiveR}");
src.onmessage = function(msg) {
    // This function will be called for each new message.
    var p = document.createElement("p");
    p.appendChild(document.createTextNode(msg.data));
    output.appendChild(p);

    // And now scroll down within the output div so the most recent message
    // is displayed.
    output.scrollTop = output.scrollHeight;
};

// Set up the sending end: send a message via Ajax whenever the user hits
// enter.
var input = document.getElementById("#{input}");
input.onkeyup = function(event) {
    var keycode = (event.keyCode ? event.keyCode : event.which);
    if (keycode == '13') {
        var xhr = new XMLHttpRequest();
        var val = input.value;
        input.value = "";
        var params = "?message=" + encodeURI(val);
        xhr.open("POST", "@{toMaster SendR}" + params);
        xhr.send(null);
    }
}
|]
        else do
            -- User isn't logged in, give a not-logged-in message.
            master &lt;- lift getYesod
            [whamlet|
&lt;p&gt;
    You must be #
    $maybe ar &lt;- authRoute master
        &lt;a href=@{ar}&gt;logged in
    $nothing
        logged in
    \ to chat.
|]</programlisting>
   <para>This module stands on its own, and can be used in any application. Next we'll provide such a
   driver application: a wiki. Our wiki will have a hard-coded homepage, and then a wiki section of
   the site. We'll be using <glossterm>multiple dynamic pieces</glossterm> to allow an arbitrary hierarchy of
   pages within the Wiki.</para>
   <para>For storage, we'll just use a mutable reference to a <literal>Map</literal>. For a production
   application, this should be replaced with a proper database. The content will be stored and
   served as Markdown. <literal>yesod-auth</literal>'s dummy plugin will provide us with (fake)
   authentication.</para>
   <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, QuasiQuotes,
             TemplateHaskell, FlexibleInstances, MultiParamTypeClasses,
             FlexibleContexts
  #-}
import Yesod
import Yesod.Auth
import Yesod.Auth.Dummy (authDummy)
import Chat
import Control.Concurrent.Chan (Chan, newChan)
import Network.Wai.Handler.Warp (run)
import Data.Text (Text)
import qualified Data.Text.Lazy as TL
import qualified Data.IORef as I
import qualified Data.Map as Map
import Text.Markdown (markdown, def)

-- | Our foundation type has both the chat subsite and a mutable reference to
-- a map of all our wiki contents. Note that the key is a list of Texts, since
-- a wiki can have an arbitrary hierarchy.
--
-- In a real application, we would want to store this information in a
-- database of some sort.
data Wiki = Wiki
    { getChat :: Chat
    , wikiContent :: I.IORef (Map.Map [Text] Text)
    }

-- Set up our routes as usual.
mkYesod "Wiki" [parseRoutes|
/ RootR GET                 -- the homepage
/wiki/*Texts WikiR GET POST -- note the multipiece for the wiki hierarchy
/chat ChatR Chat getChat    -- the chat subsite
/auth AuthR Auth getAuth    -- the auth subsite
|]

instance Yesod Wiki where
    authRoute _ = Just $ AuthR LoginR -- get a working login link

    -- Our custom defaultLayout will add the chat widget to every page.
    -- We'll also add login and logout links to the top.
    defaultLayout widget = do
        pc &lt;- widgetToPageContent $ widget &gt;&gt; chatWidget ChatR
        mmsg &lt;- getMessage
        hamletToRepHtml [hamlet|
$doctype 5
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;#{pageTitle pc}
        ^{pageHead pc}
    &lt;body&gt;
        $maybe msg &lt;- mmsg
            &lt;div .message&gt;#{msg}
        &lt;nav&gt;
            &lt;a href=@{AuthR LoginR}&gt;Login
            \ | #
            &lt;a href=@{AuthR LogoutR}&gt;Logout
        ^{pageBody pc}
|]

-- Fairly standard YesodAuth instance. We'll use the dummy plugin so that you
-- can create any name you want, and store the login name as the AuthId.
instance YesodAuth Wiki where
    type AuthId Wiki = Text
    authPlugins _ = [authDummy]
    loginDest _ = RootR
    logoutDest _ = RootR
    getAuthId = return . Just . credsIdent
    authHttpManager = error "authHttpManager" -- not used by authDummy

-- Just implement authentication based on our yesod-auth usage.
instance YesodChat Wiki where
    getUserName = requireAuthId
    isLoggedIn = do
        ma &lt;- maybeAuthId
        return $ maybe False (const True) ma

instance RenderMessage Wiki FormMessage where
    renderMessage _ _ = defaultFormMessage

-- Nothing special here, just giving a link to the root of the wiki.
getRootR :: Handler RepHtml
getRootR = defaultLayout [whamlet|
&lt;p&gt;Welcome to the Wiki!
&lt;p&gt;
    &lt;a href=@{wikiRoot}&gt;Wiki root
|]
  where
    wikiRoot = WikiR []

-- A form for getting wiki content
wikiForm mtext = renderDivs $ areq textareaField "Page body" mtext

-- Show a wiki page and an edit form
getWikiR :: [Text] -&gt; Handler RepHtml
getWikiR page = do
    -- Get the reference to the contents map
    icontent &lt;- fmap wikiContent getYesod

    -- And read the map from inside the reference
    content &lt;- liftIO $ I.readIORef icontent

    -- Lookup the contents of the current page, if available
    let mtext = Map.lookup page content

    -- Generate a form with the current contents as the default value.
    -- Note that we use the Textarea wrapper to get a &lt;textarea&gt;.
    (form, _) &lt;- generateFormPost $ wikiForm $ fmap Textarea mtext
    defaultLayout $ do
        case mtext of
            -- We're treating the input as markdown. The markdown package
            -- automatically handles XSS protection for us.
            Just text -&gt; toWidget $ markdown def $ TL.fromStrict text
            Nothing -&gt; [whamlet|&lt;p&gt;Page does not yet exist|]
        [whamlet|
&lt;h2&gt;Edit page
&lt;form method=post&gt;
    ^{form}
    &lt;div&gt;
        &lt;input type=submit&gt;
|]

-- Get a submitted wiki page and updated the contents.
postWikiR :: [Text] -&gt; Handler RepHtml
postWikiR page = do
    icontent &lt;- fmap wikiContent getYesod
    content &lt;- liftIO $ I.readIORef icontent
    let mtext = Map.lookup page content
    ((res, form), _) &lt;- runFormPost $ wikiForm $ fmap Textarea mtext
    case res of
        FormSuccess (Textarea t) -&gt; do
            liftIO $ I.atomicModifyIORef icontent $
                \m -&gt; (Map.insert page t m, ())
            setMessage "Page updated"
            redirect $ WikiR page
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post&gt;
    ^{form}
    &lt;div&gt;
        &lt;input type=submit&gt;
|]

main :: IO ()
main = do
    -- Create our server event channel
    chan &lt;- newChan

    -- Initially have a blank database of wiki pages
    icontent &lt;- I.newIORef Map.empty

    -- Run our app
    warpDebug 3000 $ Wiki (Chat chan) icontent</programlisting>
  </chapter>
  <chapter>
   <title>JSON Web Service</title>
   <para/>
   <para/>
   <para>Let's create a very simple web service: it takes a JSON request and returns a JSON
            response. We're going to write the server in WAI/Warp, and the client in <function>http-conduit</function>. We'll be using <function>aeson</function> for
            JSON parsing and rendering. We could also write the server in Yesod itself, but for such
            a simple example, the extra features of Yesod don't add much.</para>
   <section>
    <title>Server</title>
    <para/>
    <para>WAI uses the <function>conduit</function> package to handle streaming request
            bodies, and efficiently generates responses using <function>blaze-builder</function>. <function>aeson</function> uses <function>attoparsec</function> for parsing; by using <function>attoparsec-conduit</function> we get easy interoperability with WAI. This plays out
            as:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Network.Wai (Response, responseLBS, Application, requestBody)
import Network.HTTP.Types (status200, status400)
import Network.Wai.Handler.Warp (run)
import Data.Aeson.Parser (json)
import Data.Conduit.Attoparsec (sinkParser)
import Control.Monad.IO.Class (liftIO)
import Data.Aeson (Value, encode, object, (.=))
import Control.Exception (SomeException)
import Data.ByteString (ByteString)
import Data.Conduit (ResourceT, ($$))
import Control.Exception.Lifted (handle)

main :: IO ()
main = run 3000 app

app :: Application
app req = handle invalidJson $ do
    value &lt;- requestBody req $$ sinkParser json
    newValue &lt;- liftIO $ modValue value
    return $ responseLBS
        status200
        [("Content-Type", "application/json")]
        $ encode newValue

invalidJson :: SomeException -&gt; ResourceT IO Response
invalidJson ex = return $ responseLBS
    status400
    [("Content-Type", "application/json")]
    $ encode $ object
        [ ("message" .= show ex)
        ]

-- Application-specific logic would go here.
modValue :: Value -&gt; IO Value
modValue = return</programlisting>
   </section>
   <section>
    <title>Client</title>
    <para/>
    <para>
     <function>http-conduit</function> was written as a companion to WAI. It too uses
    <literal>conduit</literal> and <literal>blaze-builder</literal> pervasively, meaning we once again
   get easy interop with <literal>aeson</literal>. A few extra comments for those not familiar with
    <literal>http-conduit</literal>:</para>
    <itemizedlist>
     <listitem>
      <para>A <literal>Manager</literal> is present to keep track of open connections, so
    that multiple requests to the same server use the same connection. You usually want to use the
     <literal>withManager</literal> function to create and clean up this
     <literal>Manager</literal>, since it is exception safe.</para>
     </listitem>
     <listitem>
      <para>We need to know the size of our request body, which can't be determined directly from
    a <literal>Builder</literal>. Instead, we convert the <literal>Builder</literal> into a lazy
     <literal>ByteString</literal> and take the size from there.</para>
     </listitem>
     <listitem>
      <para>There are a number of different functions for initiating a request. We use
     <literal>http</literal>, which allows us to directly access the data stream. There are other
    higher level functions (such as <literal>httpLbs</literal>) that let you ignore the issues of
    sources and get the entire body directly.</para>
     </listitem>
    </itemizedlist>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit
    ( http, parseUrl, withManager, RequestBody (RequestBodyLBS)
    , requestBody, method, Response (..)
    )
import Data.Aeson (Value (Object, String))
import Data.Aeson.Parser (json)
import Data.Conduit (($$))
import Data.Conduit.Attoparsec (sinkParser)
import Control.Monad.IO.Class (liftIO)
import Data.Aeson (encode, (.=), object)

main :: IO ()
main = withManager $ \manager -&gt; do
    value &lt;- liftIO makeValue
    -- We need to know the size of the request body, so we convert to a
    -- ByteString
    let valueBS = encode value
    req' &lt;- liftIO $ parseUrl "http://localhost:3000/"
    let req = req' { method = "POST", requestBody = RequestBodyLBS valueBS }
    Response status version headers body &lt;- http req manager
    resValue &lt;- body $$ sinkParser json
    liftIO $ handleResponse resValue

-- Application-specific function to make the request value
makeValue :: IO Value
makeValue = return $ object
    [ ("foo" .= ("bar" :: String))
    ]

-- Application-specific function to handle the response from the server
handleResponse :: Value -&gt; IO ()
handleResponse = print</programlisting>
   </section>
  </chapter>
  <chapter>
   <title>Case Study: Sphinx-based Search</title>
   <para/>
   <para/>
   <para>
    <link xlink:href="http://sphinxsearch.com/">Sphinx</link> is a search
   server, and powers the search feature on many sites, including Yesod's own site. While the actual
   code necessary to integrate Yesod with Sphinx is relatively short, it touches on a number of
   complicated topics, and is therefore a great case study in how to play with some of the
   under-the-surface details of Yesod.</para>
   <para>There are essentially three different pieces at play here:</para>
   <itemizedlist>
    <listitem>
     <para>Storing the content we wish to search. This is fairly straight-forward Persistent code, and
    we won't dwell on it much in this chapter.</para>
    </listitem>
    <listitem>
     <para>Accessing Sphinx search results from inside Yesod. Thanks to the <function>sphinx</function>
    package, this is actually very easy.</para>
    </listitem>
    <listitem>
     <para>Providing the document content to Sphinx. This is where the interesting stuff happens, and
    will show how to deal with streaming content from a database directly to XML, which gets sent
    directly over the wire to the client.</para>
    </listitem>
   </itemizedlist>
   <section>
    <title>Sphinx Setup</title>
    <para/>
    <para>Unlike many of our other examples, to start with here we'll need to actually configure
   and run our external Sphinx server. I'm not going to go into all the details of Sphinx, partly
   because it's not relevant to our point here, and mostly because I'm not an expert on Sphinx.</para>
    <para>Sphinx provides three main command line utilities: <literal>searchd</literal>
   is the actual search daemon that receives requests from the client (in this case, our web app)
   and returns the search results. <literal>indexer</literal> parses the set of documents and
   creates the search index. <literal>search</literal> is a debugging utility that will run
   simple queries against Sphinx.</para>
    <para>There are two important settings: the source and the index. The source tells Sphinx
   where to read document information from. It has direct support for MySQL and PostgreSQL, as well
   as a more general XML format known as xmlpipe2. We're going to use the last one. This not only
   will give us more flexibility with choosing Persistent backends, but will also demonstrate some
   more powerful Yesod concepts.</para>
    <para>The second setting is the index. Sphinx can handle multiple indices simultaneously,
   which allows it to provide search for multiple services at once. Each index will have a source it
   pulls from.</para>
    <para>In our case, we're going to provide a URL from our application (/search/xmlpipe) that provides
   the XML file required by Sphinx, and then pipe that through to the indexer. So we'll add the
   following to our Sphinx config file:</para>
    <programlisting>source searcher_src
{
	type = xmlpipe2
	xmlpipe_command = curl http://localhost:3000/search/xmlpipe
}

index searcher
{
	source = searcher_src
	path = /var/data/searcher
	docinfo = extern
	charset_type = utf-8
}</programlisting>
    <para>In order to build your search index, you would run <literal>indexer searcher</literal>. Obviously
   this won't work until you have your web app running. For a production site, it would make sense
   to run this command via a crontab script so the index is regularly updated.</para>
   </section>
   <section>
    <title>Basic Yesod Setup</title>
    <para/>
    <para>Let's get our basic Yesod setup going. We're going to have a single table in the database for
   holding documents, which consist of a title and content. We'll store this in a SQLite database,
   and provide routes for searching, adding documents, viewing documents and providing the xmlpipe
   file to Sphinx.</para>
    <programlisting language="haskell">share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage
</programlisting>
    <para>Hopefully all of this looks pretty familiar by now. Next we'll define some forms: one for
   creating documents, and one for searching:</para>
    <programlisting language="haskell">addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing
</programlisting>
    <para>The <literal>True</literal> parameter to searchField makes the field auto-focus on page load.
   Finally, we have some standard handlers for the homepage (shows the add document form and the
   search form), the document display, and adding a document.</para>
    <programlisting language="haskell">getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]
</programlisting>
   </section>
   <section>
    <title>Searching</title>
    <para/>
    <para>Now that we've got the boring stuff out of the way, let's jump into the actual
            searching. We're going to need three pieces of information for displaying a result: the
            document ID it comes from, the title of that document, and the <glossterm>excerpts</glossterm>. Excerpts are the highlighted portions of the document which
            contain the search term.</para>
    <figure xml:id="searching-x-5">
     <title>Search Result</title>
     <mediaobject>
      <imageobject>
       <imagedata fileref="images/case-study-sphinx/search-results.png"/>
      </imageobject>
     </mediaobject>
    </figure>
    <para>So let's start off by defining a Result datatype:</para>
    <programlisting language="haskell">data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }</programlisting>
    <para>Next we'll look at the search handler:</para>
    <programlisting language="haskell">getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]
</programlisting>
    <para>Nothing magical here, we're just relying on the <literal>searchForm</literal> defined above, and the <literal>getResults</literal>
            function which hasn't been defined yet. This function just takes a search string, and
            returns a list of results. This is where we first interact with the Sphinx API. We'll be
            using two functions: <literal>query</literal> will return a list of matches, and
                <literal>buildExcerpts</literal> will return the highlighted excerpts. Let's
            first look at <literal>query</literal>:</para>
    <programlisting language="haskell">getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" (unpack qstring)
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }
</programlisting>
    <para>
     <literal>query</literal> takes three parameters: the configuration
            options, the index to search against (searcher in this case) and the search string. It
            returns a list of document IDs that contain the search string. The tricky bit here is
            that those documents are returned as <literal>Int64</literal> values, whereas we
            need <literal>DocId</literal>s. We're taking advantage of the fact that the SQL
            Persistent backends use a <literal>PersistInt64</literal> constructor for their
            IDs, and simply wrap up the values appropriately.</para>
    <note>
     <para>If you're dealing with a backend that has non-numeric IDs, like MongoDB,
            you'll need to work out something a bit more clever than this.</para>
    </note>
    <para>We then loop over the resulting IDs to get a <literal>[Maybe
                Result]</literal> value, and use <literal>catMaybes</literal> to turn it into
            a <literal>[Result]</literal>. In the where clause, we define our local
            settings, which override the default port and set up the search to work when <emphasis>any</emphasis> term matches the document.</para>
    <para>Let's finally look at the <literal>getResult</literal> function:</para>
    <programlisting language="haskell">getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [T.unpack $ escape $ docContent doc]
        "searcher"
        (unpack qstring)
    let excerpt =
            case excerpt' of
                ST.Ok bss -&gt; preEscapedLazyText $ decodeUtf8With ignore $ L.concat bss
                _ -&gt; ""
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c</programlisting>
    <para>
     <literal>buildExcerpts</literal> takes four parameters: the
            configuration options, the textual contents of the document, the search index and the
            search term. The interesting bit is that we entity escape the text content. Sphinx won't
            automatically escape these for us, so we must do it explicitly.</para>
    <para>Similarly, the result from Sphinx is a list of lazy ByteStrings. But of course,
            we'd rather have Html. So we concat that list into a single lazy ByteString, decode it
            to a lazy text (ignoring invalid UTF-8 character sequences), and use preEscapedLazyText
            to make sure that the tags inserted for matches are not escaped. A sample of this HTML
            is:</para>
    <programlisting>&amp;#8230; Departments.  The President shall have &lt;span class='match'&gt;Power&lt;/span&gt; to fill up all Vacancies
&amp;#8230;  people. Amendment 11 The Judicial &lt;span class='match'&gt;power&lt;/span&gt; of the United States shall
&amp;#8230; jurisdiction. 2. Congress shall have &lt;span class='match'&gt;power&lt;/span&gt; to enforce this article by
&amp;#8230; 5. The Congress shall have &lt;span class='match'&gt;power&lt;/span&gt; to enforce, by appropriate legislation
&amp;#8230;</programlisting>
   </section>
   <section>
    <title>Streaming xmlpipe output</title>
    <para/>
    <para>We've saved the best for last. For the majority of Yesod handlers, the recommended approach is
   to load up the database results into memory and then produce the output document based on that.
   It's simpler to work with, but more importantly it's more resilient to exceptions. If there's a
   problem loading the data from the database, the user will get a proper 500 response code.</para>
    <note>
     <para>What do I mean by "proper 500 response code?" If you start streaming a response to a client,
   and encounter an exception halfway through, there's no way to change the status code; the user
   will see a 200 response that simply stops in the middle. Not only can this partial content be
   confusing, but it's an invalid usage of the HTTP spec.</para>
    </note>
    <para>However, generating the xmlpipe output is a perfect example of the alternative. There are
   potentially a huge number of documents (the yesodweb.com code handles tens of thousands of
   these), and documents could easily be several hundred kilobytes. If we take a non-streaming
   approach, this can lead to huge memory usage and slow response times.</para>
    <para>So how exactly do we create a streaming response? As we cover in the WAI chapter, we have a <literal>ResponseSource</literal> constructor that
   uses a stream of blaze-builder <literal>Builder</literal>s. From the Yesod side, we can
   avoid the normal Yesod response procedure and send a WAI response directly using the <literal>sendWaiResponse</literal> function. So there are at least two of the pieces of this
   puzzle.</para>
    <para>Now we know we want to create a stream of <literal>Builder</literal>s from some XML
   content. Fortunately, the <function>xml-conduit</function> package provides this
   interface directly. <literal>xml-conduit</literal> provides some high-level interfaces for dealing
   with documents as a whole, but in our case, we're going to need to use the low-level Event
   interface to ensure minimal memory impact. So the function we're interested in is:</para>
    <programlisting language="haskell">renderBuilder :: Resource m =&gt; RenderSettings -&gt; Conduit Event m Builder b</programlisting>
    <para>In plain English, that means renderBuilder takes some settings (we'll just use the
   defaults), and will then convert a stream of <literal>Event</literal>s to a stream of
    <literal>Builder</literal>s. This is looking pretty good, all we need now is a stream of
    <literal>Event</literal>s.</para>
    <para>Speaking of which, what should our XML document actually look like? It's pretty
   simple, we have a <literal>sphinx:docset</literal> root element, a <literal>sphinx:schema</literal> element containing a single <literal>sphinx:field</literal>
   (which defines the content field), and then a <literal>sphinx:document</literal> for each
   document in our database. That last element will have an <literal>id</literal> attribute and a
   child <literal>content</literal> element.</para>
    <figure xml:id="conceptId-x-20">
     <title>Sample xmlpipe document</title>
     <programlisting>&lt;sphinx:docset xmlns:sphinx="http://sphinxsearch.com/"&gt;
    &lt;sphinx:schema&gt;
        &lt;sphinx:field name="content"/&gt;
    &lt;/sphinx:schema&gt;
    &lt;sphinx:document id="1"&gt;
        &lt;content&gt;bar&lt;/content&gt;
    &lt;/sphinx:document&gt;
    &lt;sphinx:document id="2"&gt;
        &lt;content&gt;foo bar baz&lt;/content&gt;
    &lt;/sphinx:document&gt;
&lt;/sphinx:docset&gt;</programlisting>
    </figure>
    <para>Every document is going to start off with the same events (start the docset, start
   the schema, etc) and end with the same event (end the docset). We'll start off by defining
   those:</para>
    <programlisting language="haskell">toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]</programlisting>
    <para>Now that we have the shell of our document, we need to get the <literal>Event</literal>s for each individual document. This is actually a fairly simple function:</para>
    <programlisting language="haskell">entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]</programlisting>
    <para>We start the document element with an <literal>id</literal> attribute, start the
   content, insert the content, and then close both elements. We use <literal>toPathPiece</literal> to
   convert a <literal>DocId</literal> into a <literal>Text</literal> value. Next, we need to be able to
   convert a stream of these entities into a stream of events. For this, we can use the built-in
    <literal>concatMap</literal> function from <literal>Data.Conduit.List</literal>: <literal>CL.concatMap entityToEvents</literal>.</para>
    <para>But what we <emphasis>really</emphasis> want is to stream those events directly from the
   database. For most of this book, we've used the <literal>selectList</literal> function, but
   Persistent also provides the (more powerful) <literal>selectSourceConn</literal> function. So we
   end up with the function:</para>
    <programlisting language="haskell">docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents</programlisting>
    <para>The $= operator joins together a source and a conduit into a new source. Now that we
   have our <literal>Event</literal> source, all we need to do is surround it with the document start
   and end events. With <literal>Source</literal>'s <literal>Monoid</literal> instance, this is a piece
   of cake:</para>
    <programlisting language="haskell">fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]</programlisting>
    <para>We're almost there, now we just need to tie it together in
    <literal>getXmlpipeR</literal>. We need to get a database connection to be used. Normally,
   database connections are taken and returned automatically via the <literal>runDB</literal>
   function. In our case, we want to check out a connection and keep it available until the response
   body is completely sent. To do this, we use the <literal>takeResource</literal> function, which
   registers a cleanup action with the <literal>ResourceT</literal> monad.</para>
    <note>
     <para>All WAI applications live in a <literal>ResourceT</literal> transformer. You can get more
   information on <literal>ResourceT</literal> in the conduit appendix.</para>
    </note>
    <para>By default, a resource will not be returned to the pool. This has to do with proper
   exception handling, but is not relevant for our use case. Therefore, we need to force the
   connection to be returned to the pool.</para>
    <programlisting language="haskell">getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True let source = fullDocSource conn C.$= renderBuilder def
    sendWaiResponse $ ResponseSource status200 headers source</programlisting>
    <para>We get our connection pool from the foundation variable, then send a WAI response. We
   use the <literal>ResponseSource</literal> constructor, and provide it the status code, response
   headers, and body.</para>
   </section>
   <section>
    <title>Full code</title>
    <para/>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, TypeFamilies, TemplateHaskell,
    QuasiQuotes, MultiParamTypeClasses, GADTs, FlexibleContexts
  #-}
import Yesod
import Data.Text (Text, unpack)
import Control.Applicative ((&lt;$&gt;), (&lt;*&gt;))
import Database.Persist.Sqlite
import Database.Persist.Query.GenericSql (selectSourceConn)
import Database.Persist.Store (PersistValue (PersistInt64))
import qualified Text.Search.Sphinx as S
import qualified Text.Search.Sphinx.Types as ST
import qualified Text.Search.Sphinx.ExcerptConfiguration as E
import qualified Data.ByteString.Lazy as L
import Data.Text.Lazy.Encoding (decodeUtf8With)
import Data.Text.Encoding.Error (ignore)
import Data.Maybe (catMaybes)
import Control.Monad (forM)
import qualified Data.Text as T
import Text.Blaze (preEscapedLazyText)
import qualified Data.Conduit as C
import qualified Data.Conduit.List as CL
import qualified Data.XML.Types as X
import Network.Wai (Response (ResponseSource))
import Network.HTTP.Types (status200)
import Text.XML.Stream.Render (renderBuilder, def)
import Data.Monoid (mconcat)
import Data.Conduit.Pool (takeResource, mrValue, mrReuse)

share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persist|
Doc
    title Text
    content Textarea
|]

data Searcher = Searcher ConnectionPool

mkYesod "Searcher" [parseRoutes|
/ RootR GET
/doc/#DocId DocR GET
/add-doc AddDocR POST
/search SearchR GET
/search/xmlpipe XmlpipeR GET
|]

instance Yesod Searcher

instance YesodPersist Searcher where
    type YesodPersistBackend Searcher = SqlPersist

    runDB action = do
        Searcher pool &lt;- getYesod
        runSqlPool action pool

instance RenderMessage Searcher FormMessage where
    renderMessage _ _ = defaultFormMessage

addDocForm :: Html -&gt; MForm Searcher Searcher (FormResult Doc, Widget)
addDocForm = renderTable $ Doc
    &lt;$&gt; areq textField "Title" Nothing
    &lt;*&gt; areq textareaField "Contents" Nothing

searchForm :: Html -&gt; MForm Searcher Searcher (FormResult Text, Widget)
searchForm = renderDivs $ areq (searchField True) "Query" Nothing

getRootR :: Handler RepHtml
getRootR = do
    docCount &lt;- runDB $ count ([] :: [Filter Doc])
    ((_, docWidget), _) &lt;- runFormPost addDocForm
    ((_, searchWidget), _) &lt;- runFormGet searchForm
    let docs = if docCount == 1
                then "There is currently 1 document."
                else "There are currently " ++ show docCount ++ " documents."
    defaultLayout [whamlet|
&lt;p&gt;Welcome to the search application. #{docs}
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
|]

postAddDocR :: Handler RepHtml
postAddDocR = do
    ((res, docWidget), _) &lt;- runFormPost addDocForm
    case res of
        FormSuccess doc -&gt; do
            docid &lt;- runDB $ insert doc
            setMessage "Document added"
            redirect $ DocR docid
        _ -&gt; defaultLayout [whamlet|
&lt;form method=post action=@{AddDocR}&gt;
    &lt;table&gt;
        ^{docWidget}
        &lt;tr&gt;
            &lt;td colspan=3&gt;
                &lt;input type=submit value="Add document"&gt;
|]

getDocR :: DocId -&gt; Handler RepHtml
getDocR docid = do
    doc &lt;- runDB $ get404 docid
    defaultLayout $
        [whamlet|
&lt;h1&gt;#{docTitle doc}
&lt;div .content&gt;#{docContent doc}
|]

data Result = Result
    { resultId :: DocId
    , resultTitle :: Text
    , resultExcerpt :: Html
    }

getResult :: DocId -&gt; Doc -&gt; Text -&gt; IO Result
getResult docid doc qstring = do
    excerpt' &lt;- S.buildExcerpts
        excerptConfig
        [T.unpack $ escape $ docContent doc]
        "searcher"
        (unpack qstring)
    let excerpt =
            case excerpt' of
                ST.Ok bss -&gt; preEscapedLazyText $ decodeUtf8With ignore $ L.concat bss
                _ -&gt; ""
    return Result
        { resultId = docid
        , resultTitle = docTitle doc
        , resultExcerpt = excerpt
        }
  where
    excerptConfig = E.altConfig { E.port = 9312 }

escape :: Textarea -&gt; Text
escape =
    T.concatMap escapeChar . unTextarea
  where
    escapeChar '&lt;' = "&amp;lt;"
    escapeChar '&gt;' = "&amp;gt;"
    escapeChar '&amp;' = "&amp;amp;"
    escapeChar c   = T.singleton c

getResults :: Text -&gt; Handler [Result]
getResults qstring = do
    sphinxRes' &lt;- liftIO $ S.query config "searcher" (unpack qstring)
    case sphinxRes' of
        ST.Ok sphinxRes -&gt; do
            let docids = map (Key . PersistInt64 . ST.documentId) $ ST.matches sphinxRes
            fmap catMaybes $ runDB $ forM docids $ \docid -&gt; do
                mdoc &lt;- get docid
                case mdoc of
                    Nothing -&gt; return Nothing
                    Just doc -&gt; liftIO $ Just &lt;$&gt; getResult docid doc qstring
        _ -&gt; error $ show sphinxRes'
  where
    config = S.defaultConfig
        { S.port = 9312
        , S.mode = ST.Any
        }

getSearchR :: Handler RepHtml
getSearchR = do
    ((formRes, searchWidget), _) &lt;- runFormGet searchForm
    searchResults &lt;-
        case formRes of
            FormSuccess qstring -&gt; getResults qstring
            _ -&gt; return []
    defaultLayout $ do
        toWidget [lucius|
.excerpt {
    color: green; font-style: italic
}
.match {
    background-color: yellow;
}
|]
        [whamlet|
&lt;form method=get action=@{SearchR}&gt;
    ^{searchWidget}
    &lt;input type=submit value=Search&gt;
$if not $ null searchResults
    &lt;h1&gt;Results
    $forall result &lt;- searchResults
        &lt;div .result&gt;
            &lt;a href=@{DocR $ resultId result}&gt;#{resultTitle result}
            &lt;div .excerpt&gt;#{resultExcerpt result}
|]

getXmlpipeR :: Handler RepXml
getXmlpipeR = do
    Searcher pool &lt;- getYesod
    let headers = [("Content-Type", "text/xml")]
    managedConn &lt;- lift $ takeResource pool
    let conn = mrValue managedConn
    lift $ mrReuse managedConn True
    let source = fullDocSource conn C.$= renderBuilder def
        flushSource = C.mapOutput C.Chunk source
    sendWaiResponse $ ResponseSource status200 headers flushSource

entityToEvents :: (Entity Doc) -&gt; [X.Event]
entityToEvents (Entity docid doc) =
    [ X.EventBeginElement document [("id", [X.ContentText $ toPathPiece docid])]
    , X.EventBeginElement content []
    , X.EventContent $ X.ContentText $ unTextarea $ docContent doc
    , X.EventEndElement content
    , X.EventEndElement document
    ]

fullDocSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
fullDocSource conn = mconcat
    [ CL.sourceList startEvents
    , docSource conn
    , CL.sourceList endEvents
    ]

docSource :: Connection -&gt; C.Source (C.ResourceT IO) X.Event
docSource conn = selectSourceConn conn [] [] C.$= CL.concatMap entityToEvents

toName :: Text -&gt; X.Name
toName x = X.Name x (Just "http://sphinxsearch.com/") (Just "sphinx")

docset, schema, field, document, content :: X.Name
docset = toName "docset"
schema = toName "schema"
field = toName "field"
document = toName "document"
content = "content" -- no prefix

startEvents, endEvents :: [X.Event]
startEvents =
    [ X.EventBeginDocument
    , X.EventBeginElement docset []
    , X.EventBeginElement schema []
    , X.EventBeginElement field [("name", [X.ContentText "content"])]
    , X.EventEndElement field
    , X.EventEndElement schema
    ]

endEvents =
    [ X.EventEndElement docset
    ]

main :: IO ()
main = withSqlitePool "searcher.db3" 10 $ \pool -&gt; do
    runSqlPool (runMigration migrateAll) pool
    warpDebug 3000 $ Searcher pool</programlisting>
   </section>
  </chapter>
 </part>
 <part>
  <title>Appendices</title>
  <chapter>
   <title>monad-control</title>
   <para/>
   <para/>
   <para>
    <function>monad-control</function> is used in a few places within Yesod, most notably to ensure proper exception handling within Persistent. It is a general purpose package to extend standard functionality in monad transformers.</para>
   <section>
    <title>Overview</title>
    <para/>
    <para>One of the powerful, and sometimes confusing, features in Haskell is monad transformers. They
   allow you to take different pieces of functionality- such as mutable state, error handling, or
   logging- and compose them together easily. Though I swore I'd never write a monad tutorial, I'm
   going to employ a painful analogy here: monads are like onions. (Monads are not like cakes.) By
   that, I mean <emphasis>layers</emphasis>.</para>
    <para>We have the core monad- also known as the innermost or bottom monad. On top of this
   core, we add layers, each adding a new feature and spreading outward/upward. As a motivating
   example, let's consider an Error monad stacked on top of the IO
   monad:<programlisting language="haskell">newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
type MyStack = ErrorT MyError IO</programlisting>Now
   pay close attention here: ErrorT is just a simple newtype around an Either wrapped in a monad.
   Getting rid of the newtype, we
   have:<programlisting language="haskell">type ErrorTUnwrapped e m a = m (Either e a)</programlisting>
    </para>
    <para>At some point, we'll need to actually perform some IO inside our MyStack. If we went with the
   unwrapped approach, it would be trivial, since there would be no ErrorT constructor in the way.
   However, we need that newtype wrapper for a whole bunch of type reasons I won't go into here
   (this isn't a monad transformer tutorial after all). So the solution is the MonadTrans
   typeclass:</para>
    <programlisting language="haskell">class MonadTrans t where
    lift :: Monad m =&gt; m a -&gt; t m a</programlisting>
    <para>I'll admit, the first time I saw that type signature, my response was stunned confusion, and
   incredulity that it actually meant anything. But looking at an instance helps a
   bit:<programlisting language="haskell">instance (Error e) =&gt; MonadTrans (ErrorT e) where
    lift m = ErrorT $ do
        a &lt;- m
        return (Right a)</programlisting>All
   we're doing is wrapping the inside of the IO with a Right value, and then applying our newtype
   wrapper. This allows us to take an action that lives in IO, and "lift" it to the outer/upper
   monad.</para>
    <para>But now to the point at hand. This works very well for simple functions. For example:</para>
    <programlisting language="haskell">sayHi :: IO ()
sayHi = putStrLn "Hello"

sayHiError :: ErrorT MyError IO ()
sayHiError = lift $ putStrLn "Hello"</programlisting>
    <para>But let's take something slightly more complicated, like a callback:</para>
    <programlisting language="haskell">withMyFile :: (Handle -&gt; IO a) -&gt; IO a
withMyFile = withFile "test.txt" WriteMode

sayHi :: Handle -&gt; IO ()
sayHi handle = hPutStrLn handle "Hi there"

useMyFile :: IO ()
useMyFile = withMyFile sayHi</programlisting>
    <para>So far so good, right? Now let's say that we need a version of sayHi that has access to the
   Error monad:</para>
    <programlisting language="haskell">sayHiError :: Handle -&gt; ErrorT MyError IO ()
sayHiError handle = do
    lift $ hPutStrLn handle "Hi there, error!"
    throwError MyError</programlisting>
    <para>We would like to write a function that combines withMyFile and sayHiError.
   Unfortunately, GHC doesn't like this very
   much:<programlisting language="haskell">useMyFileErrorBad :: ErrorT MyError IO ()
useMyFileErrorBad = withMyFile sayHiError

    Couldn't match expected type `ErrorT MyError IO ()'
                with actual type `IO ()'</programlisting>Why
   does this happen, and how can we work around it?</para>
   </section>
   <section>
    <title>Intuition</title>
    <para/>
    <para>Let's try and develop an external intuition of what's happening here. The ErrorT monad
   transformer adds extra functionality to the IO monad. We've defined a way to "tack on" that extra
   functionality to normal IO actions: we add that Right constructor and wrap it all in ErrorT.
   Wrapping in Right is our way of saying "it went OK," there wasn't anything wrong with this
   action.</para>
    <para>Now this intuitively makes sense: since the IO monad doesn't have the concept of returning a
   MyError when something goes wrong, it will always succeed in the lifting phase. (Note: This has
    <emphasis role="bold">nothing</emphasis> to do with runtime exceptions, don't even think about them.) What we have is a
   guaranteed one-directional translation up the monad stack.</para>
    <para>Let's take another example: the Reader monad. A Reader has access to some extra piece of data
   floating around. Whatever is running in the inner monad doesn't know about that extra piece of
   information. So how would you do a lift? You just ignore that extra information. The Writer
   monad? Don't write anything. State? Don't change anything. I'm seeing a pattern here.</para>
    <para>But now let's try and go in the opposite direction: I have something in a Reader, and I'd like
   to run it in the base monad (e.g., IO). Well... that's not going to work, is it? I need that
   extra piece of information, I'm relying on it, and it's not there. There's simply no way to go in
   the opposite direction without providing that extra value.</para>
    <para>Or is there? If you remember, we'd pointed out earlier that ErrorT is just a simple wrapper
   around the inner monad. In other words, if I have <literal>errorValue :: ErrorT MyError IO
    MyValue</literal>, I can apply <literal>runErrorT</literal> and get a value of type <literal>IO
    (Either MyError MyValue)</literal>. The looks quite a bit like bi-directional translation,
   doesn't it?</para>
    <para>Well, not quite. We originally had an <literal>ErrorT MyError IO</literal> monad, with a value of
   type <literal>MyValue</literal>. Now we have a monad of type <literal>IO</literal> with a value of
   type <literal>Either MyError MyValue</literal>. So this process has in fact changed the value,
   while the lifting process leaves it the same.</para>
    <para>But still, with a little fancy footwork we can unwrap the ErrorT, do some processing, and then
   wrap it back up again.</para>
    <programlisting language="haskell">useMyFileError1 :: ErrorT MyError IO ()
useMyFileError1 =
    let unwrapped :: Handle -&gt; IO (Either MyError ())
        unwrapped handle = runErrorT $ sayHiError handle
        applied :: IO (Either MyError ())
        applied = withMyFile unwrapped
        rewrapped :: ErrorT MyError IO ()
        rewrapped = ErrorT applied
     in rewrapped</programlisting>
    <para>This is the crucial point of this whole article, so look closely. We first unwrap our monad.
   This means that, to the outside world, it's now just a plain old IO value. Internally, we've
   stored all the information from our ErrorT transformer. Now that we have a plain old IO, we can
   easily pass it off to withMyFile. withMyFile takes in the internal state and passes it back out
   unchanged. Finally, we wrap everything back up into our original ErrorT.</para>
    <para>This is the entire pattern of monad-control: we embed the extra features of our monad
   transformer inside the value. Once in the value, the type system ignores it and focuses on the
   inner monad. When we're done playing around with that inner monad, we can pull our state back out
   and reconstruct our original monad stack.</para>
   </section>
   <section>
    <title>Types</title>
    <para/>
    <para>I purposely started with the ErrorT transformer, as it is one of the simplest for this
   inversion mechanism. Unfortunately, others are a bit more complicated. Take for instance ReaderT.
   It is defined as <literal>newtype ReaderT r m a = ReaderT { runReaderT :: r -&gt; m a }</literal>. If
   we apply <literal>runReaderT</literal> to it, we get a function that returns a monadic value. So
   we're going to need some extra machinery to deal with all that stuff. And this is when we leave
   Kansas behind.</para>
    <para>There are a few approaches to solving these problems. In the past, I implemented a solution
   using type families in the <function>neither</function> package. Anders Kaseorg implemented a much
   more straight-forward solution in <function>monad-peel</function>. And for efficiency, in
    <function>monad-control</function>, Bas van Dijk uses CPS (continuation passing style) and
   existential types.</para>
    <note>
     <para>The code taken from monad-control actually applies to version 0.2. 0.3 changed things just a
   bit, by making the state explicit with an associated type, and generalizing
    <literal>MonadControlIO</literal> to <literal>MonadBaseControl</literal>, but the concepts are still
   the same.</para>
    </note>
    <para>The first type we're going to look at
   is:<programlisting language="haskell">type Run t = forall n o b. (Monad n, Monad o, Monad (t o)) =&gt; t n b -&gt; n (t o b)</programlisting>That's
   incredibly dense, let's talk it out. The only "input" datatype to this thing is t, a monad
   transformer. A Run is a function that will then work with <emphasis role="bold">any</emphasis> combination of types n, o
   and b (that's what the forall means). n and o are both monads, while b is a simple value
   contained by them.</para>
    <para>The left hand side of the Run function, <literal>t n b</literal>, is our monad transformer
   wrapped around the n monad and holding a b value. So for example, that could be a <literal>MyTrans
    FirstMonad MyValue</literal>. It then returns a value with the transformer "popped" inside, with
   a brand new monad at its core. In other words, <literal>FirstMonad (MyTrans NewMonad
    MyValue)</literal>.</para>
    <para>That might sound pretty scary at first, but it actually isn't as foreign as you'd think: this
   is essentially what we did with ErrorT. We started with ErrorT on the outside, wrapping around
   IO, and ended up with an IO by itself containing an Either. Well guess what: another way to
   represent an Either is <literal>ErrorT MyError Identity</literal>. So essentially, we pulled the IO
   to the outside and plunked an Identity in its place. We're doing the same thing in a Run: pulling
   the FirstMonad outside and replacing it with a NewMonad.<note>
      <para>Now might be a good time to get a
    beer.</para>
     </note>
    </para>
    <para>Alright, now we're getting somewhere. If we had access to one of those Run functions, we could
   use it to peel off the ErrorT on our sayHiError function and pass it to withMyFile. With the
   magic of undefined, we can play such a game:</para>
    <programlisting language="haskell">errorRun :: Run (ErrorT MyError)
errorRun = undefined

useMyFileError2 :: IO (ErrorT MyError Identity ())
useMyFileError2 =
    let afterRun :: Handle -&gt; IO (ErrorT MyError Identity ())
        afterRun handle = errorRun $ sayHiError handle
        applied :: IO (ErrorT MyError Identity ())
        applied = withMyFile afterRun
     in applied</programlisting>
    <para>This looks eerily similar to our previous example. In fact, errorRun is acting almost
   identically to runErrorT. However, we're still left with two problems: we don't know where to get
   that errorRun value from, and we still need to restructure the original ErrorT after we're
   done.</para>
    <section>
     <title>MonadTransControl</title>
     <para/>
     <para>Obviously in the specific case we have before us, we could use our knowledge of the ErrorT
   transformer to beat the types into submission and create our Run function manually. But what we
    <emphasis>really</emphasis> want is a general solution for many transformers. At this point, you know we need
   a typeclass.</para>
     <para>So let's review what we need: access to a Run function, and some way to restructure our
   original transformer after the fact. And thus was born MonadTransControl, with its single method
   liftControl:</para>
     <programlisting language="haskell">class MonadTrans t =&gt; MonadTransControl t where
    liftControl :: Monad m =&gt; (Run t -&gt; m a) -&gt; t m a</programlisting>
     <para>Let's look at this closely. liftControl takes a function (the one we'll be writing). That
   function is provided with a Run function, and must return a value in some monad (m). liftControl
   will then take the result of that function and reinstate the original transformer on top of
   everything.</para>
     <programlisting language="haskell">useMyFileError3 :: Monad m =&gt; ErrorT MyError IO (ErrorT MyError m ())
useMyFileError3 =
    liftControl inside
  where
    inside :: Monad m =&gt; Run (ErrorT MyError) -&gt; IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           =&gt; Run (ErrorT MyError) -&gt; Handle -&gt; IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())</programlisting>
     <para>Close, but not exactly what I had in mind. What's up with the double monads? Well, let's start
   at the end: sayHiError handle returns a value of type <literal>ErrorT MyError IO ()</literal>. This
   we knew already, no surprises. What might be a little surprising (it got me, at least) is the
   next two steps.</para>
     <para>First we apply run to that value. Like we'd discussed before, the result is that the IO inner
   monad is popped to the outside, to be replaced by some arbitrary monad (represented by m here).
   So we end up with an IO (ErrorT MyError m ()). Ok... We then get the same result after applying
   withMyFile. Not surprising.</para>
     <para>The last step took me a long time to understand correctly. Remember how we said that we
   reconstruct the original transformer? Well, so we do: by plopping it right on top of everything
   else we have. So our end result is the previous type- <literal>IO (ErrorT MyError m ())</literal>-
   with a <literal>ErrorT MyError</literal> stuck on the front.</para>
     <para>Well, that seems just about utterly worthless, right? Well, almost. But don't forget, that "m"
   can be any monad, including IO. If we treat it that way, we get <literal>ErrorT MyError IO (ErrorT
    MyError IO ())</literal>. That looks a lot like <literal>m (m a)</literal>, and we want just plain
   old <literal>m a</literal>. Fortunately, now we're in
   luck:<programlisting language="haskell">useMyFileError4 :: ErrorT MyError IO ()
useMyFileError4 = join useMyFileError3</programlisting>And
   it turns out that this usage is so common, that Bas had mercy on us and defined a helper
   function:<programlisting language="haskell">control :: (Monad m, Monad (t m), MonadTransControl t)
        =&gt; (Run t -&gt; m (t m a)) -&gt; t m a
control = join . liftControl</programlisting>So
   all we need to write
   is:<programlisting language="haskell">useMyFileError5 :: ErrorT MyError IO ()
useMyFileError5 =
    control inside
  where
    inside :: Monad m =&gt; Run (ErrorT MyError) -&gt; IO (ErrorT MyError m ())
    inside run = withMyFile $ helper run
    helper :: Monad m
           =&gt; Run (ErrorT MyError) -&gt; Handle -&gt; IO (ErrorT MyError m ())
    helper run handle = run (sayHiError handle :: ErrorT MyError IO ())</programlisting>
     </para>
     <para>And just to make it a little
   shorter:<programlisting language="haskell">useMyFileError6 :: ErrorT MyError IO ()
useMyFileError6 = control $ \run -&gt; withMyFile $ run . sayHiError</programlisting>
     </para>
    </section>
    <section>
     <title>MonadControlIO</title>
     <para/>
     <para>The MonadTrans class provides the lift method, which allows you to lift an action one level in
   the stack. There is also the MonadIO class that provides liftIO, which lifts an IO action as far
   in the stack as desired. We have the same breakdown in monad-control. But first, we need a
   corrolary to
   Run:<programlisting language="haskell">type RunInBase m base = forall b. m b -&gt; base (m b)</programlisting>Instead
   of dealing with a transformer, we're dealing with two monads. base is the underlying monad, and m
   is a stack built on top of it. RunInBase is a function that takes a value of the entire stack,
   pops out that base, and puts in on the outside. Unlike in the Run type, we don't replace it with
   an arbitrary monad, but with the original one. To use some more concrete types:</para>
     <programlisting language="haskell">RunInBase (ErrorT MyError IO) IO = forall b. ErrorT MyError IO b -&gt; IO (ErrorT MyError IO b)</programlisting>
     <para>This should look fairly similar to what we've been looking at so far, the only difference is
   that we want to deal with a specific inner monad. Our MonadControlIO class is really just an
   extension of MonadControlTrans using this RunInBase.</para>
     <programlisting language="haskell">class MonadIO m =&gt; MonadControlIO m where
    liftControlIO :: (RunInBase m IO -&gt; IO a) -&gt; m a</programlisting>
     <para>Simply put, liftControlIO takes a function which receives a RunInBase. That RunInBase can be
   used to strip down our monad to just an IO, and then liftControlIO builds everything back up
   again. And like MonadControlTrans, it comes with a helper function</para>
     <programlisting language="haskell">controlIO :: MonadControlIO m =&gt; (RunInBase m IO -&gt; IO (m a)) -&gt; m a
controlIO = join . liftControlIO</programlisting>
     <para>We can easily rewrite our previous example with
   it:<programlisting language="haskell">useMyFileError7 :: ErrorT MyError IO ()
useMyFileError7 = controlIO $ \run -&gt; withMyFile $ run . sayHiError</programlisting>And
   as an advantage, it easily scales to multiple
   transformers:<programlisting language="haskell">sayHiCrazy :: Handle -&gt; ReaderT Int (StateT Double (ErrorT MyError IO)) ()
sayHiCrazy handle = liftIO $ hPutStrLn handle "Madness!"

useMyFileCrazy :: ReaderT Int (StateT Double (ErrorT MyError IO)) ()
useMyFileCrazy = controlIO $ \run -&gt; withMyFile $ run . sayHiCrazy</programlisting>
     </para>
    </section>
   </section>
   <section>
    <title>Real Life Examples</title>
    <para/>
    <para>Let's solve some real-life problems with this code. Probably the biggest motivating use case is
   exception handling in a transformer stack. For example, let's say that we want to automatically
   run some cleanup code when an exception is thrown. If this were normal IO code, we'd
   use:<programlisting language="haskell">onException :: IO a -&gt; IO b -&gt; IO a</programlisting>But if we're
   in the ErrorT monad, we can't pass in either the action or the cleanup. In comes controlIO to the
   rescue:<programlisting language="haskell">onExceptionError :: ErrorT MyError IO a
                 -&gt; ErrorT MyError IO b
                 -&gt; ErrorT MyError IO a
onExceptionError action after = controlIO $ \run -&gt;
    run action `onException` run after</programlisting>
    </para>
    <para>Let's say we need to allocate some memory to store a Double in. In the IO monad, we could just
   use the alloca function. Once again, our solution is
   simple:<programlisting language="haskell">allocaError :: (Ptr Double -&gt; ErrorT MyError IO b)
            -&gt; ErrorT MyError IO b
allocaError f = controlIO $ \run -&gt; alloca $ run . f</programlisting>
    </para>
   </section>
   <section>
    <title>Lost State</title>
    <para/>
    <para>Let's rewind a bit to our onExceptionError. It uses onException under the surface,
   which has a type signature: <literal>IO a -&gt; IO b -&gt; IO a</literal>. Let me ask you
   something: what happened to the b in the output? Well, it was thoroughly ignored. But that seems
   to cause us a bit of a problem. After all, we store our transformer state information in the
   value of the inner monad. If we ignore it, we're essentially ignoring the monadic side effects as
   well!</para>
    <para>And the answer is that, yes, this does happen with monad-control. Certain functions
   will drop some of the monadic side effects. This is put best by Bas, in the comments on the
   relevant functions:<blockquote>
      <para>Note, any monadic side effects in m of the "release" computation
    will be discarded; it is run only for its side effects in IO.</para>
     </blockquote>In practice, monad-control
   will usually be doing the right thing for you, but you need to be aware that some side effects
   may disappear.</para>
   </section>
   <section>
    <title>More Complicated Cases</title>
    <para/>
    <para>In order to make our tricks work so far, we've needed to have functions that give us full
   access to play around with their values. Sometimes, this isn't the case. Take, for instance:</para>
    <programlisting language="haskell">addMVarFinalizer :: MVar a -&gt; IO () -&gt; IO ()</programlisting>
    <para>In this case, we are required to have no value inside our finalizer function. Intuitively, the
   first thing we should notice is that there will be no way to capture our monadic side effects. So
   how do we get something like this to compile? Well, we need to explicitly tell it to drop all of
   its state-holding
   information:<programlisting language="haskell">addMVarFinalizerError :: MVar a -&gt; ErrorT MyError IO () -&gt; ErrorT MyError IO ()
addMVarFinalizerError mvar f = controlIO $ \run -&gt;
    return $ liftIO $ addMVarFinalizer mvar (run f &gt;&gt; return ())</programlisting>
    </para>
    <para>Another case from the same module
   is:<programlisting language="haskell">modifyMVar :: MVar a -&gt; (a -&gt; IO (a, b)) -&gt; IO b</programlisting>Here,
   we have a restriction on the return type in the second argument: it must be a tuple of the value
   passed to that function and the final return value. Unfortunately, I can't see a way of writing a
   little wrapper around modifyMVar to make it work for ErrorT. Instead, in this case, I copied the
   definition of modifyMVar and modified it:</para>
    <programlisting language="haskell">modifyMVar :: MVar a
           -&gt; (a -&gt; ErrorT MyError IO (a, b))
           -&gt; ErrorT MyError IO b
modifyMVar m io =
  Control.Exception.Control.mask $ \restore -&gt; do
    a      &lt;- liftIO $ takeMVar m
    (a',b) &lt;- restore (io a) `onExceptionError` liftIO (putMVar m a)
    liftIO $ putMVar m a'
    return b</programlisting>
   </section>
  </chapter>
  <chapter>
   <title>Conduit</title>
   <para/>
   <para/>
   <para>Conduits are a solution to the streaming data problem. Often times, laziness allows us
   to process large amounts of data without pulling all values into memory. However, doing so in the
   presence of I/O requires us to use <glossterm>lazy I/O</glossterm>. The main downside to lazy I/O is
   non-determinism: we have no guarantees of when our resource finalizers will be run. For small
   application, this may be acceptable, but for a high-load server, we could quickly run out of
   scarce resources, such as file handles.</para>
   <para>Conduits allow us to process large streams of data while still retaining deterministic resource
   handling. They provide a unified interface for data streams, whether they come from files,
   sockets, or memory. And when combined with <literal>ResourceT</literal>, we can safely allocate
   resources, knowing that they will always be reclaimed- even in the presence of exceptions.</para>
   <para>This appendix covers version 0.2 of the <function>conduit</function> package.</para>
   <section>
    <title>Conduits in Five Minutes</title>
    <para/>
    <para>While a good understanding of the lower-level mechanics of conduits is advisable, you can get
   very far without it. Let's start off with some high-level examples. Don't worry if some of the
   details seem a bit magical right now. We'll cover everything in the course of this appendix.
   Let's start with the terminology, and then some sample code.</para>
    <variablelist>
     <varlistentry>
      <term>Source</term>
      <listitem>
       <para>A producer of data. The data could be in a file, coming from a socket, or in memory as a
     list. To access this data, we <glossterm>pull</glossterm> from the source.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Sink</term>
      <listitem>
       <para>A consumer of data. Basic examples would be a sum function (adding up a stream of numbers
     fed in), a file sink (which writes all incoming bytes to a file), or a socket. We
      <glossterm>push</glossterm> data into a sink. When the sink finishes processing (we'll explain that
     later), it returns some value.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Conduit</term>
      <listitem>
       <para>A transformer of data. The simplest example is a map function, though there are many others.
     Like a sink, we <glossterm>push</glossterm> data into a conduit. But instead of returning a single value
     at the end, a conduit can return multiple outputs every time it is pushed to.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Fuse</term>
      <listitem>
       <para>(Thanks to David Mazieres for the term.) A conduit can be <glossterm>fused</glossterm> with a source
     to produce a new, modified source (the <literal>$=</literal> operator). For example, you could
     have a source that reads bytes from a file, and a conduit that decodes bytes into text. If you
     fuse them together, you would now have a source that reads text from a file. Likewise, a
     conduit and a sink can fuse into a new sink (<literal>=$</literal>), and two conduits can fuse
     into a new conduit (<literal>=$=</literal>).</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>Connect</term>
      <listitem>
       <para>You can connect a source to a sink using the <literal>$$</literal> operator. Doing so will
     pull data from the source and push it to the sink, until either the source or sink signals that
     they are "done."</para>
      </listitem>
     </varlistentry>
    </variablelist>
    <para>Let's see some examples of conduit code.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit -- the core library
import qualified Data.Conduit.List as CL -- some list-like functions
import qualified Data.Conduit.Binary as CB -- bytes
import qualified Data.Conduit.Text as CT

import Data.ByteString (ByteString)
import Data.Text (Text)
import qualified Data.Text as T
import Control.Monad.ST (runST)

-- Let's start with the basics: connecting a source to a sink. We'll use the
-- built in file functions to implementing efficient, constant-memory,
-- resource-friendly file copying.
--
-- Two things to note: we use $$ to connect our source to our sink, and then
-- use runResourceT.
copyFile :: FilePath -&gt; FilePath -&gt; IO ()
copyFile src dest = runResourceT $ CB.sourceFile src $$ CB.sinkFile dest


-- The Data.Conduit.List module provides a number of helper functions for
-- creating sources, sinks, and conduits. Let's look at a typical fold: summing
-- numbers.
sumSink :: Resource m =&gt; Sink Int m Int
sumSink = CL.fold (+) 0

-- If we want to go a little more low-level, we can code our sink with the
-- sinkState function. This function takes three parameters: an initial state,
-- a push function (receive some more data), and a close function.
sumSink2 :: Resource m =&gt; Sink Int m Int
sumSink2 = sinkState
    0 -- initial value

    -- update the state with the new input and
    -- indicate that we want more input
    (\accum i -&gt; return $ StateProcessing (accum + i))
    (\accum -&gt; return accum) -- return the current accum value on close

-- Another common helper function is sourceList. Let's see how we can combine
-- that function with our sumSink to reimplement the built-in sum function.
sum' :: [Int] -&gt; Int
sum' input = runST $ runResourceT $ CL.sourceList input $$ sumSink

-- Since this is Haskell, let's write a source to generate all of the
-- Fibonacci numbers. We'll use sourceState. The state will contain the next
-- two numbers in the sequence. We also need to provide a pull function, which
-- will return the next number and update the state.
fibs :: Resource m =&gt; Source m Int
fibs = sourceState
    (0, 1) -- initial state
    (\(x, y) -&gt; return $ StateOpen (y, x + y) x)

-- Suppose we want to get the sum of the first 10 Fibonacci numbers. We can use
-- the isolate conduit to make sure the sum sink only consumes 10 values.
sumTenFibs :: Int
sumTenFibs =
       runST -- runs fine in pure code
     $ runResourceT
     $ fibs
    $= CL.isolate 10 -- fuse the source and conduit into a source
    $$ sumSink

-- We can also fuse the conduit into the sink instead, we just swap a few
-- operators.
sumTenFibs2 :: Int
sumTenFibs2 =
       runST
     $ runResourceT
     $ fibs
    $$ CL.isolate 10
    =$ sumSink

-- Alright, let's make some conduits. Let's turn our numbers into text. Sounds
-- like a job for a map...

intToText :: Int -&gt; Text -- just a helper function
intToText = T.pack . show

textify :: Resource m =&gt; Conduit Int m Text
textify = CL.map intToText

-- Like previously, we can use a conduitState helper function. But here, we
-- don't even need state, so we provide a dummy state value.
textify2 :: Resource m =&gt; Conduit Int m Text
textify2 = conduitState
    ()
    (\() input -&gt; return $ StateProducing () [intToText input])
    (\() -&gt; return [])

-- Let's make the unlines conduit, that puts a newline on the end of each piece
-- of input. We'll just use CL.map; feel free to write it with conduitState as
-- well for practice.
unlines' :: Resource m =&gt; Conduit Text m Text
unlines' = CL.map $ \t -&gt; t `T.append` "\n"

-- And let's write a function that prints the first N fibs to a file. We'll
-- use UTF8 encoding.
writeFibs :: Int -&gt; FilePath -&gt; IO ()
writeFibs count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $= unlines'
   $= CT.encode CT.utf8
   $$ CB.sinkFile dest

-- We used the $= operator to fuse the conduits into the sources, producing a
-- single source. We can also do the opposite: fuse the conduits into the sink. We can even combine the two.
writeFibs2 :: Int -&gt; FilePath -&gt; IO ()
writeFibs2 count dest =
      runResourceT
    $ fibs
   $= CL.isolate count
   $= textify
   $$ unlines'
   =$ CT.encode CT.utf8
   =$ CB.sinkFile dest

-- Or we could fuse all those inner conduits into a single conduit...
someIntLines :: ResourceThrow m -- encoding can throw an exception
             =&gt; Int
             -&gt; Conduit Int m ByteString
someIntLines count =
      CL.isolate count
  =$= textify
  =$= unlines'
  =$= CT.encode CT.utf8

-- and then use that conduit
writeFibs3 :: Int -&gt; FilePath -&gt; IO ()
writeFibs3 count dest =
      runResourceT
    $ fibs
   $= someIntLines count
   $$ CB.sinkFile dest

main :: IO ()
main = do
    putStrLn $ "First ten fibs: " ++ show sumTenFibs
    writeFibs 20 "fibs.txt"
    copyFile "fibs.txt" "fibs2.txt"</programlisting>
   </section>
   <section>
    <title>Structure of this Chapter</title>
    <para/>
    <para>The remainder of this chapter covers five major topics in conduits:</para>
    <itemizedlist>
     <listitem>
      <para>
       <literal>ResourceT</literal>, the underlying technique that allows us to have guaranteed
    resource deallocation.</para>
     </listitem>
     <listitem>
      <para>Sources, our data producers</para>
     </listitem>
     <listitem>
      <para>Sinks, our data consumers</para>
     </listitem>
     <listitem>
      <para>Conduits, our data transformers</para>
     </listitem>
     <listitem>
      <para>Buffering, which allows us to avoid Inversion of Control</para>
     </listitem>
    </itemizedlist>
   </section>
   <section>
    <title>The Resource monad transformer</title>
    <para/>
    <para>The Resource transformer (<literal>ResourceT</literal>) plays a vital role in proper resource
   management in the conduit project. It is included within the <literal>conduit</literal> package
   itself. We'll explaining <literal>ResourceT</literal> as its own entity. While some of the design
   decisions clearly are biased towards conduits, <literal>ResourceT</literal> should remain a usable
   tool in its own right.</para>
    <section>
     <title>Goals</title>
     <para/>
     <para>What's wrong with the following code?</para>
     <programlisting language="haskell">import System.IO

main = do
    output &lt;- openFile "output.txt" WriteMode
    input  &lt;- openFile "input.txt"  ReadMode
    hGetContents input &gt;&gt;= hPutStr output
    hClose input
    hClose output</programlisting>
     <para>If the file <filename>input.txt</filename> does not exist, then an exception will be thrown
   when trying to open it. As a result, <literal>hClose output</literal> will never be called, and
   we'll have leaked a scarce resource (a file descriptor). In our tiny program, this isn't a big
   deal, but clearly we can't afford such waste in a long running, highly active server process.</para>
     <para>Fortunately, solving the problem is easy:</para>
     <programlisting language="haskell">import System.IO

main =
    withFile "output.txt" WriteMode $ \output -&gt;
    withFile "input.txt" ReadMode $ \input -&gt;
    hGetContents input &gt;&gt;= hPutStr output</programlisting>
     <para>
      <literal>withFile</literal> makes sure that the <literal>Handle</literal> is always closed, even in
   the presence of exceptions. It also handles asynchronous exceptions. Overall, it's a great
   approach to use... when you can use it. While often <literal>withFile</literal> is easy to use,
   sometimes it can require restructuring our programs. And this restructuring can range from mildly
   tedious to wildly inefficient.</para>
     <para>Let's take enumerators for example. If you look in the documentation, there is an
    <literal>enumFile</literal> function (for reading contents from a file), but no
    <literal>iterFile</literal> (for writing contents to a file). That's because the flow of control
   in an iteratee doesn't allow proper allocation of the Handle. Instead, in order to write to a
   file, you need to allocate the Handle before entering the Iteratee, e.g.:</para>
     <programlisting language="haskell">import System.IO
import Data.Enumerator
import Data.Enumerator.Binary

main =
    withFile "output.txt" WriteMode $ \output -&gt;
    run_ $ enumFile "input.txt" $$ iterHandle output</programlisting>
     <para>This code works fine, but imagine that, instead of simply piping data directly to the file,
   there was a huge amount of computation that occurred before we need to use the output handle. We
   will have allocated a file descriptor long before we needed it, and thereby locked up a scarce
   resource in our application. Besides this, there are times when we <emphasis>can't</emphasis> allocate the file
   before hand, such as when we won't know which file to open until we've read from the input
   file.</para>
     <para>One of the stated goals of conduits is to solve this problem, and it does so via
    <literal>ResourceT</literal>. As a result, the above program can be written in conduit as:</para>
     <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Data.Conduit
import Data.Conduit.Binary

main = runResourceT $ sourceFile "input.txt" $$ sinkFile "output.txt"</programlisting>
    </section>
    <section>
     <title>How it Works</title>
     <para/>
     <para>There are essentially three base functions on <literal>ResourceT</literal>, and then a bunch of
   conveniences thrown on top. The first function is:</para>
     <programlisting language="haskell">register :: IO () -&gt; ResourceT IO ReleaseKey</programlisting>
     <note>
      <para>This function, and the others below, are actually more polymorphic than implied here,
   allowing other monads besides <literal>IO</literal>. In fact, almost any transformer on top of
    <literal>IO</literal>, as well as any <literal>ST</literal> stacks, work. We'll cover the details of
   that later.</para>
     </note>
     <para>This function registers a piece of code that it asserts <emphasis role="bold">must</emphasis> be run. It gives back a
    <literal>ReleaseKey</literal>, which is used by the next function:</para>
     <programlisting language="haskell">release :: ReleaseKey -&gt; ResourceT IO ()</programlisting>
     <para>Calling <literal>release</literal> on a <literal>ReleaseKey</literal> immediately performs the
   action you previously registered. You may call <literal>release</literal> on the same
    <literal>ReleaseKey</literal> as many times as you like; the first time it is called, it
    <glossterm>unregisters</glossterm> the action. This means you can safely register an action like a memory
   free, and have no concerns that it will be called twice.</para>
     <para>Eventually, we'll want to exit our special <literal>ResourceT</literal>. To do so, we use:</para>
     <programlisting language="haskell">runResourceT :: ResourceT IO a -&gt; IO a</programlisting>
     <para>This seemingly innocuous function is where all the magic happens. It runs through all of the
   registered cleanup actions and performs them. It is fully exception safe, meaning the cleanups
   will be performed in the presence of both synchronous and asynchronous exceptions. And as
   mentioned before, calling <literal>release</literal> will unregister an action, so there is no
   concern of double-freeing.</para>
     <para>Finally, as a convenience, we provide one more function for the common case of allocating a
   resource and registering a release action:</para>
     <programlisting language="haskell">with :: IO a -- ^ allocate
     -&gt; (a -&gt; IO ()) -- ^ free resource
     -&gt; ResourceT IO (ReleaseKey, a)</programlisting>
     <para>So, to rework our first buggy example to use <literal>ResourceT</literal>, we would write:</para>
     <programlisting language="haskell">import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.Trans.Class (lift)

main = runResourceT $ do
    (releaseO, output) &lt;- with (openFile "output.txt" WriteMode) hClose
    (releaseI, input)  &lt;- with (openFile "input.txt"  ReadMode)  hClose
    lift $ hGetContents input &gt;&gt;= hPutStr output
    release releaseI
    release releaseO</programlisting>
     <para>Now there is no concern of any exceptions preventing the releasing of resources. We could skip
   the <literal>release</literal> calls if we want to, and in an example this small, it would not make
   any difference. But for larger applications, where we want processing to continue, this ensures
   that the <literal>Handle</literal>s are freed as early as possible, keeping our scarce resource
   usage to a minimum.</para>
    </section>
    <section>
     <title>Some Type Magic</title>
     <para/>
     <para>As alluded to, there's a bit more to <literal>ResourceT</literal> than simply running in
    <literal>IO</literal>. Let's cover some of the things we need from this underlying
    <literal>Monad</literal>.</para>
     <itemizedlist>
      <listitem>
       <para>Mutable references to keep track of the registered release actions. You might think we could
    just use a <literal>StateT</literal> transformer, but then our state wouldn't survive
    exceptions.</para>
      </listitem>
      <listitem>
       <para>We only want to register actions in the <glossterm>base monad</glossterm>. For example, if we have a
     <literal>ResourceT (WriterT [Int] IO)</literal> stack, we only want to register
     <literal>IO</literal> actions. This makes it easy to lift our stacks around (i.e., add an extra
    transformer to the middle of an existing stack), and avoids confusing issues about the threading
    of other monadic side-effects.</para>
      </listitem>
      <listitem>
       <para>Some way to guarantee an action is performed, even in the presence of exceptions. This boils
    down to needing a <literal>bracket</literal>-like function.</para>
      </listitem>
     </itemizedlist>
     <para>For the first point, we define a new typeclass to represent monads that have mutable
   references:</para>
     <programlisting language="haskell">class Monad m =&gt; HasRef m where
    type Ref m :: * -&gt; *
    newRef' :: a -&gt; m (Ref m a)
    readRef' :: Ref m a -&gt; m a
    writeRef' :: Ref m a -&gt; a -&gt; m ()
    modifyRef' :: Ref m a -&gt; (a -&gt; (a, b)) -&gt; m b
    mask :: ((forall a. m a -&gt; m a) -&gt; m b) -&gt; m b
    mask_ :: m a -&gt; m a
    try :: m a -&gt; m (Either SomeException a)</programlisting>
     <para>We have an associated type to signify what the reference type should be. (For fans of fundeps,
   you'll see in the next section that this <emphasis>has</emphasis> to be an associated type.) Then we provide a
   number of basic reference operations. Finally, there are some functions to help with exceptions,
   which are needed to safely implement the functions described in the last section. The instance
   for <literal>IO</literal> is very straight-forward:</para>
     <programlisting language="haskell">instance HasRef IO where
    type Ref IO = I.IORef
    newRef' = I.newIORef
    modifyRef' = I.atomicModifyIORef
    readRef' = I.readIORef
    writeRef' = I.writeIORef
    mask = E.mask
    mask_ = E.mask_
    try = E.try</programlisting>
     <para>However, we have a problem when it comes to implementing the <literal>ST</literal> instance:
   there is no way to deal with exceptions in the <literal>ST</literal> monad. As a result,
    <literal>mask</literal>, <literal>mask_</literal> and <literal>try</literal> are given default
   implementations that do no exception checking. This gives rise to the first word of warning:
    <emphasis role="bold">operations in the ST monad are not exception safe</emphasis>. You should not be allocating scarce
   resources in ST when using <literal>ResourceT</literal>. You might be wondering why bother with
    <literal>ResourceT</literal> at all then for <literal>ST</literal>. The answer is that there is a
   lot you can do with conduits without allocating scarce resources, and <literal>ST</literal> is a
   great way to do this in a pure way. But more on this later.</para>
     <para>Now onto point 2: we need some way to deal with this base monad concept. Again, we use an
   associated type (again explained in the next section). Our solution looks something like:</para>
     <programlisting language="haskell">class (HasRef (Base m), Monad m) =&gt; Resource m where
    type Base m :: * -&gt; *

    resourceLiftBase :: Base m a -&gt; m a</programlisting>
     <para>But we forgot about point 3: some <literal>bracket</literal>-like function. So we need one more
   method in this typeclass:</para>
     <programlisting language="haskell">    resourceBracket_ :: Base m a -&gt; Base m b -&gt; m c -&gt; m c</programlisting>
     <para>The reason the first two arguments to <literal>resourceBracket_</literal> (allocation and
   cleanup) live in <literal>Base m</literal> instead of <literal>m</literal> is that, in
    <literal>ResourceT</literal>, all allocation and cleanup lives in the base monad.</para>
     <para>So on top of our <literal>HasRef</literal> instance for <literal>IO</literal>, we now need a
    <literal>Resource</literal> instance as well. This is similarly straight-forward:</para>
     <programlisting language="haskell">instance Resource IO where
    type Base IO = IO
    resourceLiftBase = id
    resourceBracket_ = E.bracket_</programlisting>
     <para>We have similar <literal>ST</literal> instances, with <literal>resourceBracket_</literal> having no
   exception safety. The final step is dealing with monad transformers. We don't need to provide a
    <literal>HasRef</literal> instance, but we do need a <literal>Resource</literal> instance. The
   tricky part is providing a valid implementation of <literal>resourceBracket_</literal>. For this,
   we use some functions from <function>monad-control</function>:</para>
     <programlisting language="haskell">instance (MonadTransControl t, Resource m, Monad (t m))
        =&gt; Resource (t m) where
    type Base (t m) = Base m

    resourceLiftBase = lift . resourceLiftBase
    resourceBracket_ a b c =
        control' $ \run -&gt; resourceBracket_ a b (run c)
      where
        control' f = liftWith f &gt;&gt;= restoreT . return</programlisting>
     <para>For any transformer, its base is the base of its inner monad. Similarly, we lift to the base by
   lifting to the inner monad and then lifting to the base from there. The tricky part is the
   implemetnation of <literal>resourceBracket_</literal>. I will not go into a detailed explanation,
   as I would simply make a fool of myself.</para>
    </section>
    <section>
     <title>Definition of ResourceT</title>
     <para/>
     <para>We now have enough information to understand the definition of <literal>ResourceT</literal>:</para>
     <programlisting language="haskell">newtype ReleaseKey = ReleaseKey Int

type RefCount = Int
type NextKey = Int

data ReleaseMap base =
    ReleaseMap !NextKey !RefCount !(IntMap (base ()))

newtype ResourceT m a =
    ResourceT (Ref (Base m) (ReleaseMap (Base m)) -&gt; m a)</programlisting>
     <para>We see that <literal>ReleaseKey</literal> is simply an <literal>Int</literal>. If you skip a few
   lines down, this will make sense, since we're using an <literal>IntMap</literal> to keep track of
   the registered actions. We also define two type synonyms: <literal>RefCount</literal> and
    <literal>NextKey</literal>. <literal>NextKey</literal> keeps track of the most recently assigned
   value for a key, and is incremented each time <literal>register</literal> is called. We'll touch on
    <literal>RefCount</literal> later.</para>
     <para>The <literal>ReleaseMap</literal> is three pieces of information: the next key and the reference
   count, and then the map of all registered actions. Notice that <literal>ReleaseMap</literal> takes
   a type parameter <literal>base</literal>, which states which monad release actions must live
   in.</para>
     <para>Finally, a <literal>ResourceT</literal> is essentially a <literal>ReaderT</literal> that keeps a
   mutable reference to a <literal>ReleaseMap</literal>. The reference type is determined by the base
   of the monad in question, as is the cleanup monad. This is why we need to use associated
   types.</para>
     <para>The majority of the rest of the code in the <literal>Control.Monad.Trans.Resource</literal>
   module is just providing instances for the <literal>ResourceT</literal> type.</para>
    </section>
    <section>
     <title>Other Typeclasses</title>
     <para/>
     <para>There are three other typeclasses provided by the module:</para>
     <variablelist>
      <varlistentry>
       <term>ResourceUnsafeIO</term>
       <listitem>
        <para>Any monad which can lift <literal>IO</literal> actions into it, but that this may be
     considered unsafe. The prime candidate here is <literal>ST</literal>. Care should be taken to
     only lift actions which do not acquire scarce resources and which don't "fire the missiles." In
     other words, all the normal warnings of <literal>unsafeIOToST</literal> apply.</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>ResourceThrow</term>
       <listitem>
        <para>For actions that can throw exceptions. This automatically applies to all
     <literal>IO</literal>-based monads. For <literal>ST</literal>-based monads, you can use the
     supplied <literal>ExceptionT</literal> transformer to provide exception-throwing capabilities.
     Some functions in conduit, for example, will require this (e.g., text decoding).</para>
       </listitem>
      </varlistentry>
      <varlistentry>
       <term>ResourceIO</term>
       <listitem>
        <para>A convenience class tying together a bunch of other classes, included the two mentioned
     above. This is purely for convenience; you could achieve the same effect without this type
     class, you'd just have to do a lot more typing.</para>
       </listitem>
      </varlistentry>
     </variablelist>
    </section>
    <section>
     <title>Forking</title>
     <para/>
     <para>It would seem that forking a thread would be inherently unsafe with <literal>ResourceT</literal>,
   since the parent thread may call <literal>runResourceT</literal> while the child thread is still
   accessing some of the allocated resources. This is indeed true, <emphasis>if</emphasis> you use the normal
    <literal>forkIO</literal> function.</para>
     <note>
      <para>You can't actually use the standard <literal>forkIO</literal>, since it only operates in the
    <literal>IO</literal> monad, but you could use the <literal>fork</literal> function from
    <function>lifted-base</function>. In fact, due to this issue, the <function>regions</function>
   package does not provide a <literal>MonadBaseControl</literal> instance for its transformer (which
   is very similar to <literal>ResourceT</literal>). However, our goal in <literal>ResourceT</literal>
   is not to make it impossible for programmers to mess up, only to make it easier to do the right
   thing. Therefore, we still provide the instance, even though it could be abused.</para>
     </note>
     <para>In order to solve this, <literal>ResourceT</literal> includes reference counting. When you fork a
   new thread via <literal>resourceForkIO</literal>, the <literal>RefCount</literal> value of the
    <literal>ReleaseMap</literal> is incremented. Every time <literal>runResourceT</literal> is called,
   the value is decremented. Only when the value hits 0 are all the release actions called.</para>
    </section>
    <section>
     <title>Convenience Exports</title>
     <para/>
     <para>In addition to what's been listed so far, there are a few extra functions exported (mostly) for
   convenience.</para>
     <itemizedlist>
      <listitem>
       <para>
        <literal>newRef</literal>, <literal>writeRef</literal>, and <literal>readRef</literal> wrap up the
     <literal>HasRef</literal> versions of the functions and allow them to run in any
     <literal>ResourceT</literal>.</para>
      </listitem>
      <listitem>
       <para>
        <literal>withIO</literal> is essentially a type-restricted version of <literal>with</literal>,
    but working around some of the nastiness with types you would otherwise run into. In general:
    you'll want to use <literal>withIO</literal> when writing <literal>IO</literal> code.</para>
      </listitem>
      <listitem>
       <para>
        <literal>transResourceT</literal> let's you modify which monad your ResourceT is running in,
    assuming it keeps the same
    base.<programlisting language="haskell">transResourceT :: (Base m ~ Base n)
               =&gt; (m a -&gt; n a)
               -&gt; ResourceT m a
               -&gt; ResourceT n a
transResourceT f (ResourceT mx) = ResourceT (\r -&gt; f (mx r))</programlisting>
       </para>
      </listitem>
     </itemizedlist>
    </section>
   </section>
   <section>
    <title>Source</title>
    <para/>
    <para>I think it's simplest to understand sources by looking at the types:</para>
    <programlisting language="haskell">data SourceResult m a = Open (Source m a) a | Closed
data Source m a = Source
    { sourcePull :: ResourceT m (SourceResult m a)
    , sourceClose :: ResourceT m ()
    }</programlisting>
    <para>A source has just two operations on it: you can pull data from it, and you can close it (think
      of closing a file handle). When you pull, you either get some data and the a new
        <literal>Source</literal> (the source is still open), or nothing (the source is closed). Let's
      look at some of the simplest sources:</para>
    <programlisting language="haskell">import Prelude hiding (repeat)
import Data.Conduit

-- | Never give any data
eof :: Monad m =&gt; Source m a
eof = Source
    { sourcePull = return Closed
    , sourceClose = return ()
    }

-- | Always give the same value
repeat :: Monad m =&gt; a -&gt; Source m a
repeat a = Source
    { sourcePull = return $ Open (repeat a) a
    , sourceClose = return ()
    }
</programlisting>
    <para>These sources are very straight-forward, since they always return the same results.
      Additionally, their close records don't do anything. You might think that this is a bug:
      shouldn't a call to <literal>sourcePull</literal> return <literal>Closed</literal> after it's been
      closed? This isn't required, since one of the rules of sources is that they can never be
      reused. In other words:</para>
    <itemizedlist>
     <listitem>
      <para>If a <literal>Source</literal> returns <literal>Open</literal>, it has provided you with a new
          <literal>Source</literal> which you should use in place of the original one.</para>
     </listitem>
     <listitem>
      <para>If it returns <literal>Closed</literal>, then you cannot perform any more operations on
        it.</para>
     </listitem>
    </itemizedlist>
    <para>Don't worry too much about the invariant. In practice, you will almost never call
        <literal>sourcePull</literal> or <literal>sourceClose</literal> yourself. In fact, you hardly
      even write them yourself either (that's what <literal>sourceState</literal> and
        <literal>sourceIO</literal> are for). The point is that we can make some assumptions when we
      implement our sources.</para>
    <section>
     <title>State</title>
     <para/>
     <para>There is something similar about the two sources mentioned above: they never change. They
    <emphasis>always</emphasis> return the same value. In other words, they have no state. For almost all serious
   sources, we'll need some kind of state.</para>
     <note>
      <para>The state might actually be defined outside of our program. For example, if we write a
   source that reads data from a <literal>Handle</literal>, we don't need to manually specify any
   state, since the <literal>Handle</literal> itself already has.</para>
     </note>
     <para>The way we store state in a source is by updating the returned <literal>Source</literal> value in
   the <literal>Open</literal> constructor. This is best seen with an example.</para>
     <programlisting language="haskell">import Data.Conduit
import Control.Monad.Trans.Resource

-- | Provide data from the list, one element at a time.
sourceList :: Resource m =&gt; [a] -&gt; Source m a
sourceList list = Source
    { sourcePull =
        case list of
            [] -&gt; return Closed -- no more data

            -- This is where we store our state: by return a new
            -- Source with the rest of the list
            x:xs -&gt; return $ Open (sourceList xs) x
        , sourceClose = return ()
        }
</programlisting>
     <para>Each time we pull from the source, it checks the input list. If the list is empty, pulling
   returns <literal>Closed</literal>, which makes sense. If the list is not empty, pulling returns
    <literal>Open</literal> with both the next value in the list, and a new <literal>Source</literal>
   value containing the rest of the input list.</para>
    </section>
    <section>
     <title>sourceState and sourceIO</title>
     <para/>
     <para>In addition to being able to manually create <literal>Source</literal>s, we also have a few
   convenience functions that allow us to create most sources in a more high-level fashion.
    <literal>sourceState</literal> let's you write code similar to how you would use the
    <literal>State</literal> monad. You provide an initial state, your pull function is provided with
   the current state, and it returns a new state and a return value. Let's use this to reimplement
   sourceList.</para>
     <programlisting language="haskell">import Data.Conduit
import Control.Monad.Trans.Resource

-- | Provide data from the list, one element at a time.
sourceList :: Resource m =&gt; [a] -&gt; Source m a
sourceList state0 = sourceState
    state0
    pull
  where
    pull [] = return StateClosed
    pull (x:xs) = return $ StateOpen xs x
</programlisting>
     <para>Notice the usage of the <literal>StateClosed</literal> and <literal>StateOpen</literal>
   constructors. These are very similar to <literal>Closed</literal> and <literal>Open</literal>, except
   that instead of specifying the next <literal>Source</literal> to be used, you provide the next
   state (here, the remainder of the list).</para>
     <para>The other common activity is to perform some I/O allocation (like opening a file), registering
   some cleanup action (closing that file), and having a function for pulling data from that
   resource. <literal>conduit</literal> comes built-in with a <literal>sourceFile</literal> function
   that gives a stream of <literal>ByteString</literal>s. Let's write a wildly inefficient alternative
   that returns a stream of characters.</para>
     <programlisting language="haskell">import Data.Conduit
import Control.Monad.Trans.Resource
import System.IO
import Control.Monad.IO.Class (liftIO)

sourceFile :: ResourceIO m =&gt; FilePath -&gt; Source m Char
sourceFile fp = sourceIO
    (openFile fp ReadMode)
    hClose
    (\h -&gt; liftIO $ do
        eof &lt;- hIsEOF h
        if eof
            then return IOClosed
            else fmap IOOpen $ hGetChar h)
</programlisting>
     <para>Like <literal>sourceState</literal>, it uses a variant on the <literal>Open</literal> and
    <literal>Closed</literal> constructors. <literal>sourceIO</literal> does a number of things for
   us:</para>
     <itemizedlist>
      <listitem>
       <para>It registers the cleanup function with the <literal>ResourceT</literal> transformer, ensuring
    it gets called even in the presence of exceptions.</para>
      </listitem>
      <listitem>
       <para>It sets up the <literal>sourceClose</literal> record to release the resource immediately.</para>
      </listitem>
      <listitem>
       <para>As soon as you return <literal>IOClosed</literal>, it will release the resource.</para>
      </listitem>
     </itemizedlist>
    </section>
   </section>
   <section>
    <title>Sinks</title>
    <para/>
    <para>A sink consumes a stream of data, and produces a result. A sink must always produce a result,
   and must always produce a single result. This is encoded in the types themselves.</para>
    <para>There is a <literal>Monad</literal> instance for sink, making it simple to compose multiple sinks
   together into a larger sink. You can also use the built-in sink functions to perform most of your
   work. Like sources, you'll rarely need to dive into the inner workings. Let's start off with an
   example: getting lines from a stream of <literal>Char</literal>s (we'll assume Unix line endings
   for simplicity).</para>
    <programlisting language="haskell">import Data.Conduit
import qualified Data.Conduit.List as CL

-- Get a single line from the stream.
sinkLine :: Resource m =&gt; Sink Char m String
sinkLine = sinkState
    id -- initial state, nothing at the beginning of the line
    push
    close
  where
    -- On a new line, return the contents up until here
    push front '\n' =
        return $ StateDone Nothing $ front []

    -- Just another character, add it to the front and keep going
    push front char =
        return $ StateProcessing $ front . (char:)

    -- Got an EOF before hitting a newline, just give what we have so far
    close front = return $ front []

-- Get all the lines from the stream, until we hit a blank line or EOF.
sinkLines :: Resource m =&gt; Sink Char m [String]
sinkLines = do
    line &lt;- sinkLine
    if null line
        then return []
        else do
            lines &lt;- sinkLines
            return $ line : lines

content :: String
content = unlines
    [ "This is the first line."
    , "Here's the second."
    , ""
    , "After the blank."
    ]

main :: IO ()
main = do
    lines &lt;- runResourceT $ CL.sourceList content $$ sinkLines
    mapM_ putStrLn lines</programlisting>
    <para>Running this sample produces the expected output:</para>
    <programlisting>This is the first line.
Here's the second.</programlisting>
    <para>
     <literal>sinkLine</literal> demonstrates usage of the <literal>sinkState</literal> function, which
   is very similar to the <literal>sourceState</literal> function we just saw. It takes three
   arguments: an initial state, a push function (takes the current state and next input, and returns
   a new state and result) and a close function (takes the current state and returns an output). As
   opposed to <literal>sourceState</literal>- which doesn't need a close function- a sink is required
   to always return a result.</para>
    <para>Our push function has two clauses. When it gets a newline character, it indicates that
   processing is complete via <literal>StateDone</literal>. The <literal>Nothing</literal> indicates
   that there is no leftover input (we'll discuss that later). It also gives an output of all the
   characters it has received. The second clause simply appends the new character to the existing
   state and indicates that we are still working via <literal>StateProcessing</literal>. The close
   function returns all characters.</para>
    <para>
     <literal>sinkLines</literal> shows how we can use the monadic interface to produce new sinks. If
   you replace <literal>sinkLine</literal> with <literal>getLine</literal>, this would look like
   standard code to pull lines from standard input. This familiar interface should make it easy to
   get up and running quickly.</para>
    <section>
     <title>Types</title>
     <para/>
     <para>The types for sinks are just a bit more involved than sources. Let's have a look:</para>
     <programlisting language="haskell">type SinkPush input m output = input -&gt; ResourceT m (SinkResult input m output)
type SinkClose m output = ResourceT m output

data SinkResult input m output =
    Processing (SinkPush input m output) (SinkClose m output)
  | Done (Maybe input) output

data Sink input m output =
    SinkNoData output
  | SinkData
        { sinkPush :: SinkPush input m output
        , sinkClose :: SinkClose m output
        }
  | SinkLift (ResourceT m (Sink input m output))</programlisting>
     <para>Whenever a sink is pushed to, it can either say it needs more data
   (<literal>Processing</literal>) or say it's all done. When still processing, it must provided
   updated push and close function; when done, it returns any leftover inut and the output. Fairly
   straight-forward.</para>
     <para>The first real "gotcha" is the three constructors for <literal>Sink</literal>. Why do we need
    <literal>SinkNoData</literal>: aren't sinks all about consuming data? The answer is that we need
   it to efficiently implement our <literal>Monad</literal> instance. When we use
    <literal>return</literal>, we're giving back a value that requires no data in order to compute it.
   We could model this with the <literal>SinkData</literal> constructor, with something like:</para>
     <programlisting language="haskell">myReturn a = SinkData (\input -&gt; return (Done (Just input) a)) (return a)</programlisting>
     <para>But doing so would force reading in an extra bit of input that we don't need right now, and
   possibly will never need. (Have a look again at the <literal>sinkLines</literal> example.) So
   instead, we have an extra constructor to indicate that no input is required. Likewise,
    <literal>SinkLift</literal> is provided in order to implement an efficient
    <literal>MonadTrans</literal> instance.</para>
    </section>
    <section>
     <title>Sinks: no helpers</title>
     <para/>
     <para>Let's try to implement some sinks on the "bare metal", without any helper functions.</para>
     <programlisting language="haskell">import Data.Conduit
import System.IO
import Control.Monad.Trans.Resource
import Control.Monad.IO.Class (liftIO)

-- Consume all input and discard it.
sinkNull :: Resource m =&gt; Sink a m ()
sinkNull =
    SinkData push close
  where
    push _ignored = return $ Processing push close
    close = return ()

-- Let's stream characters to a file. Here we do need some kind of
-- initialization. We do this by initializing in a push function,
-- and then returning a different push function for subsequent
-- calls. By using withIO, we know that the handle will be closed even
-- if there's an exception.
sinkFile :: ResourceIO m =&gt; FilePath -&gt; Sink Char m ()
sinkFile fp =
    SinkData pushInit closeInit
  where
    pushInit char = do
        (releaseKey, handle) &lt;- withIO (openFile fp WriteMode) hClose
        push releaseKey handle char
    closeInit = do
        -- Never opened a file, so nothing to do here
        return ()

    push releaseKey handle char = do
        liftIO $ hPutChar handle char
        return $ Processing (push releaseKey handle) (close releaseKey handle)

    close releaseKey _ = do
        -- Close the file handle as soon as possible.
        return ()

-- And we'll count how many values were in the stream.
count :: Resource m =&gt; Sink a m Int
count =
    SinkData (push 0) (close 0)
  where
    push count _ignored =
        return $ Processing (push count') (close count')
      where
        count' = count + 1

    close count = return count
</programlisting>
     <para>Nothing is particularly complicated to implement. You should notice a common pattern here:
            declaring your push and close functions in a <literal>where</literal> clause, and then
            using them twice: once for the initial <literal>SinkData</literal>, and once for the
                <literal>Processing</literal> constructor. This can become a bit tedious; that's why
            we have helper functions.</para>
    </section>
    <section>
     <title>Sinks: with helpers</title>
     <para/>
     <para>Let's rewrite <literal>sinkFile</literal> and <literal>count</literal> to take advantage of the
   helper functions <literal>sinkIO</literal> and <literal>sinkState</literal>, respectively.</para>
     <programlisting language="haskell">import Data.Conduit
import System.IO
import Control.Monad.IO.Class (liftIO)

-- We never have to touch the release key directly, sinkIO automatically
-- releases our resource as soon as we return IODone from our push function,
-- or sinkClose is called.
sinkFile :: ResourceIO m =&gt; FilePath -&gt; Sink Char m ()
sinkFile fp = sinkIO
    (openFile fp WriteMode)
    hClose
    -- push: notice that we are given the handle and the input
    (\handle char -&gt; do
        liftIO $ hPutChar handle char
        return IOProcessing)
    -- close: we're also given the handle, but we don't use it
    (\_handle -&gt; return ())

-- And we'll count how many values were in the stream.
count :: Resource m =&gt; Sink a m Int
count = sinkState
    0
    -- The push function gets both the current state and the next input...
    (\state _ignored -&gt;
        -- and it returns the new state
        return $ StateProcessing $ state + 1)
    -- The close function gets the final state and returns the output.
    (\state -&gt; return state)
</programlisting>
     <para>Nothing dramatic, just slightly shorter, less error-prone code. Using these two helper
   functions is highly recommended, as it ensures proper resource management and state updating.</para>
    </section>
    <section>
     <title>List functions</title>
     <para/>
     <para>As easy as it is to write your own sinks, you'll likely want to take advantage of the built-in
   sinks available in the <function>Data.Conduit.List</function> module. These provide
   analogues to common list functions, like folding. (The module also has some
    <literal>Conduit</literal>s, like <function>map</function>.)</para>
     <para>If you're looking for some way to practice with conduits, reimplementing the functions in the
    <literal>List</literal> module- both with and without the helper functions- would be a good
   start.</para>
     <para>Let's look at some simple things we can make out of the built-in sinks.</para>
     <programlisting language="haskell">import Data.Conduit
import qualified Data.Conduit.List as CL
import Control.Monad.IO.Class (liftIO)

-- A sum function.
sum' :: Resource m =&gt; Sink Int m Int
sum' = CL.fold (+) 0

-- Print every input value to standard output.
printer :: (Show a, ResourceIO m) =&gt; Sink a m ()
printer = CL.mapM_ (liftIO . print)

-- Sum up all the values in a stream after the first five.
sumSkipFive :: Resource m =&gt; Sink Int m Int
sumSkipFive = do
    CL.drop 5
    CL.fold (+) 0

-- Print each input number and sum the total
printSum :: ResourceIO m =&gt; Sink Int m Int
printSum = do
    total &lt;- CL.foldM go 0
    liftIO $ putStrLn $ "Sum: " ++ show total
    return total
  where
    go accum int = do
        liftIO $ putStrLn $ "New input: " ++ show int
        return $ accum + int
</programlisting>
    </section>
    <section>
     <title>Connecting</title>
     <para/>
     <para>At the end of the day, we're actually going to want to use our sinks. While we could manually
   call <literal>sinkPush</literal> and <literal>sinkClose</literal>, it's tedious. For example:</para>
     <programlisting language="haskell">main :: IO ()
main = runResourceT $ do
    res &lt;-
        case printSum of
            SinkData push close -&gt; loop [1..10] push close
            SinkNoData res -&gt; return res
    liftIO $ putStrLn $ "Got a result: " ++ show res
  where
    loop [] _push close = close
    loop (x:xs) push close = do
        mres &lt;- push x
        case mres of
            Done _leftover res -&gt; return res
            Processing push' close' -&gt; loop xs push' close'
</programlisting>
     <para>Instead, the recommended approach is to connect your sink to a source. Not only is this
   simpler, it's less error prone, and means you have a lot of flexibility in where your data is
   coming from. To rewrite the example above:</para>
     <programlisting language="haskell">main :: IO ()
main = runResourceT $ do
    res &lt;- CL.sourceList [1..10] $$ printSum
    liftIO $ putStrLn $ "Got a result: " ++ show res
</programlisting>
     <para>Connecting takes care of testing for the sink constructor (<literal>SinkData</literal> versus
    <literal>SinkNoData</literal> versus <literal>SinkLift</literal>), pulling from the source, and
   pushing to/closing the sink.</para>
     <para>However, there is one thing I wanted to point out from the long-winded example. On the second
   to last line, we ignore the leftover value of <literal>Done</literal>. This brings up the issue of
    <glossterm>data loss</glossterm>. This is an important topic that has had a lot of thought put into it.
   Unfortunately, we can't fully cover it yet, as we haven't discussed the main culprit in the
   drama: <literal>Conduit</literal>s (the type, not the package).</para>
     <para>But as a quick note here, the leftover value from the <literal>Done</literal> constructor is not
   always ignored. The <literal>Monad</literal> instance, for example, uses it to pass data from one
   sink to the next in a binding. And in fact, the real connect operator <emphasis>doesn't</emphasis> always throw
   away the leftovers. When we cover resumable sources later, we'll see that the leftover value is
   put back on the buffer to allow later sinks reusing an existing source to pull the value.</para>
    </section>
   </section>
   <section>
    <title>Conduit</title>
    <para/>
    <para>This section covers the final major datatype in our package, conduits. While sources produce a
   stream of data and sinks consume a stream, conduits transform a stream.</para>
    <section>
     <title>Types</title>
     <para/>
     <para>As we did previously, let's start off by looking at the types involved.</para>
     <programlisting language="haskell">data ConduitResult input m output =
    Producing (Conduit input m output) [output]
  | Finished (Maybe input) [output]

data Conduit input m output = Conduit
    { conduitPush :: input -&gt; ResourceT m (ConduitResult input m output)
    , conduitClose :: ResourceT m [output]
    }</programlisting>
     <para>This should look very similar to what we've seen with sinks. A conduit can be pushed to, in
   which case it returns a result. A result either indicates that it is still producing data, or
   that it is finished. When a conduit is closed, it returns some more output.</para>
     <para>But let's examine the idiosyncracies a bit. Like sinks, we can only push one piece of input at
   a time, and leftover data may be 0 or 1 pieces. However, there are a few changes:</para>
     <itemizedlist>
      <listitem>
       <para>When producing (the equivalent of processing for a sink), we can return output. This is
    because a conduit will product a new stream of output instead of producing a single output value
    at the end of processing.</para>
      </listitem>
      <listitem>
       <para>A sink always returns a single output value, while a conduit returns 0 or more outputs (a
    list). To understand why, consider conduits such as <literal>concatMap</literal> (produces
    multiple outputs for one input) and <literal>filter</literal> (returns 0 or 1 output for each
    input).</para>
      </listitem>
      <listitem>
       <para>We have no special constructor like <literal>SinkNoData</literal>. That's because we provide no
     <literal>Monad</literal> instance for conduits. We'll see later how you can still use a familiar
    Monadic approach to creating conduits.</para>
      </listitem>
     </itemizedlist>
     <para>Overall conduits should seem very similar to what we've covered so far.</para>
    </section>
    <section>
     <title>Simple conduits</title>
     <para/>
     <para>We'll start off by defining some simple conduits that don't have any state.</para>
     <programlisting language="haskell">import Prelude hiding (map, concatMap)
import Data.Conduit

-- A simple conduit that just passes on the data as-is.
passThrough :: Monad m =&gt; Conduit input m input
passThrough = Conduit
    { conduitPush = \input -&gt; return $ Producing passThrough [input]
    , conduitClose = return []
    }

-- map values in a stream
map :: Monad m =&gt; (input -&gt; output) -&gt; Conduit input m output
map f = Conduit
    { conduitPush = \input -&gt; return $ Producing (map f) [f input]
    , conduitClose = return []
    }

-- map and concatenate
concatMap :: Monad m =&gt; (input -&gt; [output]) -&gt; Conduit input m output
concatMap f = Conduit
    { conduitPush = \input -&gt; return $ Producing (concatMap f) $ f input
    , conduitClose = return []
    }
</programlisting>
    </section>
    <section>
     <title>Stateful conduits</title>
     <para/>
     <para>Of course, not all conduits can be declared without state. Doing so on the bare metal is not
   too difficult.</para>
     <programlisting language="haskell">import Prelude hiding (reverse)
import qualified Data.List
import Data.Conduit
import Control.Monad.Trans.Resource

-- Reverse the elements in the stream. Note that this has the same downside as
-- the standard reverse function: you have to read the entire stream into
-- memory before producing any output.
reverse :: Resource m =&gt; Conduit input m input
reverse =
    mkConduit []
  where
    mkConduit state = Conduit (push state) (close state)
    push state input = return $ Producing (mkConduit $ input : state) []
    close state = return state

-- Same thing with sort: it will pull everything into memory
sort :: (Ord input, Resource m) =&gt; Conduit input m input
sort =
    mkConduit []
  where
    mkConduit state = Conduit (push state) (close state)
    push state input = return $ Producing (mkConduit $ input : state) []
    close state = return $ Data.List.sort state
</programlisting>
     <para>But we can do better. Just like <literal>sourceState</literal> and <literal>sinkState</literal>, we
            have <literal>conduitState</literal> to simplify things.</para>
     <programlisting language="haskell">import Prelude hiding (reverse)
import qualified Data.List
import Data.Conduit

-- Reverse the elements in the stream. Note that this has the same downside as
-- the standard reverse function: you have to read the entire stream into
-- memory before producing any output.
reverse :: Resource m =&gt; Conduit input m input
reverse =
    conduitState [] push close
  where
    push state input = return $ StateProducing (input : state) []
    close state = return state

-- Same thing with sort: it will pull everything into memory
sort :: (Ord input, Resource m) =&gt; Conduit input m input
sort =
    conduitState [] push close
  where
    push state input = return $ StateProducing (input : state) []
    close state = return $ Data.List.sort state
</programlisting>
    </section>
    <section>
     <title>Using conduits</title>
     <para/>
     <para>The way <literal>Conduit</literal>s interact with the rest of the package is via
    <glossterm>fusing</glossterm>. A conduit can be fused into a source, producing a new source, fused into a
   sink to produce a new sink, or fused with another conduit to produce a new conduit. It's best to
   just look at the fusion operators.</para>
     <programlisting language="haskell">-- Left fusion: source + conduit = source
($=) :: (Resource m, IsSource src) =&gt; src m a -&gt; Conduit a m b -&gt; Source m b

-- Right fusion: conduit + sink = sink
(=$) :: Resource m =&gt; Conduit a m b -&gt; Sink b m c -&gt; Sink a m c

-- Middle fusion: conduit + conduit = conduit
(=$=) :: Resource m =&gt; Conduit a m b -&gt; Conduit b m c -&gt; Conduit a m c</programlisting>
     <para>Using these operators is straightforward.</para>
     <programlisting language="haskell">useConduits = do
    runResourceT
          $  CL.sourceList [1..10]
          $= reverse
          $= CL.map show
          $$ CL.consume

    -- equivalent to
    runResourceT
          $  CL.sourceList [1..10]
          $$ reverse
          =$ CL.map show
          =$ CL.consume

    -- and equivalent to
    runResourceT
          $  CL.sourceList [1..10]
          $$ (reverse =$= CL.map show)
          =$ CL.consume</programlisting>
     <para>There is in fact one last way of expressing the same idea. I'll leave it as an exercise to the
   reader to discover it.</para>
     <para>It may seem like all these different approaches are redundant. While occassionally you can in
   fact choose whichever approach you feel like using, in many cases you will need a specific
   approach. For example:</para>
     <itemizedlist>
      <listitem>
       <para>If you have a stream of numbers, and you want to apply a conduit (e.g., <literal>map
     show</literal>) to only some of the stream that will be passed to a specific sink, you'll want
    to use the right fusion operator.</para>
      </listitem>
      <listitem>
       <para>If you're reading a file, and want to parse the entire file as textual data, you'll want to
    use left fusion to convert the entire stream.</para>
      </listitem>
      <listitem>
       <para>If you want to create reusable conduits that combine together individual, smaller conduits,
    you'll use middle fusion.</para>
      </listitem>
     </itemizedlist>
    </section>
    <section>
     <title>Data loss</title>
     <para/>
     <para>Let's forget about conduits for a moment. Instead, suppose we want to write a program- using
   plain old lists- that will take a list of numbers, apply some kind of transformation to them,
   take the first five transformed values and do something with them, and then do something else
   with the remaining <emphasis role="bold">non-transformed</emphasis> values. For example, we want something like:</para>
     <programlisting language="haskell">main = do
    let list = [1..10]
        transformed = map show list
        (begin, end) = splitAt 5 transformed
        untransformed = map read end
    mapM_ putStrLn begin
    print $ sum untransformed</programlisting>
     <para>But clearly this isn't a good general solution, since we don't want to have to transform and
   then untransform every element in the list. For one thing, we may not always have an inverse
   function. Another issue is efficiency. In this case, we can write something more efficient:</para>
     <programlisting language="haskell">main = do
    let list = [1..10]
        (begin, end) = splitAt 5 list
        transformed = map show begin
    mapM_ putStrLn transformed
    print $ sum end</programlisting>
     <para>Note the change: we perform our split before transforming any elements. This works because,
   with <literal>map</literal>, we have a 1-to-1 correspondence between the input and output elements.
   So splitting at 5 before or after mapping <literal>show</literal> is the same thing. But what
   happens if we replace <literal>map show</literal> with something more devious.</para>
     <programlisting language="haskell">deviousTransform =
    concatMap go
  where
    go 1 = [show 1]
    go 2 = [show 2, "two"]
    go 3 = replicate 5 "three"
    go x = [show x]</programlisting>
     <para>We no longer have the 1-to-1 correspondence. As a result, we can't use the second method. But
   it's even worse: we can't use the first method either, since there's no inverse of our
    <literal>deviousTransform</literal>.</para>
     <para>There's only one solution to the problem that I'm aware of: transform elements one at a time.
   The final program looks like this:</para>
     <programlisting language="haskell">deviousTransform 1 = [show 1]
deviousTransform 2 = [show 2, "two"]
deviousTransform 3 = replicate 5 "three"
deviousTransform x = [show x]

transform5 :: [Int] -&gt; ([String], [Int])
transform5 list =
    go [] list
  where
    go output (x:xs)
        | newLen &gt;= 5 = (take 5 output', xs)
        | otherwise = go output' xs
      where
        output' = output ++ deviousTransform x
        newLen = length output'

    -- Degenerate case: not enough input to make 5 outputs
    go output [] = (output, [])

main = do
    let list = [1..10]
        (begin, end) = transform5 list
    mapM_ putStrLn begin
    print $ sum end</programlisting>
     <para>The final output of this program is<programlisting>1
2
two
three
three
49</programlisting>What's important
   to note is that the number 3 is converted into five copies of the word "three", yet only two of
   them show up in the output. The rest are discarded in the <literal>take 5</literal> call.</para>
     <para>This whole exercise is just to demonstrate the issue of data loss in conduits. By forcing
   conduits to accept only one input at a time, we avoid the issue of transforming too many elements
   at once. That doesn't mean we don't lose <emphasis>any</emphasis> data: if a conduit produces too much output
   for the receiving sink to handle, some of it may be lost.</para>
     <para>To put all this another way: conduits avoid chunking to get away from data loss. This is not an
   issue unique to conduits. If you look in the implementation of <literal>concatMapM</literal> for
    <function>enumerator</function>, you'll see that it forces elements to be handled one at a time.
   In conduits, we opted to force the issue at the type level.</para>
    </section>
    <section>
     <title>SequencedSink</title>
     <para/>
     <para>Suppose we want to be able to combine up existing conduits and sinks to produce a new, more
   powerful conduit. For example, we want to write a conduit that takes a stream of numbers and sums
   up every five. In other words, for the input <literal>[1..50]</literal>, it should result in the
   sequence <literal>[15,40,65,90,115,140,165,190,215,240]</literal>. We can definitely do this with
   the low-level conduit interface.</para>
     <programlisting language="haskell">sum5Raw :: Resource m =&gt; Conduit Int m Int
sum5Raw =
    conduitState (0, 0) push close
  where
    push (total, count) input
        | newCount == 5 = return $ StateProducing (0, 0) [newTotal]
        | otherwise     = return $ StateProducing (newTotal, newCount) []
      where
        newTotal = total + input
        newCount = count + 1
    close (total, count)
        | count == 0 = return []
        | otherwise  = return [total]
</programlisting>
     <para>But this is frustrating, since we already have all the tools we need to do this at a high
   level! There's the <literal>fold</literal> sink for adding up the numbers, and the
    <literal>isolate</literal> conduit which will only allow up to a certain number of elements to be
   passed to a sink. Can't we combine these somehow?</para>
     <para>The answer is a <literal>SequencedSink</literal>. The idea is to create a normal
    <literal>Sink</literal>, except it returns a special output called a
    <literal>SequencedSinkResponse</literal>. This value can emit new output, stop processing data, or
   transfer control to a new conduit. (See the Haddocks for more information.) Then we can turn this
   into a <literal>Conduit</literal> using the <literal>sequenceSink</literal> function. This function
   also takes some state value that gets passed through to the sink.</para>
     <para>So we can rewrite <literal>sum5Raw</literal> in a much more high-level manner.</para>
     <programlisting language="haskell">sum5 :: Resource m =&gt; Conduit Int m Int
sum5 = sequenceSink () $ \() -&gt; do
    nextSum &lt;- CL.isolate 5 =$ CL.fold (+) 0
    return $ Emit () [nextSum]
</programlisting>
     <para>All of the <literal>()</literal> in there are simply the unused state variable being passed
   around, they can be ignored. Otherwise, we're doing exactly what we want. We fuse
    <literal>isolate</literal> to <literal>fold</literal> to get the sum of the next five elements from
   the stream. We then emit that value, and start all over again.</para>
     <para>Let's say we want to modify this slightly. We want to get the first 8 sums, and then pass
   through the remaining values, multiplied by 2. We can keep track of how many values we've
   returned in our state, and then use the <literal>StartConduit</literal> constructor to pass control
   to the multiply-by-2 conduit next.</para>
     <programlisting language="haskell">sum5Pass :: Resource m =&gt; Conduit Int m Int
sum5Pass = sequenceSink 0 $ \count -&gt; do
    if count == 8
        then return $ StartConduit $ CL.map (* 2)
        else do
            nextSum &lt;- CL.isolate 5 =$ CL.fold (+) 0
            return $ Emit (count + 1) [nextSum]
</programlisting>
     <para>These are obviously very contrived examples, but I hope it makes clear the power and simplicity
   available from this approach.</para>
    </section>
   </section>
   <section>
    <title>Buffering</title>
    <para/>
    <para>Buffering is one of the unique features of conduits. With buffering, conduits no longer need to
   control the flow of your application. In some cases, this can lead to simpler code.</para>
    <section>
     <title>Inversion of Control</title>
     <para/>
     <para>Buffering was actually one of the main motivations in the creation of the
    <literal>conduit</literal> package. To see its importance, we need to consider the approach we've
   seen so far, which we'll call inversion of control, or IoC.</para>
     <note>
      <para>Inversion of control can mean different things in different circles. If you object to its
   usage here, go ahead replace it with some other phrase like "warm, fuzzy thing." I won't be
   offended.</para>
     </note>
     <para>Suppose you want to count how many newline characters there are in a file. In the standard
   imperative approach, you would do someting like:</para>
     <orderedlist>
      <listitem>
       <para>Open the file</para>
      </listitem>
      <listitem>
       <para>Pull some data into a buffer</para>
      </listitem>
      <listitem>
       <para>Loop over the values in the buffer, incrementing a counter on each newline character</para>
      </listitem>
      <listitem>
       <para>Return to 2</para>
      </listitem>
      <listitem>
       <para>Close the file</para>
      </listitem>
     </orderedlist>
     <para>Notice that your code is explicitly calling out to other code and that code is returning
   control back to your code. You have retained full control of the flow of execution of your
   program. The conduit approach we've seen so far does <emphasis>not</emphasis> work this way. Instead, you
   would:</para>
     <orderedlist>
      <listitem>
       <para>Write a sink that counts newlines and adds the result to an accumulator.</para>
      </listitem>
      <listitem>
       <para>Connect the sink to a source</para>
      </listitem>
     </orderedlist>
     <para>There's no doubt in my mind that this is an easier approach. You don't have to worry about
   opening and closing files or pulling data from the file. Instead, the data you need to process is
   simply presented to you. This is the advantage of IoC: you can focus on specifically your piece
   of the code.</para>
     <para>We use this IoC approach all over Haskell: for example, instead of <literal>readMVar</literal>
   and <literal>putMVar</literal>, you can use <literal>withMVar</literal>. Don't bother with
    <literal>openFile</literal> and <literal>closeFile</literal>, just use <literal>withFile</literal> and
   pass in a function that uses the <literal>Handle</literal>. Even C has a version of this: why
    <literal>malloc</literal> and <literal>free</literal> when you could just
   <literal>alloca</literal>?</para>
     <para>Actually, that last one is a huge red herring. Of course you can't just use
    <literal>alloca</literal> for everything. <literal>alloca</literal> only allocates memory locally on
   the stack, not dynamically on the heap. There's no way to return your allocated memory outside
   the current function.</para>
     <para>But actually, the same restriction applies to the whole family of <literal>with</literal>
   functions: you can never return an allocated resource outside of the "block". Usually this works
   out just fine, but we need to recognize that this <emphasis>is</emphasis> a change in how we structure our
   programs. Often times, with simple examples, this is a minor change. However, in larger settings
   this can become very difficult to manage, bordering on impossible at times.</para>
     <section>
      <title>A web server</title>
      <para/>
      <para>Let's say we're going to write a web server. We're going to use the following low-level
   operations:</para>
      <programlisting language="haskell">data Socket
recv    :: Socket -&gt; Int -&gt; IO ByteString -- returns empty when the socket is closed
sendAll :: Socket -&gt; ByteString -&gt; IO ()</programlisting>
      <para>We're up to the part where we need to implement the function <literal>handleConn</literal> that
   handles an individual connection. It will look something like this:</para>
      <programlisting language="haskell">data Request  -- request headers, HTTP version, etc
data Response -- status code, response headers, resposne body
type Application = Request -&gt; IO Response
handleConn :: Application -&gt; Socket -&gt; IO ()</programlisting>
      <para>What does our <literal>handleConn</literal> need to do? In broad strokes:</para>
      <orderedlist>
       <listitem>
        <para>Parse the request line</para>
       </listitem>
       <listitem>
        <para>Parse the request headers</para>
       </listitem>
       <listitem>
        <para>Construct the <literal>Request</literal> value</para>
       </listitem>
       <listitem>
        <para>Pass <literal>Request</literal> to the <literal>Application</literal> and get back a
     <literal>Response</literal>
        </para>
       </listitem>
       <listitem>
        <para>Send the <literal>Response</literal> over the <literal>Socket</literal>
        </para>
       </listitem>
      </orderedlist>
      <para>We start off by writing steps 1 and 2 manually, without using conduits. We'll do this very
   simply and just assume three space-separated strings. We end up with something that looks
   like:</para>
      <programlisting language="haskell">data RequestLine = RequestLine ByteString ByteString ByteString

parseRequestLine :: Socket -&gt; IO RequestLine
parseRequestLine socket = do
    bs &lt;- recv socket 4096
    let (method:path:version:ignored) = S8.words bs
    return $ RequestLine method path version</programlisting>
      <para>There are two issues here: it doesn't handle the case where there are less than three words in
   the chunk of data, and it throws away any extra data. We can definitely solve both of these
   issues manually, but it's very tedious. It's much easier to implement this in terms of
   conduits.</para>
      <programlisting language="haskell">import Data.ByteString (ByteString)
import qualified Data.ByteString as S
import Data.Conduit
import qualified Data.Conduit.Binary as CB
import qualified Data.Conduit.List as CL

data RequestLine = RequestLine ByteString ByteString ByteString

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = do
    let space = toEnum $ fromEnum ' '
    let getWord = do
            CB.dropWhile (== space)
            bss &lt;- CB.takeWhile (/= space) =$ CL.consume
            return $ S.concat bss

    method &lt;- getWord
    path &lt;- getWord
    version &lt;- getWord
    return $ RequestLine method path version
</programlisting>
      <para>This means that our code will automatically be supplied with more data as it comes in, and any
   extra data will automatically be buffered in the <literal>Source</literal>, ready for the next time
   it's used. Now we can easily structure our program together, demonstrating the power of the
   conduits approach:</para>
      <programlisting language="haskell">import Data.ByteString (ByteString)
import Data.Conduit
import Data.Conduit.Network (sourceSocket)
import Control.Monad.IO.Class (liftIO)
import Network.Socket (Socket)

data RequestLine = RequestLine ByteString ByteString ByteString
type Headers = [(ByteString, ByteString)]
data Request = Request RequestLine Headers
data Response = Response
type Application = Request -&gt; IO Response

parseRequestHeaders :: Sink ByteString IO Headers
parseRequestHeaders = undefined

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = undefined

sendResponse :: Socket -&gt; Response -&gt; IO ()
sendResponse = undefined

handleConn :: Application -&gt; Socket -&gt; IO ()
handleConn app socket = do
    req &lt;- runResourceT $ sourceSocket socket $$ do
        requestLine &lt;- parseRequestLine
        headers &lt;- parseRequestHeaders
        return $ Request requestLine headers
    res &lt;- liftIO $ app req
    liftIO $ sendResponse socket res
</programlisting>
     </section>
     <section>
      <title>Whither the request body?</title>
      <para/>
      <para>This is all great, until we realize <emphasis>we can't read the request body</emphasis>. The
    <literal>Application</literal> is simply given the <literal>Request</literal>, and lives in the
    <literal>IO</literal> monad. It has no access whatsoever to the incoming stream of data.</para>
      <para>There's an easy fix for this actually: have the <literal>Application</literal> live in the
    <literal>Sink</literal> monad. This is the very approach we took with
    <function>enumerator</function>-based WAI 0.4. However, there are two problems:</para>
      <itemizedlist>
       <listitem>
        <para>People find it confusing. What people <emphasis>expect</emphasis> is that the <literal>Request</literal>
    value would have a <literal>requestBody</literal> value of type <literal>Source</literal>.</para>
       </listitem>
       <listitem>
        <para>This makes certain kinds of usage incredibly difficult. For example, trying to write an HTTP
    proxy combining WAI and <literal>http-enumerator</literal> proved to be almost impossible.</para>
       </listitem>
      </itemizedlist>
      <para>This is the downside of inversion of control. Our code wants to be in control. It wants to be
   given something to pull from, something to push to, and run with it. We need some solution to the
   problem.</para>
      <note>
       <para>If you think that the situation I described with the proxy isn't so bad, it's because I've
   gone easy on the details. We also need to take into account streaming the response body, and the
   streaming needs to happen on both the client and server side.</para>
      </note>
      <para>The simplest solution would be to just create a new <literal>Source</literal> and pass that to
   the <literal>Application</literal>. Unfortunately, this will cause problems with our buffering. You
   see, when we connect our source to the <literal>parseRequestLine</literal> and
    <literal>parseRequestHeaders</literal> sinks, it made a call to <literal>recv</literal>. If the data
   it received was not enough to cover all of the headers, it would issue another call. When it had
   enough data, it would stop. However, odds are that it didn't stop <emphasis>exactly</emphasis> at the end of
   the headers. It likely consumed a bit of the request body as well.</para>
      <para>If we just create a new source and pass that to the request, it will be missing the beginning
   of the request body. We need some way to pass that buffered data along.</para>
     </section>
    </section>
    <section>
     <title>BufferedSource</title>
     <para/>
     <para>And so we finally get to introduce the last data type in conduits:
    <literal>BufferedSource</literal>. This is an abstract data type, but all it really does is keep a
   mutable reference to a buffer and an underlying <literal>Source</literal>. In order to create one
   of these, you use the <literal>bufferSource</literal> function.</para>
     <programlisting language="haskell">bufferSource ::Resource m =&gt; Source m a -&gt; ResourceT m (BufferedSource m a)</programlisting>
     <para>This one little change is what allows us to easily solve our web server dilemna. Instead of
   connecting a <literal>Source</literal> to our parsing <literal>Sink</literal>s, we use a
    <literal>BufferedSource</literal>. At the end of each connection, any leftover data is put back on
   the buffer. For our web server case, we can now create a <literal>BufferedSource</literal>, use
   that to read the request line and headers, and then pass that same
    <literal>BufferedSource</literal> to the application for reading the request body.</para>
    </section>
    <section>
     <title>Typeclass</title>
     <para/>
     <para>We want to be able to connect a buffered source to a sink, just like we would a regular source.
   We would also like to be able to fuse it to a conduit. In order to make this convenient, conduit
   has a typeclass, <literal>IsSource</literal>. There are instances provided for both
    <literal>Source</literal> and <literal>BufferedSource</literal>. Both the connect
    (<literal>$$</literal>) and left-fuse (<literal>$=</literal>) operators use this typeclass.</para>
     <para>There's one "gotcha" in the <literal>BufferedSource</literal> instance of this typeclass, so
   let's explain it. Suppose we want to write a file copy function, without any buffering. This is a
   fairly standard usage of conduits:</para>
     <programlisting language="haskell">sourceFile input $$ sinkFile output</programlisting>
     <para>When this line is run, both the input and output files are opened, the data is copied, and then
   both files are closed. Let's change this example slightly to use buffering:</para>
     <programlisting language="haskell">bsrc &lt;- bufferSource $ sourceFile input
bsrc $$ isolate 50 =$ sinkFile output1
bsrc $$ sinkFile output2</programlisting>
     <para>When is the input file opened and closed? The opening occurs on the first line, when buffering
   the source. And if we follow the normal rules from sources, the file should be closed after the
   second line. However, if we did that, we couldn't reuse <literal>bsrc</literal> for line 3!</para>
     <para>So instead, <literal>$$</literal> does <emphasis>not</emphasis> close the file. As a result, you can pass a
   buffered source to as many actions as you want, without concerns that the file handle has been
   closed out from under you.</para>
     <note>
      <para>If you remember from earlier, the invariant of a source is that it cannot be pulled from
   after it returns a <literal>Closed</literal> response. In order to allow you to work more easily
   with a <literal>BufferedSource</literal>, this invariant is relaxed. It is the responsibility of
   the <literal>BufferSource</literal> implementation to ensure that after the underlying
    <literal>Source</literal> is closed, it is never used again.</para>
     </note>
     <para>This presents one caveat: when you're finished with a buffered source, you should manually call
    <literal>bsourceClose</literal> on it. However, as usual, this is merely an optimization, as the
   source will automatically be closed when <literal>runResourceT</literal> is called.</para>
    </section>
    <section>
     <title>Recapping the web server</title>
     <para/>
     <para>So what exactly does our web server look like now?</para>
     <programlisting language="haskell">import Data.ByteString (ByteString)
import Data.Conduit
import Data.Conduit.Network (sourceSocket)
import Control.Monad.IO.Class (liftIO)
import Network.Socket (Socket)

data RequestLine = RequestLine ByteString ByteString ByteString
type Headers = [(ByteString, ByteString)]
data Request = Request RequestLine Headers (BufferedSource IO ByteString)
data Response = Response
type Application = Request -&gt; ResourceT IO Response

parseRequestHeaders :: Sink ByteString IO Headers
parseRequestHeaders = undefined

parseRequestLine :: Sink ByteString IO RequestLine
parseRequestLine = undefined

sendResponse :: Socket -&gt; Response -&gt; IO ()
sendResponse = undefined

handleConn :: Application -&gt; Socket -&gt; IO ()
handleConn app socket = runResourceT $ do
    bsrc &lt;- bufferSource $ sourceSocket socket
    requestLine &lt;- bsrc $$ parseRequestLine
    headers &lt;- bsrc $$ parseRequestHeaders
    let req = Request requestLine headers bsrc
    res &lt;- app req
    liftIO $ sendResponse socket res
</programlisting>
     <para>We've made a few minor changes. Firstly, the <literal>Application</literal> now lives in the
    <literal>ResourceT IO</literal> monad. This isn't strictly necessary, but it's very convenient:
   the application can now register cleanup actions that will only take place after the response has
   been fully sent to the client.</para>
     <para>But the major changes are in the <literal>handleConn</literal> function. We now start off by
   buffering our source. This buffered source is then used twice in our function, and then passed
   off to the application.</para>
    </section>
   </section>
  </chapter>
  <chapter>
   <title>Web Application Interface</title>
   <para/>
   <para/>
   <para>It is a problem almost every language used for web development has dealt with: the low level interface between the web server and the application. The earliest example of a solution is the venerable and battle-worn CGI (CGI), providing a language-agnostic interface using only standard input, standard output and environment variables.</para>
   <para>Back when Perl was becoming the de facto web programming language, a major shortcoming of CGI became apparent: the process needed to be started anew for each request. When dealing with an interpretted language and application requiring database connection, this overhead became unbearable. FastCGI (and later SCGI) arose as a successor to CGI, but it seems that much of the programming world went in a different direction.</para>
   <para>Each language began creating its own standard for interfacing with servers. mod_perl.
            mod_python. mod_php. mod_ruby. Within the same language, multiple interfaces arose. In
            some cases, we even had interfaces on top of interfaces. And all of this led to much
            duplicated effort: a Python application designed to work with FastCGI wouldn't work with
            mod_python; mod_python only exists for certain webservers; and these programming
            language specific web server  extensions need to be written for each programming
            language.</para>
   <para>Haskell has its own history. We originally had the <function>cgi</function> package, which provided a monadic interface. The <function>fastcgi</function> package then provided the same interface. Meanwhile, it seemed that the majority of Haskell web development focused on the standalone server. The problem is that each server comes with its own interface, meaning that you need to target a specific backend. This means that it is impossible to share common features, like GZIP encoding, development servers, and testing frameworks.</para>
   <para>WAI attempts to solve this, by providing a generic and efficient interface between web servers and applications. Any <emphasis role="bold">handler</emphasis> supporting the interface can serve any WAI application, while any application using the interface can run on any handler.</para>
   <para>At the time of writing, there are various backends, including Warp, FastCGI, and
            development server. There are even more esoteric backends like <function>wai-handler-webkit</function> for creating desktop apps. <function>wai-extra</function> provides many common middleware components like GZIP, JSON-P
            and virtual hosting. <function>wai-test</function> makes it easy to write unit
            tests, and <function>wai-handler-devel</function> lets you develop your
            applications without worrying about stopping to compile. Yesod targets WAI, and
            Happstack is in the process of converting over as well. It's also used by some
            applications that skip the framework entirely, including the new Hoogle.</para>
   <note>
    <para>Yesod provides an alternate approach for a devel server, known as
                <command>yesod devel</command>. The difference from wai-handler-devel is that yesod
            devel actually compiles your code each time, respecting all settings in your cabal file.
            This is the recommended aproach for general Yesod development.</para>
   </note>
   <section>
    <title>The Interface</title>
    <para/>
    <para>The interface itself is very straight-forward: an application takes a request and returns a response. A response is an HTTP status, a list of headers and a response body. A request contains various information: the requested path, query string, request body, HTTP version, and so on.</para>
    <section>
     <title>Response Body</title>
     <para/>
     <para>Haskell has a datatype known as a lazy bytestring. By utilizing laziness, you can create large values without exhausting memory. Using lazy I/O, you can do such tricks as having a value which represents the entire contents of a file, yet only occupies a small memory footprint. In theory, a lazy bytestring is the only representation necessary for a response body.</para>
     <para>In practice, while lazy byte strings are wonderful for generating "pure" values, the
            lazy I/O necessary to read a file introduces some non-determinism into our programs.
            When serving thousands of small files a second, the limiting factor is not memory, but
            file handles. Using lazy I/O, file handles may not be freed immediately, leading to
            resource exhaustion. To deal with this, WAI uses <glossterm>conduits</glossterm>.</para>
     <note>
      <para>Versions of WAI before 1.0 used enumerators in place of conduits. While both conduits
            and enumerators solve the same basic problem, experience showed that enumerators were
            too constricting in their inversion of control approach, making it difficult to
            structure more complicated systems like a streaming proxy server. Conduits were designed
            with the express purpose of making a better WAI.</para>
     </note>
     <para>The data type relevant to us now is a <glossterm>source</glossterm>. A source produces a stream of
            data, producing a single chunk at a time. In the case of WAI, the request body would be
            a source passed to the application, and the response body would be a source returned
            from the application.</para>
     <para>There are two further optimizations: many systems provide a sendfile system call, which sends a file directly to a socket, bypassing a lot of the memory copying inherent in more general I/O system calls. Additionally, there is a datatype in Haskell called <literal>Builder</literal> which allows efficient copying of bytes into buffers.</para>
     <para>The WAI response body therefore has three constructors: one for pure builders
                (<literal>ResponseBuilder</literal>), one for a source of builders (<literal>ResponseSource</literal>) and one for files (<literal>ResponseFile</literal>).</para>
    </section>
    <section>
     <title>Request Body</title>
     <para/>
     <para>In order to avoid the need to load the entire request body into memory, we use
            sources here as well. Since the purpose of these values are for reading (not writing),
            we use <literal>ByteString</literal>s in place of <literal>Builder</literal>s. There is a record inside <literal>Request</literal> called
                <literal>requestBody</literal>, with type <literal>BufferedSource IO
                ByteString</literal>. We can use all of the standard conduit functions to interact
            with this source.</para>
     <para>The request body could in theory contain any type of data, but the most common are URL encoded and multipart form data. The <function>wai-extra</function> package contains built-in support for parsing these in a memory-efficient manner.</para>
    </section>
   </section>
   <section>
    <title>Hello World</title>
    <para/>
    <para>To demonstrate the simplicity of WAI, let's look at a hello world example. In this example, we're going to use the OverloadedStrings language extension to avoid explicitly packing string values into bytestrings.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.HTTP.Types (status200)
import Network.Wai.Handler.Warp (run)

application _ = return $
  responseLBS status200 [("Content-Type", "text/plain")] "Hello World"

main = run 3000 application</programlisting>
    <para>Lines 2 through 4 perform our imports. Warp is provided by the <function>warp</function> package, and is the premiere WAI backend. WAI is also built on top of the <function>http-types</function> package, which provides a number of datatypes and convenience values, including <literal>status200</literal>.</para>
    <para>First we define our application. Since we don't care about the specific request parameters, we ignore the argument to the function. For any request, we are returning a response with status code 200 ("OK"), and text/plain content type and a body containing the words "Hello World". Pretty straight-forward.</para>
   </section>
   <section>
    <title>Middleware</title>
    <para/>
    <para>In addition to allowing our applications to run on multiple backends without code changes, the WAI allows us another benefits: middleware. Middleware is essentially an <glossterm>application transformer</glossterm>, taking one application and returning another one.</para>
    <para>Middleware components can be used to provide lots of services: cleaning up URLs,
                                                  authentication, caching, JSON-P requests. But
                                                  perhaps the most useful and most intuitive
                                                  middleware is gzip compression. The middleware
                                                  works very simply: it parses the request headers
                                                  to determine if a client supports compression, and
                                                  if so compresses the response body and adds the
                                                  appropriate response header.</para>
    <para>The great thing about middlewares is that they are unobtrusive. Let's see how we would apply the gzip middleware to our hello world application.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Network.Wai
import Network.Wai.Handler.Warp (run)
import Network.Wai.Middleware.Gzip (gzip, def)
import Network.HTTP.Types (status200)

application _ = return $ responseLBS status200 [("Content-Type", "text/plain")]
                       "Hello World"

main = run 3000 $ gzip def application</programlisting>
    <para>We added an import line to actually have access to the middleware, and then simply applied gzip to our application. You can also <emphasis>chain together</emphasis> multiple middlewares: a line such as <literal>gzip False $ jsonp $ othermiddleware $ myapplication</literal> is perfectly valid. One word of warning: the order the middleware is applied can be important. For example, jsonp needs to work on uncompressed data, so if you apply it after you apply gzip, you'll have trouble.</para>
   </section>
  </chapter>
  <chapter>
   <title>Settings Types</title>
   <para/>
   <para/>
   <para>Let's say you're writing a webserver. You want the server to take a port to listen on, and an
   application to run. So you create the following function:</para>
   <programlisting language="haskell">run :: Int -&gt; Application -&gt; IO ()</programlisting>
   <para>But suddenly you realize that some people will want to customize their timeout durations. So
   you modify your API:</para>
   <programlisting language="haskell">run :: Int -&gt; Int -&gt; Application -&gt; IO ()</programlisting>
   <para>So, which <literal>Int</literal> is the timeout, and which is the port? Well, you could create
   some type aliases, or comment your code. But there's another problem creeping into our code: this
    <literal>run</literal> function is getting unmanageable. Soon we'll need to take an extra
   parameter to indicate how exceptions should be handled, and then another one to control which
   host to bind to, and so on.</para>
   <para>So a more extensible solution is to introduce a settings datatype:</para>
   <programlisting language="haskell">data Settings = Settings
    { settingsPort :: Int
    , settingsHost :: String
    , settingsTimeout :: Int
    }</programlisting>
   <para>And this makes the calling code almost self-documenting:</para>
   <programlisting language="haskell">run Settings
    { settingsPort = 8080
    , settingsHost = "127.0.0.1"
    , settingsTimeout = 30
    } myApp</programlisting>
   <para>Great, couldn't be clearer, right? True, but what happens when you have 50 settings to your
   webserver. Do you really want to have to specify all of those each time? Of course not. So
   instead, the webserver should provide a set of defaults:</para>
   <programlisting language="haskell">defaultSettings = Settings 3000 "127.0.0.1" 30</programlisting>
   <para>And now, instead of needing to write that long bit of code above, we can get away with:</para>
   <programlisting language="haskell">run defaultSettings { settingsPort = 8080 } myApp -- (1)</programlisting>
   <para>This is great, except for one minor hitch. Let's say we now decide to add an extra record to
    <literal>Settings</literal>. Any code out in the wild looking like
   this:<programlisting language="haskell">run (Settings 8080 "127.0.0.1" 30) myApp -- (2)</programlisting>will
   be broken, since the <literal>Settings</literal> constructor now takes 4 arguments. The proper
   thing to do would be to bump the major version number so that dependent packages don't get
   broken. But having to change major versions for every minor setting you add is a nuisance. The
   solution? Don't export the <literal>Settings</literal> constructor:</para>
   <programlisting language="haskell">module MyServer
    ( Settings
    , settingsPort
    , settingsHost
    , settingsTimeout
    , run
    , defaultSettings
    ) where</programlisting>
   <para>With this approach, no one can write code like (2), so you can freely add new records without
   any fear of code breaking.</para>
   <para>The one downside of this approach is that it's not immediately obvious from the Haddocks that
   you can actually change the settings via record syntax. That's the point of this chapter: to
   clarify what's going on in the libraries that use this technique.</para>
   <para>I personally use this technique in a few places, feel free to have a look at the Haddocks to
   see what I mean.</para>
   <itemizedlist>
    <listitem>
     <para>Warp: <function>Settings</function>
     </para>
    </listitem>
    <listitem>
     <para>http-conduit: <function>Request</function> and
     <function>ManagerSettings</function>
     </para>
    </listitem>
    <listitem>
     <para>xml-conduit<itemizedlist>
       <listitem>
        <para>Parsing: <function>ParseSettings</function>
        </para>
       </listitem>
       <listitem>
        <para>Rendering: <function>RenderSettings</function>
        </para>
       </listitem>
      </itemizedlist>
     </para>
    </listitem>
   </itemizedlist>
   <para>As a tangential issue, <literal>http-conduit</literal> and <literal>xml-conduit</literal> actually
   create instances of the <function>Default</function> typeclass instead of
   declaring a brand new identifier. This means you can just type <literal>def</literal> instead of
    <literal>defaultParserSettings</literal>.</para>
  </chapter>
  <chapter>
   <title>http-conduit</title>
   <para/>
   <para/>
   <para>Most of Yesod is about serving content over HTTP. But that's only half the story: someone has
   to receive it. And even when you're writing a web app, sometimes that someone will be you. If you
   want to consume content from other services or interact with RESTful APIs, you'll need to write
   client code. And the recommended approach for that is <function>http-conduit</function>.</para>
   <para>This chapter is not directly connected to Yesod, and will be generally useful for anyone
   wanting to make HTTP requests.</para>
   <section>
    <title>Synopsis</title>
    <para/>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit -- the main module

-- The streaming interface uses conduits
import Data.Conduit
import Data.Conduit.Binary (sinkFile)

import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    -- Simplest query: just download the information from the given URL as a
    -- lazy ByteString.
    simpleHttp "http://www.example.com/foo.txt" &gt;&gt;= L.writeFile "foo.txt"

    -- Use the streaming interface instead. We need to run all of this inside a
    -- ResourceT, to ensure that all our connections get properly cleaned up in
    -- the case of an exception.
    runResourceT $ do
        -- We need a Manager, which keeps track of open connections. simpleHttp
        -- creates a new manager on each run (i.e., it never reuses
        -- connections).
        manager &lt;- liftIO $ newManager def

        -- A more efficient version of the simpleHttp query above. First we
        -- parse the URL to a request.
        req &lt;- liftIO $ parseUrl "http://www.example.com/foo.txt"

        -- Now get the response
        res &lt;- http req manager

        -- And finally stream the value to a file
        responseBody res $$ sinkFile "foo.txt"

        -- Make it a POST request, don't follow redirects, and accept any
        -- status code.
        let req2 = req
                { method = "POST"
                , redirectCount = 0
                , checkStatus = \_ _ -&gt; Nothing
                }
        res2 &lt;- http req2 manager
        responseBody res2 $$ sinkFile "post-foo.txt"</programlisting>
   </section>
   <section>
    <title>Concepts</title>
    <para/>
    <para>The simplest way to make a request in <literal>http-conduit</literal> is with the
    <literal>simpleHttp</literal> function. This function takes a <literal>String</literal> giving a URL
   and returns a <literal>ByteString</literal> with the contents of that URL. But under the surface,
   there are a few more steps:</para>
    <itemizedlist>
     <listitem>
      <para>A new connection <literal>Manager</literal> is allocated.</para>
     </listitem>
     <listitem>
      <para>The URL is parsed to a <literal>Request</literal>. If the URL is invalid, then an exception is
    thrown.</para>
     </listitem>
     <listitem>
      <para>The HTTP request is made, following any redirects from the server.</para>
     </listitem>
     <listitem>
      <para>If the response has a status code outside the 200-range, an exception is thrown.</para>
     </listitem>
     <listitem>
      <para>The response body is read into memory and returned.</para>
     </listitem>
     <listitem>
      <para>
       <literal>runResourceT</literal> is called, which will free up any resources (e.g., the open
    socket to the server).</para>
     </listitem>
    </itemizedlist>
    <para>If you want more control of what's going on, then you can configure any of the steps above
   (plus a few more) by explicitly creating a <literal>Request</literal> value, allocating your
    <literal>Manager</literal> manually, and using the <literal>http</literal> and
    <literal>httpLbs</literal> functions.</para>
   </section>
   <section>
    <title>Request</title>
    <para/>
    <para>The easiest way to creating a <literal>Request</literal> is with the <literal>parseUrl</literal>
   function. This function will return a value in any <literal>Failure</literal> monad, such as
    <literal>Maybe</literal> or <literal>IO</literal>. The last of those is the most commonly used, and
   results in a runtime exception whenever an invalid URL is provided. However, you can use a
   different monad if, for example, you want to validate user input.</para>
    <programlisting language="haskell">import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args &lt;- getArgs
    case args of
        [urlString] -&gt;
            case parseUrl urlString of
                Nothing -&gt; putStrLn "Sorry, invalid URL"
                Just req -&gt; withManager $ \manager -&gt; do
                    Response _ _ _ lbs &lt;- httpLbs req manager
                    liftIO $ L.putStr lbs
        _ -&gt; putStrLn "Sorry, please provide exactly one URL"</programlisting>
    <para>The <literal>Request</literal> type is abstract so that <literal>http-conduit</literal> can add new
   settings in the future without breaking the API (see the Settings Type
   chapter for more information). In order to make changes to individual records, you use record
   notation. For example, a modification to our program that issues <literal>HEAD</literal> requests
   and prints the response headers would be:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Network.HTTP.Conduit
import System.Environment (getArgs)
import qualified Data.ByteString.Lazy as L
import Control.Monad.IO.Class (liftIO)

main :: IO ()
main = do
    args &lt;- getArgs
    case args of
        [urlString] -&gt;
            case parseUrl urlString of
                Nothing -&gt; putStrLn "Sorry, invalid URL"
                Just req -&gt; withManager $ \manager -&gt; do
                    let reqHead = req { method = "HEAD" }
                    Response status _ headers _ &lt;- http reqHead manager
                    liftIO $ do
                        print status
                        mapM_ print headers
        _ -&gt; putStrLn "Sorry, please provide example one URL"</programlisting>
    <para>There are a number of different configuration settings in the API, some noteworthy ones
   are:</para>
    <variablelist>
     <varlistentry>
      <term>proxy</term>
      <listitem>
       <para>Allows you to pass the request through the given proxy server.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>redirectCount</term>
      <listitem>
       <para>Indicate how many redirects to follow. Default is 10.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>checkStatus</term>
      <listitem>
       <para>Check the status code of the return value. By default, gives an exception for any non-2XX
     response.</para>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term>requestBody</term>
      <listitem>
       <para>The request body to be sent. Be sure to also update the <literal>method</literal>. For the
     common case of url-encoded data, you can use the <literal>urlEncodedBody</literal> function.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </section>
   <section>
    <title>Manager</title>
    <para/>
    <para>The connection manager allows you to reuse connections. When making multiple queries to a
   single server (e.g., accessing Amazon S3), this can be critical for creating efficient code. A
   manager will keep track of multiple connections to a given server (taking into account port and
   SSL as well), automatically reaping unused connections as needed. When you make a request,
    <literal>http-conduit</literal> first tries to check out an existing connection. When you're
   finished with the connection (if the server allows keep-alive), the connection is returned to the
   manager. If anything goes wrong, the connection is closed.</para>
    <para>To keep our code exception-safe, we use the <literal>ResourceT</literal> monad transformer. All
   this means for you is that your code needs to be wrapped inside a call to
    <literal>runResourceT</literal>, either implicitly or explicitly, and that code inside that block
   will need to <literal>liftIO</literal> to perform normal IO actions.</para>
    <para>There are two ways you can get ahold of a manager. <literal>newManager</literal> will return a
   manager that will not be automatically closed (you can use <literal>closeManager</literal> to do so
   manually), while <literal>withManager</literal> will start a new <literal>ResourceT</literal> block,
   allow you to use the manager, and then automatically close the <literal>ResourceT</literal> when
   you're done. If you want to use a <literal>ResourceT</literal> for an entire application, and have
   no need to close it, you should probably use <literal>newManager</literal>.</para>
    <para>One other thing to point out: you obviously don't want to create a new manager for each and
   every request; that would defeat the whole purpose. You should create your
    <literal>Manager</literal> early and then share it.</para>
   </section>
   <section>
    <title>Response</title>
    <para/>
    <para>The <literal>Response</literal> datatype has three pieces of information: the status code, the
   response headers, and the response body. The first two are straight-forward; let's discuss the
   body.</para>
    <para>The <literal>Response</literal> type has a type variable to allow the response body to be of
   multiple types. If you want to use <literal>http-conduit</literal>'s streaming interface, you want
   this to be a <literal>Source</literal>. For the simple interface, it will be a lazy
    <literal>ByteString</literal>. One thing to note is that, even though we use a lazy
    <literal>ByteString</literal>, <emphasis>the entire response is held in memory</emphasis>. In other words, we
   perform no lazy I/O in this package.</para>
    <note>
     <para>The <literal>conduit</literal> package does provide a lazy module which would allow you to
   read this value in lazily, but like any lazy I/O, it's a bit unsafe, and definitely
   non-deterministic. If you need it though, you can use it.</para>
    </note>
   </section>
   <section>
    <title>http and httpLbs</title>
    <para/>
    <para>So let's tie it together. The <literal>http</literal> function gives you access to the streaming
   interface (i.e., it returns a <literal>Response</literal> using a <literal>BufferedSource</literal>)
   while <literal>httpLbs</literal> returns a lazy <literal>ByteString</literal>. Both of these return
   values in the <literal>ResourceT</literal> transformer so that they can access the
    <literal>Manager</literal> and have connections handled properly in the case of exceptions.</para>
    <note>
     <para>If you want to ignore the remainder of a large response body, you can connect to the
    <literal>sinkNull</literal> sink. The underlying connection will automatically be closed,
   preventing you from having to read a large response body over the network.</para>
    </note>
   </section>
  </chapter>
  <chapter>
   <title>xml-conduit</title>
   <para/>
   <para/>
   <para>Many developers cringe at the thought of dealing with XML files. XML has the reputation of
   having a complicated data model, with obfuscated libraries and huge layers of complexity sitting
   between you and your goal. I'd like to posit that a lot of that pain is actually a language and
   library issue, not inherent to XML.</para>
   <para>Once again, Haskell's type system allows us to easily break down the problem to its most basic
   form. The <function>xml-types</function> package neatly deconstructs the XML data model (both a
   streaming and DOM-based approach) into some simple ADTs. Haskell's standard immutable data
   structures make it easier to apply transforms to documents, and a simple set of functions makes
   parsing and rendering a breeze.</para>
   <para>We're going to be covering the <function>xml-conduit</function> package. Under
   the surface, this package uses a lot of the approaches Yesod in general does for high
   performance: <function>blaze-builder</function>, <function>text</function>,
    <function>conduit</function> and <function>attoparsec</function>. But from a
   user perspective, it provides everything from the simplest APIs
    (<literal>readFile</literal>/<literal>writeFile</literal>) through full control of XML event
   streams.</para>
   <para>In addition to <literal>xml-conduit</literal>, there are a few related packages that
   come into play, like <function>xml-hamlet</function> and <function>xml2html</function>. We'll cover both how to use all these packages, and when they should be
   used.</para>
   <section>
    <title>Synopsis</title>
    <para/>
    <figure xml:id="conceptId-x-3">
     <title>Input XML file</title>
     <programlisting>&lt;document title="My Title"&gt;
    &lt;para&gt;This is a paragraph. It has &lt;em&gt;emphasized&lt;/em&gt; and &lt;strong&gt;strong&lt;/strong&gt; words.&lt;/para&gt;
    &lt;image href="myimage.png"/&gt;
&lt;/document&gt;</programlisting>
    </figure>
    <figure xml:id="conceptId-x-6">
     <title>Haskell code</title>
     <programlisting language="haskell">{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile, writeFile)
import Text.XML
import Text.Hamlet.XML

main :: IO ()
main = do
    -- readFile will throw any parse errors as runtime exceptions
    -- def uses the default settings
    Document prologue root epilogue &lt;- readFile def "input.xml"

    -- root is the root element of the document, let's modify it
    let root' = transform root

    -- And now we write out. Let's indent our output
    writeFile def
        { rsPretty = True
        } "output.html" $ Document prologue root' epilogue

-- We'll turn out &lt;document&gt; into an XHTML document
transform :: Element -&gt; Element
transform (Element _name attrs children) = Element "html" [] [xml|
&lt;head&gt;
    &lt;title&gt;
        $maybe title &lt;- lookup "title" attrs
            \#{title}
        $nothing
            Untitled Document
&lt;body&gt;
    $forall child &lt;- children
        ^{goNode child}
|]

goNode :: Node -&gt; [Node]
goNode (NodeElement e) = [NodeElement $ goElem e]
goNode (NodeContent t) = [NodeContent t]
goNode (NodeComment _) = [] -- hide comments
goNode (NodeInstruction _) = [] -- and hide processing instructions too

-- convert each source element to its XHTML equivalent
goElem :: Element -&gt; Element
goElem (Element "para" attrs children) =
    Element "p" attrs $ concatMap goNode children
goElem (Element "em" attrs children) =
    Element "i" attrs $ concatMap goNode children
goElem (Element "strong" attrs children) =
    Element "b" attrs $ concatMap goNode children
goElem (Element "image" attrs _children) =
    Element "img" (map fixAttr attrs) [] -- images can't have children
  where
    fixAttr ("href", value) = ("src", value)
    fixAttr x = x
goElem (Element name attrs children) =
    -- don't know what to do, just pass it through...
    Element name attrs $ concatMap goNode children</programlisting>
    </figure>
    <figure xml:id="conceptId-x-9">
     <title>Output XHTML</title>
     <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;
            My Title
        &lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;
            This is a paragraph. It has 
            &lt;i&gt;
                emphasized
            &lt;/i&gt;
            and 
            &lt;b&gt;
                strong
            &lt;/b&gt;
            words.
        &lt;/p&gt;
        &lt;img src="myimage.png"/&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
    </figure>
   </section>
   <section>
    <title>Types</title>
    <para/>
    <para>Let's take a bottom-up approach to analyzing types. This section will also serve as a primer on
   the XML data model itself, so don't worry if you're not completely familiar with it.</para>
    <para>I think the first place where Haskell really shows its strength is with the
    <function>Name</function> datatype. Many languages (like Java) struggle
   with properly expressing names. The issue is that there are in fact three components to a name:
   its local name, its namespace (optional), and its prefix (also optional). Let's look at some XML
   to explain:</para>
    <programlisting>&lt;no-namespace/&gt;
&lt;no-prefix xmlns="first-namespace" first-attr="value1"/&gt;
&lt;foo:with-prefix xmlns:foo="second-namespace" foo:second-attr="value2"/&gt;</programlisting>
    <para>The first tag has a local name of <literal>no-namespace</literal>, and no
   namespace or prefix. The second tag (local name: <literal>no-prefix</literal>) <emphasis>also</emphasis> has no prefix, but it does have a namespace (<literal>first-namespace</literal>). <literal>first-attr</literal>, however, does <emphasis>not</emphasis>
   inherit that namespace: attribute namespaces must always be explicitly set with a prefix.</para>
    <note>
     <para>Namespaces are almost always URIs of some sort, though there is nothing in any specification
   requiring that it be so.</para>
    </note>
    <para>The third tag has a local name of <literal>with-prefix</literal>, a prefix of
    <literal>foo</literal> and a namespace of <literal>second-namespace</literal>.
   Its attribute has a <literal>second-attr</literal> local name and the same prefix and namespace.
   The <literal>xmlns</literal> and <literal>xmlns:foo</literal> attributes are part of the namespace
   specification, and are not considered attributes of their respective elements.</para>
    <para>So let's review what we need from a name: every name has a local name, and it can optionally
   have a prefix and namespace. Seems like a simple fit for a record type:</para>
    <programlisting language="haskell">data Name = Name
    { nameLocalName :: Text
    , nameNamespace :: Maybe Text
    , namePrefix :: Maybe Text
    }</programlisting>
    <para>According the the XML namespace standard, two names are considered equivalent if they
   have the same localname and namespace. In other words, the prefix is not important. Therefore,
    <literal>xml-types</literal> defines <literal>Eq</literal> and <literal>Ord</literal> instances that
   ignore the prefix.</para>
    <para>The last class instance worth mentioning is <literal>IsString</literal>. It would be
   very tedious to have to manually type out <literal>Name "p" Nothing Nothing</literal>
   every time we want a paragraph. If you turn on <literal>OverloadedStrings</literal>,
    <literal>"p"</literal> will resolve to that all by itself! In addition, the
    <literal>IsString</literal> instance recognizes something called Clark notation, which allows you
   to prefix the namespace surrounded in curly brackets. In other words:</para>
    <programlisting language="haskell">"{namespace}element" == Name "element" (Just "namespace") Nothing
"element" == Name "element" Nothing Nothing</programlisting>
    <section>
     <title>The Four Types of Nodes</title>
     <para/>
     <para>XML documents are a tree of nested nodes. There are in fact four different types of nodes
   allowed: elements, content (i.e., text), comments, and processing instructions.</para>
     <note>
      <para>You may not be familiar with that last one, it's less commonly used. It is marked
   up as:<programlisting>&lt;?target data?&gt;</programlisting>There are two
   surprising facts about processing instructions (PIs):<itemizedlist>
        <listitem>
         <para>PIs don't have attributes. While often times you'll see processing instructions
     that appear to have attributes, there are in fact no rules about that data of an
     instruction.</para>
        </listitem>
        <listitem>
         <para>The <literal>&lt;?xml ...?&gt;</literal> stuff at the beginning of a document is not
     a processing instruction. It is simply the beginning of the document (known as the XML
     declaration), and happens to look an awful lot like a PI. The difference though is that the
      <literal>&lt;?xml ...?&gt;</literal> line will not appear in your parsed content.</para>
        </listitem>
       </itemizedlist>
      </para>
     </note>
     <para>Since processing instructions have two pieces of text associated with them (the target and the
   data), we have a simple data type:</para>
     <programlisting language="haskell">data Instruction = Instruction
    { instructionTarget :: Text
    , instructionData :: Text
    }</programlisting>
     <para>Comments have no special datatype, since they are just text. But content is an
   interesting one: it could contain either plain text or unresolved entities (e.g.,
    <literal>&amp;copyright-statement;</literal>). <function>xml-types</function> keeps those
   unresolved entities in all the data types in order to completely match the spec. However, in
   practice, it can be very tedious to program against those data types. And in most use cases, an
   unresolved entity is going to end up as an error anyway.</para>
     <para>So the <function>Text.XML</function> module defines its own set
   of datatypes for nodes, elements and documents that removes all unresolved entities. If you need
   to deal with unresolved entities instead, you should use the <function>Text.XML.Unresolved</function> module. From now on, we'll be focusing only on the
    <literal>Text.XML</literal> data types, though they are almost identical to the
    <literal>xml-types</literal> versions.</para>
     <para>Anyway, after that detour: content is just a piece of text, and therefore it too does
   not have a special datatype. The last node type is an element, which contains three pieces of
   information: a name, a list of attributes and a list of children nodes. An attribute has two
   pieces of information: a name and a value. (In <literal>xml-types</literal>, this value could
   contain unresolved entities as well.) So our <literal>Element</literal> is defined as:</para>
     <programlisting language="haskell">data Element = Element
    { elementName :: Name
    , elementAttributes :: [(Name, Text)]
    , elementNodes :: [Node]
    }</programlisting>
     <para>Which of course begs the question: what does a <literal>Node</literal> look like? This
   is where Haskell really shines: its sum types model the XML data model perfectly.</para>
     <programlisting language="haskell">data Node
    = NodeElement Element
    | NodeInstruction Instruction
    | NodeContent Text
    | NodeComment Text</programlisting>
    </section>
    <section>
     <title>Documents</title>
     <para/>
     <para>So now we have elements and nodes, but what about an entire document? Let's just lay out the
   datatypes:</para>
     <programlisting language="haskell">data Document = Document
    { documentPrologue :: Prologue
    , documentRoot :: Element
    , documentEpilogue :: [Miscellaneous]
    }

data Prologue = Prologue
    { prologueBefore :: [Miscellaneous]
    , prologueDoctype :: Maybe Doctype
    , prologueAfter :: [Miscellaneous]
    }

data Miscellaneous
    = MiscInstruction Instruction
    | MiscComment Text

data Doctype = Doctype
    { doctypeName :: Text
    , doctypeID :: Maybe ExternalID
    }

data ExternalID
    = SystemID Text
    | PublicID Text Text</programlisting>
     <para>The XML spec says that a document has a single root element
    (<literal>documentRoot</literal>). It also has an optional doctype statement. Before and after
   both the doctype and the root element, you are allowed to have comments and processing
   instructions. (You can also have whitespace, but that is ignored in the parsing.)</para>
     <para>So what's up with the doctype? Well, it specifies the root element of the document, and then
   optional public and system identifiers. These are used to refer to DTD files, which give more
   information about the file (e.g., validation rules, default attributes, entity resolution). Let's
   see some examples:</para>
     <programlisting>&lt;!DOCTYPE root&gt; &lt;!-- no external identifier --&gt;
&lt;!DOCTYPE root SYSTEM "root.dtd"&gt; &lt;!-- a system identifier --&gt;
&lt;!DOCTYPE root PUBLIC "My Root Public Identifier" "root.dtd"&gt; &lt;!-- public identifiers have a system ID as well --&gt;</programlisting>
     <para>And that, my friends, is the entire XML data model. For many parsing purposes, you'll
   be able to simply ignore the entire <literal>Document</literal> datatype and go immediately to the
    <literal>documentRoot</literal>.</para>
    </section>
    <section>
     <title>Events</title>
     <para/>
     <para>In addition to the document API, <literal>xml-types</literal> defines an <function>Event</function> datatype. This can be used for constructing
   streaming tools, which can be much more memory efficient for certain kinds of processing (eg,
   adding an extra attribute to all elements). We will not be covering the streaming API currently,
   though it should look very familiar after analyzing the document API.</para>
     <note>
      <para>You can see an example of the streaming API in the Sphinx case
    study.</para>
     </note>
    </section>
   </section>
   <section>
    <title>Text.XML</title>
    <para/>
    <para>The recommended entry point to xml-conduit is the <function>Text.XML</function> module. This module exports all of the datatypes you'll need to
   manipulate XML in a DOM fashion, as well as a number of different approaches for parsing and
   rendering XML content. Let's start with the simple
   ones:<programlisting language="haskell">readFile  :: ParseSettings  -&gt; FilePath -&gt; IO Document
writeFile :: RenderSettings -&gt; FilePath -&gt; Document -&gt; IO ()</programlisting>This
   introduces the <literal>ParseSettings</literal> and <literal>RenderSettings</literal> datatypes. You can use these to modify the behavior of the parser and
   renderer, such as adding character entities and turning on pretty (i.e., indented) output. Both
   these types are instances of the <function>Default</function>
   typeclass, so you can simply use <literal>def</literal> when these need to be supplied.
   That is how we will supply these values through the rest of the chapter; please see the API docs
   for more information.</para>
    <para>It's worth pointing out that in addition to the file-based API, there is also a text- and
   bytestring-based API. The bytestring-powered functions all perform intelligent encoding
   detections, and support UTF-8, UTF-16 and UTF-32, in either big or little endian, with and
   without a Byte-Order Marker (BOM). All output is generated in UTF-8.</para>
    <para>For complex data lookups, we recommend using the higher-level cursors API. The
   standard <literal>Text.XML</literal> API not only forms the basis for that higher level, but is
   also a great API for simple XML transformations and for XML generation. See the synopsis for an
   example.</para>
    <section>
     <title>A note about file paths</title>
     <para/>
     <para>In the type signature above, we have a type <literal>FilePath</literal>. However, <emphasis role="bold">this isn't
     <literal>Prelude.FilePath</literal>
      </emphasis>. The standard <literal>Prelude</literal> defines a type
   synonym <literal>type FilePath = [Char]</literal>. Unfortunately, there are many limitations to
   using such an approach, including confusion of filename character encodings and differences in
   path separators.</para>
     <para>Instead, <literal>xml-conduit</literal> uses the <function>system-filepath</function> package,
   which defines an abstract <literal>FilePath</literal> type. I've personally found this to be a much
   nicer approach to work with. The package is fairly easy to follow, so I won't go into details
   here. But I do want to give a few quick explanations of how to use it:</para>
     <itemizedlist>
      <listitem>
       <para>Since a <literal>FilePath</literal> is an instance of <literal>IsString</literal>, you can type
    in regular strings and they will be treated properly, as long as the
     <literal>OverloadedStrings</literal> extension is enabled. (I highly recommend enabling it
    anyway, as it makes dealing with <literal>Text</literal> values much more pleasant.)</para>
      </listitem>
      <listitem>
       <para>If you need to explicitly convert to or from <literal>Prelude</literal>'s
     <literal>FilePath</literal>, you should use the
     <function>encodeString</function> and
     <function>decodeString</function>, respectively. This
    takes into account file path encodings.</para>
      </listitem>
      <listitem>
       <para>Instead of manually splicing together directory names and file names with extensions, use the
    operators in the <literal>Filesystem.Path.CurrentOS</literal> module, e.g. <literal>myfolder &lt;/&gt;
     filename &lt;.&gt; extension</literal>.</para>
      </listitem>
     </itemizedlist>
    </section>
   </section>
   <section>
    <title>Cursor</title>
    <para/>
    <para>Suppose you want to pull the title out of an XHTML document. You could do so with the
    <literal>Text.XML</literal> interface we just described, using standard pattern matching on the
   children of elements. But that would get very tedious, very quickly. Probably the gold standard
   for these kinds of lookups is XPath, where you would be able to write <literal>/html/head/title</literal>. And that's exactly what inspired the design of the <function>Text.XML.Cursor</function> combinators.</para>
    <para>A cursor is an XML node that knows its location in the tree; it's able to traverse
   upwards, sideways, and downwards. (Under the surface, this is achieved by <link xlink:href="http://www.haskell.org/haskellwiki/Tying_the_Knot">tying
    the knot</link>.) There are two functions available for creating cursors from
    <literal>Text.XML</literal> types: <literal>fromDocument</literal> and
   <literal>fromNode</literal>.</para>
    <para>We also have the concept of an <glossterm>Axis</glossterm>, defined as <literal>type Axis = Cursor -&gt; [Cursor]</literal>. It's easiest to get started by looking at
   example axes: child returns zero or more cursors that are the child of the current one, parent
   returns the single parent cursor of the input, or an empty list if the input is the root element,
   and so on.</para>
    <para>In addition, there are some axes that take predicates. <literal>element</literal> is a commonly
   used function that filters down to only elements which match the given name. For example,
    <literal>element "title"</literal> will return the input element if its name is "title", or an
   empty list otherwise.</para>
    <para>Another common function which isn't quite an axis is <literal>content :: Cursor -&gt;
    [Text]</literal>. For all content nodes, it returns the contained text; otherwise, it returns an
   empty list.</para>
    <para>And thanks to the monad instance for lists, it's easy to string all of these
   together. For example, to do our title lookup, we would write the following program:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile)
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc &lt;- readFile def "test.xml"
    let cursor = fromDocument doc
    print $ T.concat $
            child cursor &gt;&gt;= element "head" &gt;&gt;= child
                         &gt;&gt;= element "title" &gt;&gt;= descendant &gt;&gt;= content</programlisting>
    <para>What this says is:</para>
    <orderedlist>
     <listitem>
      <para>Get me all the child nodes of the root element</para>
     </listitem>
     <listitem>
      <para>Filter down to only the elements named "head"</para>
     </listitem>
     <listitem>
      <para>Get all the children of all those head elements</para>
     </listitem>
     <listitem>
      <para>Filter down to only the elements named "title"</para>
     </listitem>
     <listitem>
      <para>Get all the descendants of all those title elements. (A descendant is a child, or a
    descendant of a child. Yes, that was a recursive definition.)</para>
     </listitem>
     <listitem>
      <para>Get only the text nodes.</para>
     </listitem>
    </orderedlist>
    <para>So for the input document:</para>
    <programlisting>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;My &lt;b&gt;Title&lt;/b&gt;&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;Foo bar baz&lt;/p&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
    <para>We end up with the output <literal>My Title</literal>. This is all well and good, but it's much
   more verbose than the XPath solution. To combat this verbosity, Aristid Breitkreuz added a set of
   operators to the Cursor module to handle many common cases. So we can rewrite our example as:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile)
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc &lt;- readFile def "test.xml"
    let cursor = fromDocument doc
    print $ T.concat $
        cursor $/ element "head" &amp;/ element "title" &amp;// content</programlisting>
    <para>
     <literal>$/</literal> says to apply the axis on the right to the children of
   the cursor on the left. <literal>&amp;/</literal> is almost identical, but is instead
   used to combine two axes together. This is a general rule in <literal>Text.XML.Cursor</literal>: operators beginning with $ directly apply an axis, while &amp; will
   combine two together. <literal>&amp;//</literal> is used for applying an axis to all
   descendants.</para>
    <para>Let's go for a more complex, if more contrived, example. We have a document that looks
   like:</para>
    <programlisting>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Headings&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;hgroup&gt;
            &lt;h1&gt;Heading 1 foo&lt;/h1&gt;
            &lt;h2 class="foo"&gt;Heading 2 foo&lt;/h2&gt;
        &lt;/hgroup&gt;
        &lt;hgroup&gt;
            &lt;h1&gt;Heading 1 bar&lt;/h1&gt;
            &lt;h2 class="bar"&gt;Heading 2 bar&lt;/h2&gt;
        &lt;/hgroup&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
    <para>We want to get the content of all the <literal>h1</literal> tags which precede an
    <literal>h2</literal> tag with a <literal>class</literal> attribute of "bar". To perform this
   convoluted lookup, we can write:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Prelude hiding (readFile)
import Text.XML
import Text.XML.Cursor
import qualified Data.Text as T

main :: IO ()
main = do
    doc &lt;- readFile def "test2.xml"
    let cursor = fromDocument doc
    print $ T.concat $
        cursor $// element "h2"
               &gt;=&gt; attributeIs "class" "bar"
               &gt;=&gt; precedingSibling
               &gt;=&gt; element "h1"
               &amp;// content</programlisting>
    <para>Let's step through that. First we get all h2 elements in the document.
    (<literal>$//</literal> gets all descendants of the root element.) Then we filter out only those
   with <literal>class=bar</literal>. That <literal>&gt;=&gt;</literal> operator is actually
   the standard operator from <function>Control.Monad</function>; yet another advantage
   of the monad instance of lists. <literal>precedingSibling</literal> finds all nodes that come
   before our node <emphasis role="bold">and</emphasis> share the same parent. (There is also a <literal>preceding</literal> axis which takes all elements earlier in the tree.) We then take just the
    <literal>h1</literal> elements, and then grab their content.</para>
    <note>
     <para>The equivalent XPath, for comparison, would be <literal>//h2[@class =
    'bar']/preceding-sibling::h1//text()</literal>.</para>
    </note>
    <para>While the cursor API isn't quite as succinct as XPath, it has the advantages of being standard
   Haskell code, and of type safety.</para>
   </section>
   <section>
    <title>xml-hamlet</title>
    <para/>
    <para>Thanks to the simplicity of Haskell's data type system, creating
            XML content with the <literal>Text.XML API</literal> is easy, if a bit verbose. The
            following code:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
import Text.XML
import Prelude hiding (writeFile)

main :: IO ()
main =
    writeFile def "test3.xml" $ Document (Prologue [] Nothing []) root []
  where
    root = Element "html" []
        [ NodeElement $ Element "head" []
            [ NodeElement $ Element "title" []
                [ NodeContent "My "
                , NodeElement $ Element "b" []
                    [ NodeContent "Title"
                    ]
                ]
            ]
        , NodeElement $ Element "body" []
            [ NodeElement $ Element "p" []
                [ NodeContent "foo bar baz"
                ]
            ]
        ]</programlisting>
    <para>produces</para>
    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;html&gt;&lt;head&gt;&lt;title&gt;My &lt;b&gt;Title&lt;/b&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;foo bar baz&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</programlisting>
    <para>This is leaps and bounds easier than having to deal with an imperative, mutable-value-based API
   (cough, Java, cough), but it's far from pleasant, and obscures what we're really trying to
   achieve. To simplify things, we have the <function>xml-hamlet</function> package, which using
   Quasi-Quotation to allow you to type in your XML in a natural syntax. For example, the above
   could be rewritten as:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
import Text.XML
import Text.Hamlet.XML
import Prelude hiding (writeFile)

main :: IO ()
main =
    writeFile def "test3.xml" $ Document (Prologue [] Nothing []) root []
  where
    root = Element "html" [] [xml|
&lt;head&gt;
    &lt;title&gt;
        My #
        &lt;b&gt;Title
&lt;body&gt;
    &lt;p&gt;foo bar baz
|]</programlisting>
    <para>Let's make a few points:</para>
    <itemizedlist>
     <listitem>
      <para>The syntax is almost identical to normal Hamlet, except URL-interpolation (@{...}) has been
    removed. As such:<itemizedlist>
        <listitem>
         <para>No close tags.</para>
        </listitem>
        <listitem>
         <para>Whitespace-sensitive.</para>
        </listitem>
        <listitem>
         <para>If you want to have whitespace at the end of a line, use a # at the end. At the beginning,
      use a backslash.</para>
        </listitem>
       </itemizedlist>
      </para>
     </listitem>
     <listitem>
      <para>An <literal>xml</literal> interpolation will return a list of <literal>Node</literal>s. So you still need to wrap up the output in all the normal
                    <literal>Document</literal> and root <literal>Element</literal> constructs.</para>
     </listitem>
     <listitem>
      <para>There is no support for the special <literal>.class</literal> and
                    <literal>#id</literal> attribute forms.</para>
     </listitem>
    </itemizedlist>
    <para>And like normal Hamlet, you can use variable interpolation and control structures. So a
   slightly more complex example would be:</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
import Text.XML
import Text.Hamlet.XML
import Prelude hiding (writeFile)
import Data.Text (Text, pack)

data Person = Person
    { personName :: Text
    , personAge :: Int
    }

people :: [Person]
people =
    [ Person "Michael" 26
    , Person "Miriam" 25
    , Person "Eliezer" 3
    , Person "Gavriella" 1
    ]

main :: IO ()
main =
    writeFile def "people.xml" $ Document (Prologue [] Nothing []) root []
  where
    root = Element "html" [] [xml|
&lt;head&gt;
    &lt;title&gt;Some People
&lt;body&gt;
    &lt;h1&gt;Some People
    $if null people
        &lt;p&gt;There are no people.
    $else
        &lt;dl&gt;
            $forall person &lt;- people
                ^{personNodes person}
|]

personNodes :: Person -&gt; [Node]
personNodes person = [xml|
&lt;dt&gt;#{personName person}
&lt;dd&gt;#{pack $ show $ personAge person}
|]</programlisting>
    <para>A few more notes:</para>
    <itemizedlist>
     <listitem>
      <para>The caret-interpolation (^{...}) takes a list of nodes, and so can easily embed
                other <literal>xml</literal>-quotations.</para>
     </listitem>
     <listitem>
      <para>Unlike Hamlet, hash-interpolations (#{...}) are not polymorphic, and can <emphasis>only</emphasis> accept <literal>Text</literal> values.</para>
     </listitem>
    </itemizedlist>
   </section>
   <section>
    <title>xml2html</title>
    <para/>
    <para>So far in this chapter, our examples have revolved around XHTML. I've done that so far
   simply because it is likely to be the most familiar form of XML for most of our readers. But
   there's an ugly side to all this that we must acknowledge: not all XHTML will be correct HTML.
   The following discrepancies exist:</para>
    <itemizedlist>
     <listitem>
      <para>There are some void tags (e.g., <literal>img</literal>, <literal>br</literal>) in HTML
    which do not need to have close tags, and in fact are not allowed to.</para>
     </listitem>
     <listitem>
      <para>HTML does not understand self-closing tags, so <literal>&lt;script&gt;&lt;/script&gt;</literal> and
     <literal>&lt;script/&gt;</literal> mean very different things.</para>
     </listitem>
     <listitem>
      <para>Combining the previous two points: you are free to self-close void tags, though to a browser
    it won't mean anything.</para>
     </listitem>
     <listitem>
      <para>In order to avoid quirks mode, you should start your HTML documents with a
     <literal>DOCTYPE</literal> statement.</para>
     </listitem>
     <listitem>
      <para>We do not want the XML declaration <literal>&lt;?xml ...?&gt;</literal> at the top of an HTML
    page</para>
     </listitem>
     <listitem>
      <para>We do not want any namespaces used in HTML, while XHTML is fully namespaced.</para>
     </listitem>
     <listitem>
      <para>The contents of <literal>&lt;style&gt;</literal> and <literal>&lt;script&gt;</literal>
    tags should not be escaped.</para>
     </listitem>
    </itemizedlist>
    <para>That's where the <function>xml2html</function> package comes into play. It provides a
    <function>ToHtml</function> instance for <literal>Node</literal>s,
    <literal>Document</literal>s and <literal>Element</literal>s. In order to use it, just import the
    <function>Text.XML.Xml2Html</function> module.</para>
    <programlisting language="haskell">{-# LANGUAGE OverloadedStrings, QuasiQuotes #-}
import Text.Blaze (toHtml)
import Text.Blaze.Renderer.String (renderHtml)
import Text.XML
import Text.Hamlet.XML
import Text.XML.Xml2Html ()

main :: IO ()
main = putStr $ renderHtml $ toHtml $ Document (Prologue [] Nothing []) root []

root :: Element
root = Element "html" [] [xml|
&lt;head&gt;
    &lt;title&gt;Test
    &lt;script&gt;if (5 &lt; 6 || 8 &gt; 9) alert("Hello World!");
    &lt;style&gt;body &gt; h1 { color: red }
&lt;body&gt;
    &lt;h1&gt;Hello World!
|]</programlisting>
    <para>Outputs: (whitespace added)</para>
    <programlisting>&lt;!DOCTYPE HTML&gt;
&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;Test&lt;/title&gt;
        &lt;script&gt;if (5 &lt; 6 || 8 &gt; 9) alert("Hello World!");&lt;/script&gt;
        &lt;style&gt;body &gt; h1 { color: red }&lt;/style&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;/body&gt;
&lt;/html&gt;</programlisting>
   </section>
  </chapter>
 </part>
</book>
